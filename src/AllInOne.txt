package studio.blacktech.coolqbot.furryblack.common.exception;

public class CantReinitializationException extends InitializationException {

	private static final long serialVersionUID = 1L;

	public CantReinitializationException(String message) {
		super(message);
	}

}
package studio.blacktech.coolqbot.furryblack.common.exception;

public class InitializationException extends Exception {

	private static final long serialVersionUID = 1L;

	public InitializationException(String message) {
		super(message);
	}

}
package studio.blacktech.coolqbot.furryblack.common.exception;

public class NotAFolderException extends InitializationException {

	private static final long serialVersionUID = 1L;

	public NotAFolderException(String message) {
		super(message);
	}

}
package studio.blacktech.coolqbot.furryblack.common;

import java.io.File;
import java.nio.file.Paths;
import java.util.Date;
import java.util.HashMap;

import studio.blacktech.coolqbot.furryblack.entry;
import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.message.Message;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleExecutor;

public class Executor_DEMO extends ModuleExecutor {

	private static final long serialVersionUID = 1L;

	// ==========================================================================================================================================================
	//
	// 此模块为模板模块
	// 用于教学示例用
	//
	// ==========================================================================================================================================================

	// ==========================================================================================================================================================
	//
	// 模块基本配置
	//
	// ==========================================================================================================================================================

	// PACKAGENAME 名称为完整名称
	// 命名规则应为 类型_名称
	private static String MODULE_PACKAGENAME = "Executor_Demo";

	// COMMANDNAME 名称为命令调用的名称
	// 应和PACKAGE名称一致
	private static String MODULE_COMMANDNAME = "demo";

	// DISPLAYNAME 名称为人类可读的友好名称 应该在8个字以内
	private static String MODULE_DISPLAYNAME = "示范模块";

	// DESCRIPTON 为模块功能简介
	private static String MODULE_DESCRIPTION = "示范如何编写模块";

	// 版本号
	// 推荐两段式版本
	// bug修复加个位
	// 任何功能更新都加十位
	// 仅为后个位归零
	private static String MODULE_VERSION = "1.0";

	// 命令用法，数组的每个元素应为一个参数组合用法及其说明
	// 减号左右各一个空格
	private static String[] MODULE_USAGE = new String[] {
			"命令1 - 命令用法1",
			"命令2 - 命令用法2",
			"命令3 - 命令用法3",
			"命令4 - 命令用法4",
	};

	// 如果需要将数据存储为文件 则应写明存储的内容及其用途 有效时限
	public static String[] MODULE_PRIVACY_STORED = new String[] {
			"隐私级别 - 用途"
	};

	// 如果需要将数据存储在内存 则应写明存储的内容及其用途 有效时限
	public static String[] MODULE_PRIVACY_CACHED = new String[] {
			"隐私级别 - 用途"
	};

	// 如果需要获取用户相关的信息 则应写明内容及其用途 且获取的信息不应该储存 如果需要存储则将此功能写入MODULE_PRIVACY_CACHED
	public static String[] MODULE_PRIVACY_OBTAIN = new String[] {
			"隐私级别 - 用途"
	};

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	// 非原子量请勿在声明变量的时候赋值
	// 推荐使用全大写命名
	// 错误：HashMap<String,String> MAP = new HashMap<>();
	// 正确：HashMap<String,String> MAP ;

	private HashMap<String, String> MAP;

	private File FILE_CUSTOM;

	private Thread thread;

	private boolean ENABLE_DEMO = false;

	// ==========================================================================================================================================================
	//
	// 生命周期函数
	//
	// ==========================================================================================================================================================

	/***
	 * 调用模块实例化方法 此处不应执行任何代码
	 *
	 * @throws Exception 发生任何错误应扔出
	 */
	public Executor_DEMO() throws Exception {

		// @formatter:off

		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);

		// @formatter:on

	}

	/**
	 * 生命周期函数 初始化阶段
	 * <p>
	 * 1：初始化配置及数据文件 2：生成所有内存结构 3：读取配置并应用 4：分析 ENABLE_MODE
	 */
	@Override
	public LoggerX init(LoggerX logger) throws Exception {

		// ==================================================================================
		// 1：初始化配置及数据文件

		this.initAppFolder(logger);
		this.initConfFolder(logger);
		this.initDataFolder(logger);
		this.initLogsFolder(logger);
		this.initPropertiesConfigurtion(logger);

		// ==================================================================================
		// 2：生成所有内存结构
		// 应在此处实例化成员变量

		this.MAP = new HashMap<>();

		// 关于文件路径：应使用Paths工具类以及内置的 FOLDER_CONF FOLDER_DATA FOLDER_LOGS来表示文件
		this.FILE_CUSTOM = Paths.get(this.FOLDER_CONF.getAbsolutePath(), "custom.txt").toFile();

		if (!this.FILE_CUSTOM.exists()) { this.FILE_CUSTOM.createNewFile(); }

		// ==================================================================================
		// 3：读取配置
		// NEW_CONFIG=true 为初始化过程中发现配置不存在 创建了新的配置

		if (this.NEW_CONFIG) {
			// CONFIG对象为Java property对象
			this.CONFIG.setProperty("enable", "true");
			this.CONFIG.setProperty("config1", "none");
			this.CONFIG.setProperty("config2", "none");
			this.CONFIG.setProperty("config3", "none");
			this.CONFIG.setProperty("config4", "none");
			// 不要忘记保存
			this.saveConfig();
		} else {
			this.loadConfig();
		}

		// 按需分析配置文件
		this.ENABLE_DEMO = Boolean.parseBoolean(this.CONFIG.getProperty("enable"));

		// 按需初始化内存结构
		this.MAP.put("1", "1");

		// 如果需要包含需要获取所有群成员的功能，不应该在doMessage的时候获取 应通过初始化和增减成员函数来维护一个容器

		// ==================================================================================
		// 4：分析 ENABLE_MODE
		// ENABLE_MODE = false 时，由systemd注册插件时将不会注册
		// 此设计的目的是比如模块被配置禁用
		// 则直接跳注册阶段
		// 模块不需要每次doMessage时都判断 if ( enable )

		if (this.ENABLE_DEMO) {
			this.ENABLE_USER = true;
			this.ENABLE_DISZ = true;
			this.ENABLE_GROP = true;
		}

		return logger;

	}

	/**
	 * 如果有 应在此处初始化工作线程并运行 如果ENABLE_MODE=false则不会注册 则不会执行boot的内容
	 */
	@Override
	public LoggerX boot(LoggerX logger) throws Exception {

		this.thread = new Thread(new Worker());
		this.thread.start();

		return logger;
	}

	/**
	 * 如果需要保存数据 则应该在此处保存数据 注意 这个函数不意味着结束
	 */
	@Override
	public LoggerX save(LoggerX logger) throws Exception {
		return logger;
	}

	/**
	 * 如果有 应在此处打断工作线程 和剩余的关闭逻辑
	 * <p>
	 * 正常关闭情况下执行shut之前将会执行save
	 * <p>
	 * 有可能会使用 /admin init X 强制执行生命周期函数 但是此命令不属于正常使用范畴 可以不考虑此情况
	 */
	@Override
	public LoggerX shut(LoggerX logger) throws Exception {

		// 如果包含子线程 应在此时中断
		this.thread.interrupt();
		this.thread.join();

		return logger;
	}

	/**
	 * 用于管理和debug /admin exec --module=demo xxx xxxx xxx xxxx xxxxx xxxxxxx
	 */
	@Override
	public LoggerX exec(LoggerX logger, Message message) throws Exception {

		return logger;
	}

	/**
	 * 群成员增加时执行
	 */
	@Override
	public void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) {
		// QQ系统通知为
		if (userid == 1000000) { entry.adminInfo("系统消息 - （" + gropid + "）"); }
	}

	/**
	 * 群成员减少时执行
	 */
	@Override
	public void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	/**
	 * 用户发送私聊时执行
	 */
	@Override
	public boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {
		return true;
	}

	/**
	 * 讨论组消息时执行
	 */
	@Override
	public boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {
		return true;
	}

	/***
	 * 群聊消息时执行
	 */
	@Override
	public boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {
		// 不要使用JcpApp.CQ发送消息
		entry.gropInfo(gropid, userid, "MESSAGE");
		return true;
	}

	// ==========================================================================================================================================================
	//
	// 工具函数
	//
	// ==========================================================================================================================================================

	/***
	 * 生成模块报告 数组每个元素就会产生一条消息 避免消息过长
	 */
	@Override
	public String[] generateReport(int mode, Message message, Object... parameters) {
		return null;
	}

	class Worker implements Runnable {

		/**
		 * 模块应当自己负责计划任务 框架不提供统一的计划任务 必须按照此格式写Worker
		 */

		@SuppressWarnings("deprecation")
		@Override
		public void run() {

			// 成员变量

			long time;
			Date date;

			// 最外层循环用于处理发生异常时是否继续运行
			// 休眠被打断会产生InterruptedException

			do {

				try {

					// 实际工作循环
					while (true) {

						// 这是一个比较简约的延时计算
						date = new Date();

						// 假设00:00:00(24:00:00)运行

						// 从00:00:00多少秒后运行
						time = 86400L;
						// 减去当前秒数 以对齐秒 使其能在 xx:xx:00 执行
						time = time - date.getSeconds();
						// 减去当前分钟 以对齐分 使其能在 xx:00:00 执行
						time = time - (date.getMinutes() * 60);
						// 减去当前分钟 以对齐时 使其能在 00:00:00 执行
						time = time - (date.getHours() * 3600);

						// 转换为毫秒
						time = time * 1000;

						// 应当输出log以便于观察定时任务的状况
						entry.getCQ().logInfo(MODULE_PACKAGENAME, "休眠：" + time);

						Thread.sleep(time);

						// 应当输出log以便于观察定时任务的状况
						entry.getCQ().logInfo(MODULE_PACKAGENAME, "执行");

						// 此处执行实际任务

						// 应当输出log以便于观察定时任务的状况
						entry.getCQ().logInfo(MODULE_PACKAGENAME, "结果");

					}

				} catch (Exception exception) {

					// shut时 应打断休眠此时会产生异常

					if (entry.isEnable()) {

						// 如果框架运行中，则遇到了真正意义上的异常，应观察发生了什么
						entry.getCQ().logWarning(MODULE_PACKAGENAME, "异常");
						exception.printStackTrace();

					} else {

						// 如果框架关闭，则并非真的异常 此时将会跳出主循环 结束worker
						entry.getCQ().logInfo(MODULE_PACKAGENAME, "关闭");

					}
				}

			} while (entry.isEnable());
		}
	}
}
package studio.blacktech.coolqbot.furryblack.common;

import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.message.Message;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleExecutor;

public class Executor_NULL extends ModuleExecutor {

	private static final long serialVersionUID = 1L;

	// ==========================================================================================================================================================
	//
	// 模块基本配置
	//
	// ==========================================================================================================================================================

	private static String MODULE_PACKAGENAME = "Executor_NULL";
	private static String MODULE_COMMANDNAME = "null";
	private static String MODULE_DISPLAYNAME = "模板模块";
	private static String MODULE_DESCRIPTION = "模板模块";
	private static String MODULE_VERSION = "1.0";
	private static String[] MODULE_USAGE = new String[] {};
	public static String[] MODULE_PRIVACY_STORED = new String[] {};
	public static String[] MODULE_PRIVACY_CACHED = new String[] {};
	public static String[] MODULE_PRIVACY_OBTAIN = new String[] {};

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	// ==========================================================================================================================================================
	//
	// 生命周期函数
	//
	// ==========================================================================================================================================================

	// @formatter:off

	public Executor_NULL() throws Exception {

		// @formatter:off

		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);

		// @formatter:on

	}

	@Override
	public LoggerX init(LoggerX logger) throws Exception {

		if (this.NEW_CONFIG) {
			this.CONFIG.setProperty("", "");
			this.saveConfig();
		} else {
			this.loadConfig();
		}

		this.ENABLE_USER = false;
		this.ENABLE_DISZ = false;
		this.ENABLE_GROP = false;

		return logger;

	}

	@Override
	public LoggerX boot(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX save(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX shut(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX exec(LoggerX logger, Message message) throws Exception {
		return logger;
	}

	@Override
	public void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {
		return true;
	}

	@Override
	public boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {
		return true;
	}

	@Override
	public boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {
		return true;
	}

	// ==========================================================================================================================================================
	//
	// 工具函数
	//
	// ==========================================================================================================================================================

	@Override
	public String[] generateReport(int mode, Message message, Object... parameters) {
		return null;
	}

}
package studio.blacktech.coolqbot.furryblack.common;

import javax.swing.JOptionPane;

import org.meowy.cqp.jcq.entity.Anonymous;
import org.meowy.cqp.jcq.entity.CoolQ;
import org.meowy.cqp.jcq.entity.GroupFile;
import org.meowy.cqp.jcq.entity.ICQVer;
import org.meowy.cqp.jcq.entity.IMsg;
import org.meowy.cqp.jcq.entity.IRequest;
import org.meowy.cqp.jcq.event.JcqAppAbstract;

/**
 * 本文件是JCQ插件的主类<br>
 * <br>
 * <p>
 * 注意修改json中的class来加载主类，如不设置则利用appid加载，最后一个单词自动大写查找<br>
 * 例：appid(com.example.demo) 则加载类 com.example.Demo<br>
 * 文档地址： https://gitee.com/Sobte/JCQ-CoolQ <br>
 * 帖子：https://cqp.cc/t/37318 <br>
 * 辅助开发变量: {@link JcqAppAbstract#CQ CQ}({@link org.meowy.cqp.jcq.entity.CoolQ
 * 酷Q核心操作类}), {@link JcqAppAbstract#CC
 * CC}({@link org.meowy.cqp.jcq.message.CQCode 酷Q码操作类}), 具体功能可以查看文档
 */

@SuppressWarnings({
		"deprecation",
		"unused"
})

public class JcqDemo_131 extends JcqAppAbstract implements ICQVer, IMsg, IRequest {

	/**
	 * 关于新版：本版本只是为了测试下新做的插件能不能正常运行，并不包含任何 “新” 内容 新：指代 打包，调试运行 新版改了整体架构，内部改动非常大，使用上
	 * 除了包名改动别无区别 关于包名：可以通过批量替换将老程序里的[com.sobte]全部替换成[org.meowy]即可
	 */

	/**
	 * 老的方式依然支持，也就是不强行定构造方法也行
	 */
	public JcqDemo_131() {

	}

	/**
	 * 使用新的方式加载CQ （建议使用这种方式）
	 *
	 * @param CQ CQ初始化
	 */
	public JcqDemo_131(CoolQ CQ) {
		super(CQ);
	}

	/**
	 * 用main方法调试可以最大化的加快开发效率，检测和定位错误位置 以下就是使用Main方法进行测试的一个简易案例
	 *
	 * @param args 系统参数
	 */
	public static void main(String[] args) {

		// 要测试主类就先实例化一个主类对象
		JcqDemo_131 demo = new JcqDemo_131();
		// 获取当前酷Q操作对象
		CoolQ CQ = demo.getCoolQ();
		CQ.logInfo("[JCQ] TEST Demo", "测试启动");
		// 现在就可以用CQ变量来执行任何想要的操作了
		// 下面对主类进行各方法测试,按照JCQ运行过程，模拟实际情况
		demo.startup();// 程序运行开始 调用应用初始化方法
		demo.enable();// 程序初始化完成后，启用应用，让应用正常工作
		// 开始模拟发送消息
		// 模拟私聊消息
		// 开始模拟QQ用户发送消息，以下QQ全部编造，请勿添加
		demo.privateMsg(0, 10001, 2234567819L, "小姐姐约吗", 0);
		demo.privateMsg(0, 10002, 2222222224L, "喵呜喵呜喵呜", 0);
		demo.privateMsg(0, 10003, 2111111334L, "可以给我你的微信吗", 0);
		demo.privateMsg(0, 10004, 3111111114L, "今天天气真好", 0);
		demo.privateMsg(0, 10005, 3333333334L, "你好坏，都不理我QAQ", 0);
		// 模拟群聊消息
		// 开始模拟群聊消息
		demo.groupMsg(0, 10006, 3456789012L, 3333333334L, "", "菜单", 0);
		demo.groupMsg(0, 10008, 3456789012L, 11111111114L, "", "小喵呢，出来玩玩呀", 0);
		demo.groupMsg(0, 10009, 427984429L, 3333333334L, "", "[CQ:at,qq=2222222224] 来一起玩游戏，开车开车", 0);
		demo.groupMsg(0, 10010, 427984429L, 3333333334L, "", "好久不见啦 [CQ:at,qq=11111111114]", 0);
		demo.groupMsg(0, 10011, 427984429L, 11111111114L, "", "qwq 有没有一起开的\n[CQ:at,qq=3333333334]你玩嘛", 0);
		// ......
		// 依次类推，可以根据实际情况修改参数，和方法测试效果
		// 以下是收尾触发函数
		// demo.disable();// 实际过程中程序结束不会触发disable，只有用户关闭了此插件才会触发
		demo.exit();// 最后程序运行结束，调用exit方法
	}

	/**
	 * 打包后将不会调用 请不要在此事件中写其他代码
	 *
	 * @return 返回应用的ApiVer、Appid
	 */
	@Override
	public String appInfo() {
		// 应用AppID,规则见 http://d.cqp.me/Pro/开发/基础信息#appid
		String AppID = "com.example.demo";
		// 记住编译后的文件和json也要使用appid做文件名
		/**
		 * 本函数【禁止】处理其他任何代码，以免发生异常情况。 如需执行初始化代码请在 startup 事件中执行（Type=1001）。
		 */
		return ICQVer.CQAPIVER + "," + AppID;
	}

	/**
	 * 酷Q启动 (Type=1001)<br>
	 * 本方法会在酷Q【主线程】中被调用。<br>
	 * 请在这里执行插件初始化代码。<br>
	 * 请务必尽快返回本子程序，否则会卡住其他插件以及主程序的加载。
	 *
	 * @return 请固定返回0
	 */
	@Override
	public int startup() {
		// 获取应用数据目录(无需储存数据时，请将此行注释)
		this.appDirectory = this.CQ.getAppDirectory();
		// 返回如：D:\CoolQ\data\app\org.meowy.cqp.jcq\data\app\com.example.demo\
		// 应用的所有数据、配置【必须】存放于此目录，避免给用户带来困扰。
		return 0;
	}

	/**
	 * 酷Q退出 (Type=1002)<br>
	 * 本方法会在酷Q【主线程】中被调用。<br>
	 * 无论本应用是否被启用，本函数都会在酷Q退出前执行一次，请在这里执行插件关闭代码。
	 *
	 * @return 请固定返回0，返回后酷Q将很快关闭，请不要再通过线程等方式执行其他代码。
	 */
	@Override
	public int exit() {
		return 0;
	}

	/**
	 * 应用已被启用 (Type=1003)<br>
	 * 当应用被启用后，将收到此事件。<br>
	 * 如果酷Q载入时应用已被启用，则在 {@link #startup startup}(Type=1001,酷Q启动)
	 * 被调用后，本函数也将被调用一次。<br>
	 * 如非必要，不建议在这里加载窗口。
	 *
	 * @return 请固定返回0。
	 */
	@Override
	public int enable() {
		this.enable = true;
		return 0;
	}

	/**
	 * 应用将被停用 (Type=1004)<br>
	 * 当应用被停用前，将收到此事件。<br>
	 * 如果酷Q载入时应用已被停用，则本函数【不会】被调用。<br>
	 * 无论本应用是否被启用，酷Q关闭前本函数都【不会】被调用。
	 *
	 * @return 请固定返回0。
	 */
	@Override
	public int disable() {
		this.enable = false;
		return 0;
	}

	/**
	 * 私聊消息 (Type=21)<br>
	 * 本方法会在酷Q【线程】中被调用。<br>
	 *
	 * @param subType 子类型，11/来自好友 1/来自在线状态 2/来自群 3/来自讨论组
	 * @param msgId   消息ID
	 * @param fromQQ  来源QQ
	 * @param msg     消息内容
	 * @param font    字体
	 * @return 返回值*不能*直接返回文本 如果要回复消息，请调用api发送<br>
	 *         这里 返回 {@link IMsg#MSG_INTERCEPT MSG_INTERCEPT} - 截断本条消息，不再继续处理<br>
	 *         注意：应用优先级设置为"最高"(10000)时，不得使用本返回值<br>
	 *         如果不回复消息，交由之后的应用/过滤器处理，这里 返回 {@link IMsg#MSG_IGNORE MSG_IGNORE} -
	 *         忽略本条消息
	 */
	@Override
	public int privateMsg(int subType, int msgId, long fromQQ, String msg, int font) {
		// 这里处理消息
		this.CQ.sendPrivateMsg(fromQQ, "你发送了这样的消息：" + msg + "\n来自Java插件");
		return IMsg.MSG_IGNORE;
	}

	/**
	 * 群消息 (Type=2)<br>
	 * 本方法会在酷Q【线程】中被调用。<br>
	 *
	 * @param subType       子类型，目前固定为1
	 * @param msgId         消息ID
	 * @param fromGroup     来源群号
	 * @param fromQQ        来源QQ号
	 * @param fromAnonymous 来源匿名者
	 * @param msg           消息内容
	 * @param font          字体
	 * @return 关于返回值说明, 见 {@link #privateMsg 私聊消息} 的方法
	 */
	@Override
	public int groupMsg(int subType, int msgId, long fromGroup, long fromQQ, String fromAnonymous, String msg, int font) {
		// 如果消息来自匿名者
		if ((fromQQ == 80000000L) && !fromAnonymous.equals("")) {
			// 将匿名用户信息放到 anonymous 变量中
			Anonymous anonymous = this.CQ.getAnonymous(fromAnonymous);
		}

		// 解析CQ码案例 如：[CQ:at,qq=100000]
		// 解析CQ码 常用变量为 CC(CQCode) 此变量专为CQ码这种特定格式做了解析和封装
		// CC.analysis();// 此方法将CQ码解析为可直接读取的对象
		// 解析消息中的QQID
		// long qqId = CC.getAt(msg);// 此方法为简便方法，获取第一个CQ:at里的QQ号，错误时为：-1000
		// List<Long> qqIds = CC.getAts(msg); // 此方法为获取消息中所有的CQ码对象，错误时返回 已解析的数据
		// 解析消息中的图片
		// String image = CC.getImage(msg);//
		// 此方法为简便方法，获取第一个CQ:image里的图片数据，错误时打印异常到控制台，返回 null
		// String file = CQ.getImage(image);// 获取酷Q 下载的图片地址

		// 这里处理消息
		if (fromGroup == 0L) { // 这里的 0L 可以换成您的测试群
			this.CQ.sendGroupMsg(fromGroup, this.CC.at(fromQQ) + "你发送了这样的消息：" + msg + "\n来自Java插件");
		}
		return IMsg.MSG_IGNORE;
	}

	/**
	 * 讨论组消息 (Type=4)<br>
	 * 本方法会在酷Q【线程】中被调用。<br>
	 *
	 * @param subtype     子类型，目前固定为1
	 * @param msgId       消息ID
	 * @param fromDiscuss 来源讨论组
	 * @param fromQQ      来源QQ号
	 * @param msg         消息内容
	 * @param font        字体
	 * @return 关于返回值说明, 见 {@link #privateMsg 私聊消息} 的方法
	 */
	@Override
	public int discussMsg(int subtype, int msgId, long fromDiscuss, long fromQQ, String msg, int font) {
		// 这里处理消息

		return IMsg.MSG_IGNORE;
	}

	/**
	 * 群文件上传事件 (Type=11)<br>
	 * 本方法会在酷Q【线程】中被调用。<br>
	 *
	 * @param subType   子类型，目前固定为1
	 * @param sendTime  发送时间(时间戳)// 10位时间戳
	 * @param fromGroup 来源群号
	 * @param fromQQ    来源QQ号
	 * @param file      上传文件信息
	 * @return 关于返回值说明, 见 {@link #privateMsg 私聊消息} 的方法
	 */
	@Override
	public int groupUpload(int subType, int sendTime, long fromGroup, long fromQQ, String file) {
		GroupFile groupFile = this.CQ.getGroupFile(file);
		if (groupFile == null) { // 解析群文件信息，如果失败直接忽略该消息
			return IMsg.MSG_IGNORE;
		}
		// 这里处理消息
		return IMsg.MSG_IGNORE;
	}

	/**
	 * 群事件-管理员变动 (Type=101)<br>
	 * 本方法会在酷Q【线程】中被调用。<br>
	 *
	 * @param subtype        子类型，1/被取消管理员 2/被设置管理员
	 * @param sendTime       发送时间(时间戳)
	 * @param fromGroup      来源群号
	 * @param beingOperateQQ 被操作QQ
	 * @return 关于返回值说明, 见 {@link #privateMsg 私聊消息} 的方法
	 */
	@Override
	public int groupAdmin(int subtype, int sendTime, long fromGroup, long beingOperateQQ) {
		return IMsg.MSG_IGNORE;
	}

	/**
	 * 群事件-群成员减少 (Type=102)<br>
	 * 本方法会在酷Q【线程】中被调用。<br>
	 *
	 * @param subtype        子类型，1/群员离开 2/群员被踢
	 * @param sendTime       发送时间(时间戳)
	 * @param fromGroup      来源群号
	 * @param fromQQ         操作者QQ(仅子类型为2时存在)
	 * @param beingOperateQQ 被操作QQ
	 * @return 关于返回值说明, 见 {@link #privateMsg 私聊消息} 的方法
	 */
	@Override
	public int groupMemberDecrease(int subtype, int sendTime, long fromGroup, long fromQQ, long beingOperateQQ) {
		return IMsg.MSG_IGNORE;
	}

	/**
	 * 群事件-群成员增加 (Type=103)<br>
	 * 本方法会在酷Q【线程】中被调用。<br>
	 *
	 * @param subtype        子类型，1/管理员已同意 2/管理员邀请
	 * @param sendTime       发送时间(时间戳)
	 * @param fromGroup      来源群号
	 * @param fromQQ         操作者QQ(即管理员QQ)
	 * @param beingOperateQQ 被操作QQ(即加群的QQ)
	 * @return 关于返回值说明, 见 {@link #privateMsg 私聊消息} 的方法
	 */
	@Override
	public int groupMemberIncrease(int subtype, int sendTime, long fromGroup, long fromQQ, long beingOperateQQ) {
		// 这里处理消息
		this.CQ.logInfo("fromGroup", "" + fromGroup);
		this.CQ.logInfo("fromQQ", "" + fromQQ);
		this.CQ.logInfo("beingOperateQQ", "" + beingOperateQQ);
		return IMsg.MSG_IGNORE;
	}

	/**
	 * 群事件-群禁言 (Type=104)<br>
	 * 本方法会在酷Q【线程】中被调用。<br>
	 *
	 * @param subType        子类型，1/被解禁 2/被禁言
	 * @param sendTime       发送时间(时间戳)
	 * @param fromGroup      来源群号
	 * @param fromQQ         操作者QQ
	 * @param beingOperateQQ 被操作QQ(若为全群禁言/解禁，则本参数为 0)
	 * @param duration       禁言时长(单位 秒，仅子类型为2时可用)
	 * @return 关于返回值说明, 见 {@link #privateMsg 私聊消息} 的方法
	 */
	@Override
	public int groupBan(int subType, int sendTime, long fromGroup, long fromQQ, long beingOperateQQ, long duration) {
		// 这里处理消息

		return 0;
	}

	/**
	 * 好友事件-好友已添加 (Type=201)<br>
	 * 本方法会在酷Q【线程】中被调用。<br>
	 *
	 * @param subtype  子类型，目前固定为1
	 * @param sendTime 发送时间(时间戳)
	 * @param fromQQ   来源QQ
	 * @return 关于返回值说明, 见 {@link #privateMsg 私聊消息} 的方法
	 */
	@Override
	public int friendAdd(int subtype, int sendTime, long fromQQ) {
		// 这里处理消息

		return IMsg.MSG_IGNORE;
	}

	/**
	 * 请求-好友添加 (Type=301)<br>
	 * 本方法会在酷Q【线程】中被调用。<br>
	 *
	 * @param subtype      子类型，目前固定为1
	 * @param sendTime     发送时间(时间戳)
	 * @param fromQQ       来源QQ
	 * @param msg          附言
	 * @param responseFlag 反馈标识(处理请求用)
	 * @return 关于返回值说明, 见 {@link #privateMsg 私聊消息} 的方法
	 */
	@Override
	public int requestAddFriend(int subtype, int sendTime, long fromQQ, String msg, String responseFlag) {
		// 这里处理消息

		/**
		 * REQUEST_ADOPT 通过 REQUEST_REFUSE 拒绝
		 */

		// CQ.setFriendAddRequest(responseFlag, REQUEST_ADOPT, null); // 同意好友添加请求
		return IMsg.MSG_IGNORE;
	}

	/**
	 * 请求-群添加 (Type=302)<br>
	 * 本方法会在酷Q【线程】中被调用。<br>
	 *
	 * @param subtype      子类型，1/他人申请入群 2/自己(即登录号)受邀入群
	 * @param sendTime     发送时间(时间戳)
	 * @param fromGroup    来源群号
	 * @param fromQQ       来源QQ
	 * @param msg          附言
	 * @param responseFlag 反馈标识(处理请求用)
	 * @return 关于返回值说明, 见 {@link #privateMsg 私聊消息} 的方法
	 */
	@Override
	public int requestAddGroup(int subtype, int sendTime, long fromGroup, long fromQQ, String msg, String responseFlag) {
		// 这里处理消息

		/**
		 * REQUEST_ADOPT 通过 REQUEST_REFUSE 拒绝 REQUEST_GROUP_ADD 群添加 REQUEST_GROUP_INVITE
		 * 群邀请
		 */
		/*
		 * if(subtype == 1){ // 本号为群管理，判断是否为他人申请入群 CQ.setGroupAddRequest(responseFlag,
		 * REQUEST_GROUP_ADD, REQUEST_ADOPT, null);// 同意入群 } if(subtype == 2){
		 * CQ.setGroupAddRequest(responseFlag, REQUEST_GROUP_INVITE, REQUEST_ADOPT,
		 * null);// 同意进受邀群 }
		 */
		return IMsg.MSG_IGNORE;
	}

	/**
	 * 本函数会在JCQ【线程】中被调用。
	 *
	 * @return 固定返回0
	 */
	public int menuA() {
		JOptionPane.showMessageDialog(null, "这是测试菜单A，可以在这里加载窗口");
		return 0;
	}

	/**
	 * 本函数会在酷Q【线程】中被调用。
	 *
	 * @return 固定返回0
	 */
	public int menuB() {
		JOptionPane.showMessageDialog(null, "这是测试菜单B，可以在这里加载窗口");
		return 0;
	}

}
package studio.blacktech.coolqbot.furryblack.common.LoggerX;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.LinkedList;
import java.util.TimeZone;

public class LoggerX {

	private StringBuilder builder_mini;
	private StringBuilder builder_info;
	private StringBuilder builder_seek;
	private StringBuilder builder_full;

	// private static StringBuilder builder_mini = new StringBuilder();
	// private static StringBuilder builder_info = new StringBuilder();
	// private static StringBuilder builder_seek = new StringBuilder();
	// private static StringBuilder builder_full = new StringBuilder();

	public LoggerX() {

		this.builder_mini = new StringBuilder();
		this.builder_info = new StringBuilder();
		this.builder_seek = new StringBuilder();
		this.builder_full = new StringBuilder();

		// this.builder_mini.append(LoggerX.datetime());
		// this.builder_info.append(LoggerX.datetime());
		// this.builder_seek.append(LoggerX.datetime());
		// this.builder_full.append(LoggerX.datetime());

		// this.builder_mini.append("\r\n");
		// this.builder_info.append("\r\n");
		// this.builder_seek.append("\r\n");
		// this.builder_full.append("\r\n");
	}

	public String make(int level) {
		switch (level) {
		case 0:
			return this.builder_mini.toString().substring(0, this.builder_mini.length() - 2);
		case 1:
			return this.builder_info.toString().substring(0, this.builder_info.length() - 2);
		case 2:
			return this.builder_seek.toString().substring(0, this.builder_seek.length() - 2);
		default:
			return this.builder_full.toString().substring(0, this.builder_full.length() - 2);
		}
	}

	// ==================================================================================================
	//
	//
	// ==================================================================================================

	// =====================================
	//
	// [11:22:33] 消息内容
	//
	// =====================================

	public String mini(String message) {
		this.builder_mini.append("[" + LoggerX.time() + "]" + message + "\r\n");
		return this.info(message);
	}

	public String info(String message) {
		this.builder_info.append("[" + LoggerX.time() + "]" + message + "\r\n");
		return this.seek(message);
	}

	public String seek(String message) {
		this.builder_seek.append("[" + LoggerX.time() + "]" + message + "\r\n");
		return this.full(message);
	}

	public String full(String message) {
		this.builder_full.append("[" + LoggerX.time() + "]" + message + "\r\n");
		return message;
	}

	// =====================================
	//
	// [11:22:33] 消息内容：消息内容
	//
	// =====================================

	public String mini(String category, String message) {
		this.builder_mini.append("[" + LoggerX.time() + "][" + category + "]" + message + "\r\n");
		return this.info(category, message);
	}

	public String info(String category, String message) {
		this.builder_info.append("[" + LoggerX.time() + "][" + category + "]" + message + "\r\n");
		return this.seek(category, message);
	}

	public String seek(String category, String message) {
		this.builder_seek.append("[" + LoggerX.time() + "][" + category + "]" + message + "\r\n");
		return this.full(category, message);
	}

	public String full(String category, String message) {
		this.builder_full.append("[" + LoggerX.time() + "][" + category + "]" + message + "\r\n");
		return message;
	}

	// =====================================
	//
	// [11:22:33][CORE] 消息内容：消息内容
	//
	// =====================================

	public String mini(String packname, String key, String value) {
		this.builder_mini.append("[" + LoggerX.time() + "][" + packname + "]" + key + " - " + value + "\r\n");
		return this.info(packname, key, value);
	}

	public String info(String packname, String key, String value) {
		this.builder_info.append("[" + LoggerX.time() + "][" + packname + "]" + key + " - " + value + "\r\n");
		return this.seek(packname, key, value);
	}

	public String seek(String packname, String key, String value) {
		this.builder_seek.append("[" + LoggerX.time() + "][" + packname + "]" + key + " - " + value + "\r\n");
		return this.full(packname, key, value);
	}

	public String full(String packname, String key, String value) {
		this.builder_full.append("[" + LoggerX.time() + "][" + packname + "]" + key + " - " + value + "\r\n");
		return value;
	}

	// ========================================================

	public int mini(String packname, String key, int value) {
		this.builder_mini.append("[" + LoggerX.time() + "][" + packname + "]" + key + " - " + value + "\r\n");
		return this.info(packname, key, value);
	}

	public int info(String packname, String key, int value) {
		this.builder_mini.append("[" + LoggerX.time() + "][" + packname + "]" + key + " - " + value + "\r\n");
		return this.seek(packname, key, value);
	}

	public int seek(String packname, String key, int value) {
		this.builder_seek.append("[" + LoggerX.time() + "][" + packname + "]" + key + " - " + value + "\r\n");
		return this.full(packname, key, value);
	}

	public int full(String packname, String key, int value) {
		this.builder_full.append("[" + LoggerX.time() + "][" + packname + "]" + key + " - " + value + "\r\n");
		return value;
	}

	// ========================================================

	public long mini(String packname, String key, long value) {
		this.builder_mini.append("[" + LoggerX.time() + "][" + packname + "]" + key + " - " + value + "\r\n");
		return this.info(packname, key, value);
	}

	public long info(String packname, String key, long value) {
		this.builder_info.append("[" + LoggerX.time() + "][" + packname + "]" + key + " - " + value + "\r\n");
		return this.seek(packname, key, value);
	}

	public long seek(String packname, String key, long value) {
		this.builder_seek.append("[" + LoggerX.time() + "][" + packname + "]" + key + " - " + value + "\r\n");
		return this.full(packname, key, value);
	}

	public long full(String packname, String key, long value) {
		this.builder_full.append("[" + LoggerX.time() + "][" + packname + "]" + key + " - " + value + "\r\n");
		return value;
	}

	// ==================================================================================================
	//
	//
	// ==================================================================================================

	public static String unicode(String raw) {
		StringBuilder builder = new StringBuilder();
		for (int i = 0; i < raw.length(); i++) {
			builder.append("\\u");
			builder.append(String.format("%1$4s", Integer.toHexString(raw.charAt(i) & 0xffff)).replace(" ", "0"));
		}
		return builder.toString();
	}

	public static String[] unicodeid(String raw) {
		LinkedList<String> tmp = new LinkedList<>();
		for (int i = 0; i < raw.length(); i++) {
			tmp.add(Integer.toHexString(raw.charAt(i) & 0xffff));
		}
		String[] res = new String[tmp.size()];
		tmp.toArray(res);
		return res;
	}

	// ==================================================================================================
	//
	//
	// ==================================================================================================

	private static SimpleDateFormat formater_date = new SimpleDateFormat("yyyy-MM-dd");
	private static SimpleDateFormat formater_time = new SimpleDateFormat("HH:mm:ss");
	private static SimpleDateFormat formater_full = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

	// ================================================================

	public static String date() {
		return LoggerX.formater_date.format(new Date());
	}

	public static String date(Date date) {
		return LoggerX.formater_date.format(date);
	}

	public static String date(long timestamp) {
		return LoggerX.formater_date.format(new Date(timestamp));
	}

	public static String time() {
		return LoggerX.formater_time.format(new Date());
	}

	public static String time(Date date) {
		return LoggerX.formater_time.format(date);
	}

	public static String time(long timestamp) {
		return LoggerX.formater_time.format(new Date(timestamp));
	}

	public static String datetime() {
		return LoggerX.formater_full.format(new Date());
	}

	public static String datetime(Date date) {
		return LoggerX.formater_full.format(date);
	}

	public static String datetime(long timestamp) {
		return LoggerX.formater_full.format(new Date(timestamp));
	}

	// ================================================================

	public static String formatTime(String format) {
		return new SimpleDateFormat(format).format(new Date());
	}

	public static String formatTime(String format, Date date) {
		return new SimpleDateFormat(format).format(date);
	}

	public static String formatTime(String format, long timestamp) {
		return new SimpleDateFormat(format).format(new Date(timestamp));
	}

	public static String formatTime(String format, TimeZone timezone) {
		SimpleDateFormat formater = new SimpleDateFormat(format);
		formater.setTimeZone(timezone);
		return formater.format(new Date());
	}

	public static String formatTime(String format, TimeZone timezone, Date date) {
		SimpleDateFormat formater = new SimpleDateFormat(format);
		formater.setTimeZone(timezone);
		return formater.format(date);
	}

	public static String formatTime(String format, TimeZone timezone, long timestamp) {
		SimpleDateFormat formater = new SimpleDateFormat(format);
		formater.setTimeZone(timezone);
		return formater.format(new Date(timestamp));
	}

	// ================================================================

}
package studio.blacktech.coolqbot.furryblack.common.message;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedList;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;

public class Message implements Serializable {

	private final static String REGEX_IMAGE = "\\[CQ:image,file=\\w{32}\\.\\w{3}\\]";

	private static final long serialVersionUID = 1L;

	private int messageId = 0;
	private int messageFt = 0;

	private long sendTime = 0;

	private String rawMessage = "";
	private String resMessage = "";
	private int rawLength = 0;
	private int resLength = 0;

	private String cmdMessage = "";
	private String command = "";
	private String options = "";
	private String[] segment = {};
	private String[] picture = {};
	private int section = 0;

	private boolean hasPicture = false;
	private boolean isCommand = false;
	private boolean isSnappic = false;
	private boolean isQQVideo = false;
	private boolean isHongbao = false;
	private boolean isPureCQC = false;

	private boolean parsed = false;

	private LinkedList<String> segmentParts;
	private TreeMap<String, String> switchs;

	// ===================================================================================

	public Message(String message, int messageid, int messageFont) {

		this.sendTime = System.currentTimeMillis();

		this.messageId = messageid;
		this.messageFt = messageFont;
		this.rawMessage = message;
	}

	// ===================================================================================

	public Message parse() {

		if (this.parsed) { return this; }

		this.parsed = true;

		this.rawLength = this.rawMessage.length();

		if (this.rawMessage.matches("/[a-z]+.*")) {

			// 居然因为这么一条鬼消息出BUG了 -> /招手[CQ:at,qq=XXXXXXXX]

			this.isCommand = true;

			// 去掉 /
			// 去掉首尾多余空格
			// 合并所有连续空格

			this.cmdMessage = this.rawMessage.substring(1);
			this.cmdMessage = this.cmdMessage.trim();
			this.cmdMessage = this.cmdMessage.replaceAll("\\s+", " ");

			int indexOfSpace = this.cmdMessage.indexOf(' ');

			// 是否无参数命令
			if (indexOfSpace < 0) {
				this.command = this.cmdMessage;
			} else {
				// 切开
				// 命令
				// 参数
				this.command = this.cmdMessage.substring(0, indexOfSpace);
				this.options = this.cmdMessage.substring(indexOfSpace + 1);

				String[] flag;
				this.switchs = new TreeMap<>();
				this.segmentParts = new LinkedList<>();

				// 提取所有 --XX=XXXX 形式的开关
				// 提取所有其他内容为参数
				for (String temp : this.options.split(" ")) {
					if (temp.startsWith("--") && (temp.indexOf("=") > 0)) {
						temp = temp.substring(2);
						flag = temp.split("=");
						this.switchs.put(flag[0], flag[1]);
					} else {
						this.segmentParts.add(temp);
					}
				}

				this.segment = new String[this.segmentParts.size()];
				this.segmentParts.toArray(this.segment);
				this.section = this.segment.length;
			}

		} else if (this.rawMessage.startsWith("&#91;闪照&#93;")) {
			this.isSnappic = true;
		} else if (this.rawMessage.startsWith("&#91;视频&#93;")) {
			this.isQQVideo = true;
		} else if (this.rawMessage.startsWith("&#91;QQ红包&#93;")) {
			this.isHongbao = true;
		} else {
			// 如果是普通消息

			// 提取所有图片
			Pattern pattern = Pattern.compile(Message.REGEX_IMAGE);
			Matcher matcher = pattern.matcher(this.rawMessage);
			ArrayList<String> temp = new ArrayList<>(1);
			if (matcher.find()) {
				this.hasPicture = true;
				do {
					temp.add(matcher.group());
				} while (matcher.find());
				this.picture = new String[temp.size()];
				temp.toArray(this.picture);
			}

			// 删除所有CQ码
			// 删除所有空白字符
			this.resMessage = this.rawMessage.replaceAll("\\[CQ:.+\\]", "").trim();
			this.resMessage = this.resMessage.replaceAll("\\s+", "").trim();

			this.resLength = this.resMessage.length();

			// 删除所有空白字符以后长度为0 则不视为正常消息
			// 比如@时会在最后自动加一个空格
			// [CQ:at=1234567890]□
			// 多次连续at会产生多个空格，不应用 ==" " 判断

			if (this.resLength == 0) { this.isPureCQC = true; }
		}

		return this;
	}

	// ===================================================================================

	/**
	 * 将消息去掉命令以后 从指定位置拼接
	 *
	 * @param i index位置
	 * @return 拼接后的内容
	 */
	public String join(int i) {
		if (this.section == 0) {
			return "";
		} else {
			StringBuilder builder = new StringBuilder();
			for (; i < this.section; i++) {
				builder.append(this.segment[i] + " ");
			}
			return builder.substring(0, builder.length() - 1).toString();
		}
	}

	// ===================================================================================

	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		builder.append("============================================\n");
		builder.append("时间戳：" + LoggerX.datetime(new Date(this.sendTime)) + "(" + this.sendTime + ")" + "\n");
		builder.append("消息ID：" + this.messageId + "\n");
		builder.append("字体ID：" + this.messageFt + "\n");
		builder.append("============================================\n");
		builder.append("原始内容：" + this.rawMessage + "\n");
		builder.append("原始长度：" + this.rawLength + "\n");
		builder.append("原始编码：");
		for (int i = 0; i < this.rawLength; i++) {
			builder.append("\\u");
			builder.append(Integer.toHexString(this.rawMessage.charAt(i) & 0xffff));
		}
		builder.append("\n");
		builder.append("============================================\n");
		builder.append("是否命令：" + (this.isCommand ? "True" : "False") + "\n");
		if (this.isCommand) {
			builder.append("\n");
			builder.append("============================================\n");
			builder.append("命令内容：" + this.cmdMessage + "\n");
			builder.append("命令名字：" + this.command + "\n");
			builder.append("命令参数：" + this.options + "\n");
			builder.append("参数长度：" + this.section + "\n");
			if (this.section > 0) {
				builder.append("============================================\n");
				builder.append("参数内容: \n");
				for (String temp : this.segment) {
					builder.append(temp + "\n");
				}
			}
			if (this.switchs != null) {
				builder.append("============================================\n");
				builder.append("参数开关：\n");
				for (String name : this.switchs.keySet()) {
					builder.append(name + " - " + this.switchs.get(name) + "\n");
				}
			}
		} else {
			builder.append("============================================\n");
			builder.append("是否闪照：" + (this.isSnappic ? "True" : "False") + "\n");
			builder.append("是否视频：" + (this.isQQVideo ? "True" : "False") + "\n");
			builder.append("是否红包：" + (this.isHongbao ? "True" : "False") + "\n");
			builder.append("是否纯码：" + (this.isPureCQC ? "True" : "False") + "\n");
			builder.append("============================================\n");
			builder.append("包含图片：" + (this.hasPicture ? "True" : "False") + "\n");
			if (this.hasPicture) {
				builder.append("图片ID：\n");
				for (String temp : this.picture) {
					builder.append(temp + "\n");
				}
			}
			builder.append("============================================\n");
			builder.append("最终长度: " + this.resLength + "\n");
			if (this.resLength == 0) {
				builder.append("最终内容：" + "无" + "\n");
				builder.append("最终编码：" + "无" + "\n");
			} else {
				builder.append("最终内容：" + this.resMessage + "\n");
				builder.append("最终编码：");
				for (int i = 0; i < this.resLength; i++) {
					builder.append("\\u");
					builder.append(Integer.toHexString(this.resMessage.charAt(i) & 0xffff));
				}
				builder.append("\n");
			}
		}
		builder.append("============================================");

		return builder.toString();
	}
	// ===================================================================================

	/**
	 * 获取消息ID
	 *
	 * @return id
	 */
	public int getMessageId() {
		return this.messageId;
	}

	/**
	 * 获取消息字体
	 *
	 * @return fontid
	 */
	public int getMessageFont() {
		return this.messageFt;
	}

	// ===================================================================================

	/**
	 * 获取消息发送时间 毫秒时间戳
	 *
	 * @return currentTimeMillis
	 */
	public long getSendtime() {
		return this.sendTime;
	}

	/**
	 * 获取消息发送时间 Date对象
	 *
	 * @return Date(currentTimeMillis)
	 */
	public Date getSendDate() {
		return new Date(this.sendTime);
	}

	// ===================================================================================

	/**
	 * 获取原始消息
	 *
	 * @return 原始消息
	 */
	public String getRawMessage() {
		return this.rawMessage;
	}

	/**
	 * 获取原始消息长度
	 *
	 * @return 原始消息长度
	 */
	public int getRawLength() {
		return this.rawLength;
	}

	// ===================================================================================

	/**
	 * 获取命令内容 即去掉/ 如果不是命令则为null 执行器以外的地方不应执行这个函数
	 *
	 * @return 去掉/的内容
	 */
	public String getCmdMessage() {
		return this.cmdMessage;
	}

	/**
	 * 获取命令 即去掉/以空格切分的[0] 如果不是命令则为null 执行器以外的地方不应执行这个函数
	 *
	 * @return 获取命令头
	 */
	public String getCommand() {
		return this.command;
	}

	/**
	 * 获取参数 即去掉/以后按空格切分的[1:] 如果不是命令则为null 执行器以外的地方不应执行这个函数
	 *
	 * @return 获取所有参数
	 */
	public String getOptions() {
		return this.options;
	}

	/**
	 * 获取参数长度 即去掉/以后按空格切分的[1:]的元素数量 如果不是命令则为0 执行器以外的地方不应执行这个函数
	 *
	 * @return 获取参数长度
	 */
	public int getSection() {
		return this.section;
	}

	/**
	 * 获取所有的参数 即去掉/以后按空格切分的[1:]的元素 如果不是命令则为null 执行器以外的地方不应执行这个函数
	 *
	 * @return 参数
	 */
	public String[] getSegment() {
		return this.segment;
	}

	/***
	 * 获取参数 即去掉/以后按空格切分的index+1, 如果不是命令则为null 执行器以外的地方不应执行这个函数
	 *
	 * @param index 索引号
	 * @return 获取指定顺序参数
	 */
	public String getSegment(int index) {
		return this.segment[index];
	}

	/**
	 * 获取开关的值 --name=value 形式的参数为开关 如果不是命令或不存在此参数则为null 执行器以外的地方不应执行这个函数
	 *
	 * @param name 名称
	 * @return 值
	 */
	public String getSwitch(String name) {
		return this.switchs.get(name);
	}

	/**
	 * 是否包含指定名字的开关
	 *
	 * @param name 名称
	 * @return 值
	 */
	public boolean hasSwitch(String name) {
		return this.switchs.containsKey(name);
	}

	// ===================================================================================

	/**
	 * 消息是否为命令
	 *
	 * @return 是否
	 */
	public boolean isCommand() {
		return this.isCommand;
	}

	/**
	 * 消息是否为红包
	 *
	 * @return 是否
	 */
	public boolean isHongbao() {
		return this.isHongbao;
	}

	/**
	 * 消息是否为短视频
	 *
	 * @return 是否
	 */
	public boolean isQQVideo() {
		return this.isQQVideo;
	}

	/**
	 * 消息是否为闪照
	 *
	 * @return 是否
	 */
	public boolean isSnappic() {
		return this.isSnappic;
	}

	/**
	 * 消息是否为纯CQ码
	 *
	 * @return 是否
	 */
	public boolean isPureCQC() {
		return this.isPureCQC;
	}

	/**
	 * 消息是否包含图片
	 *
	 * @return 是否
	 */
	public boolean hasPicture() {
		return this.hasPicture;
	}

	/**
	 * 获取消息中的所有图片
	 *
	 * @return CQImage码
	 */
	public String[] getPicture() {
		return this.picture;
	}

	// ===================================================================================

	/**
	 * 获取分析后的消息
	 *
	 * @return 消息
	 */
	public String getResMessage() {
		return this.resMessage;

	}

	/**
	 * 获取分析后的消息长度
	 *
	 * @return 长度
	 */
	public int getResLength() {
		return this.resLength;
	}

}
package studio.blacktech.coolqbot.furryblack.common.message;

public class MessageDisz extends Message {

	private static final long serialVersionUID = 1L;

	private long diszid = 0;
	private long userid = 0;

	public MessageDisz(long diszid, long userid, String message, int messageid, int messageFont) {
		super(message, messageid, messageFont);
		this.diszid = diszid;
		this.userid = userid;
	}

	public long diszid() {
		return this.diszid;
	}

	public long userid() {
		return this.userid;
	}

	@Override
	public String toString() {

		StringBuilder builder = new StringBuilder();
		builder.append("============================================\n");
		builder.append("组聊ID: " + this.diszid + "\n");
		builder.append("用户ID: " + this.userid + "\n");
		builder.append(super.toString());
		return builder.toString();
	}

	public Message toMessage() {
		return this;
	}
}
package studio.blacktech.coolqbot.furryblack.common.message;

public class MessageGrop extends Message {

	private static final long serialVersionUID = 1L;

	private long gropid = 0;
	private long userid = 0;

	public MessageGrop(long gropid, long userid, String message, int messageid, int messageFont) {
		super(message, messageid, messageFont);
		this.gropid = gropid;
		this.userid = userid;
	}

	public long gropid() {
		return this.gropid;
	}

	public long userid() {
		return this.userid;
	}

	@Override
	public String toString() {

		StringBuilder builder = new StringBuilder();
		builder.append("============================================\n");
		builder.append("群聊ID: " + this.gropid + "\n");
		builder.append("用户ID: " + this.userid + "\n");
		builder.append(super.toString());
		return builder.toString();
	}

	public Message toMessage() {
		return this;
	}
}
package studio.blacktech.coolqbot.furryblack.common.message;

public class MessageUser extends Message {

	private static final long serialVersionUID = 1L;

	private long typeid = 0;
	private long userid = 0;

	public MessageUser(int typeid, long userid, String message, int messageid, int messageFont) {
		super(message, messageid, messageFont);
		this.typeid = typeid;
		this.userid = userid;
	}

	public long typeid() {
		return this.typeid;
	}

	public long userid() {
		return this.userid;
	}

	@Override
	public String toString() {

		StringBuilder builder = new StringBuilder();
		builder.append("============================================\n");
		builder.append("类型ID: " + this.typeid + "\n");
		builder.append("用户ID: " + this.userid + "\n");
		builder.append(super.toString());
		return builder.toString();
	}

	public Message toMessage() {
		return this;
	}
}package studio.blacktech.coolqbot.furryblack.common.module;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.Serializable;
import java.nio.file.Paths;
import java.util.Properties;

import studio.blacktech.coolqbot.furryblack.entry;
import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.exception.NotAFolderException;
import studio.blacktech.coolqbot.furryblack.common.message.Message;

public abstract class Module implements Serializable {

	private static final long serialVersionUID = 1L;

	private String MODULE_PACKAGENAME;
	private String MODULE_COMMANDNAME;
	private String MODULE_DISPLAYNAME;
	private String MODULE_DESCRIPTION;
	private String MODULE_VERSION;
	private String[] MODULE_USAGE;
	private String[] MODULE_PRIVACY_STORED;
	private String[] MODULE_PRIVACY_CACHED;
	private String[] MODULE_PRIVACY_OBTAIN;

	public String MODULE_FULLHELP;

	protected Properties CONFIG = new Properties();

	protected File FOLDER_ROOT;

	protected File FOLDER_CONF;
	protected File FOLDER_DATA;
	protected File FOLDER_LOGS;

	protected File FILE_CONFIG;

	protected boolean NEW_CONFIG = false;

	// @formatter:off

	public Module(
			String MODULE_PACKAGENAME,
			String MODULE_COMMANDNAME,
			String MODULE_DISPLAYNAME,
			String MODULE_DESCRIPTION,
			String MODULE_VERSION,
			String[] MODULE_USAGE,
			String[] MODULE_PRIVACY_STORED,
			String[] MODULE_PRIVACY_CACHED,
			String[] MODULE_PRIVACY_OBTAIN
			) throws Exception {

		this.MODULE_PACKAGENAME = MODULE_PACKAGENAME;
		this.MODULE_COMMANDNAME = MODULE_COMMANDNAME;
		this.MODULE_DISPLAYNAME = MODULE_DISPLAYNAME;
		this.MODULE_DESCRIPTION = MODULE_DESCRIPTION;
		this.MODULE_VERSION = MODULE_VERSION;
		this.MODULE_USAGE = MODULE_USAGE;
		this.MODULE_PRIVACY_STORED = MODULE_PRIVACY_STORED;
		this.MODULE_PRIVACY_CACHED = MODULE_PRIVACY_CACHED;
		this.MODULE_PRIVACY_OBTAIN = MODULE_PRIVACY_OBTAIN;

		this.MODULE_FULLHELP = this.genFullHelp();

		this.FOLDER_ROOT = Paths.get(entry.getAppDirectory(), this.MODULE_PACKAGENAME).toFile();
		this.FOLDER_CONF =  Paths.get(entry.getAppDirectory(), this.MODULE_PACKAGENAME , "conf").toFile();
		this.FOLDER_DATA =  Paths.get(entry.getAppDirectory(), this.MODULE_PACKAGENAME , "data").toFile();
		this.FOLDER_LOGS =  Paths.get(entry.getAppDirectory(), this.MODULE_PACKAGENAME , "logs").toFile();
		this.FILE_CONFIG =  Paths.get(entry.getAppDirectory(), this.MODULE_PACKAGENAME , "config.properties").toFile();

	}

	// @formatter:on

	public LoggerX initAppFolder(LoggerX logger) throws Exception {

		if (this.FOLDER_ROOT.exists()) {
			if (!this.FOLDER_ROOT.isDirectory()) { throw new NotAFolderException("文件夹被文件占位：" + this.FOLDER_ROOT.getAbsolutePath()); }
		} else {
			logger.seek(this.MODULE_PACKAGENAME, "创建目录", this.FOLDER_ROOT.getAbsolutePath());
			this.FOLDER_ROOT.mkdirs();
		}

		return logger;
	}

	public LoggerX initConfFolder(LoggerX logger) throws Exception {

		if (this.FOLDER_CONF.exists()) {
			if (!this.FOLDER_CONF.isDirectory()) { throw new NotAFolderException("文件夹被文件占位：" + this.FOLDER_CONF.getAbsolutePath()); }
		} else {
			logger.seek(this.MODULE_PACKAGENAME, "创建目录", this.FOLDER_CONF.getAbsolutePath());
			this.FOLDER_CONF.mkdirs();
		}

		return logger;
	}

	public LoggerX initDataFolder(LoggerX logger) throws Exception {

		if (this.FOLDER_DATA.exists()) {
			if (!this.FOLDER_DATA.isDirectory()) { throw new NotAFolderException("文件夹被文件占位：" + this.FOLDER_DATA.getAbsolutePath()); }
		} else {
			logger.seek(this.MODULE_PACKAGENAME, "创建目录", this.FOLDER_DATA.getAbsolutePath());
			this.FOLDER_DATA.mkdirs();
		}

		return logger;
	}

	public LoggerX initLogsFolder(LoggerX logger) throws Exception {

		if (this.FOLDER_LOGS.exists()) {
			if (!this.FOLDER_LOGS.isDirectory()) { throw new NotAFolderException("文件夹被文件占位：" + this.FOLDER_LOGS.getAbsolutePath()); }
		} else {
			logger.seek(this.MODULE_PACKAGENAME, "创建目录", this.FOLDER_LOGS.getName());
			this.FOLDER_LOGS.mkdirs();
		}

		return logger;
	}

	public LoggerX initPropertiesConfigurtion(LoggerX logger) throws Exception {

		if (!this.FILE_CONFIG.exists()) {
			logger.seek(this.MODULE_PACKAGENAME, "创建文件", this.FILE_CONFIG.getAbsolutePath());
			this.FILE_CONFIG.createNewFile();
			this.NEW_CONFIG = true;
		}

		return logger;
	}

	public abstract LoggerX init(LoggerX logger) throws Exception;

	public abstract LoggerX boot(LoggerX logger) throws Exception;

	public abstract LoggerX save(LoggerX logger) throws Exception;

	public abstract LoggerX shut(LoggerX logger) throws Exception;

	public abstract LoggerX exec(LoggerX logger, Message message) throws Exception;

	public abstract void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) throws Exception;

	public abstract void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) throws Exception;

	public abstract String[] generateReport(int mode, Message message, Object... parameters);

	protected void loadConfig() throws Exception {
		this.CONFIG.load(new FileInputStream(this.FILE_CONFIG));
	}

	protected void saveConfig() throws Exception {
		this.CONFIG.store(new FileOutputStream(this.FILE_CONFIG), null);
	}

	public String MODULE_PACKAGENAME() {
		return this.MODULE_PACKAGENAME;
	}

	public String MODULE_COMMANDNAME() {
		return this.MODULE_COMMANDNAME;
	}

	public String MODULE_DISPLAYNAME() {
		return this.MODULE_DISPLAYNAME;
	}

	public String MODULE_DESCRIPTION() {
		return this.MODULE_DESCRIPTION;
	}

	public String MODULE_FULLHELP() {
		return this.MODULE_FULLHELP;
	}

	public String genFullHelp() {
		StringBuilder builder = new StringBuilder();
		builder.append("模块：" + this.MODULE_PACKAGENAME + "v" + this.MODULE_VERSION + "\r\n");
		builder.append("名称：" + this.MODULE_DISPLAYNAME + "\r\n");
		builder.append("用途：" + this.MODULE_DESCRIPTION + "\r\n");
		builder.append("命令：" + this.MODULE_COMMANDNAME + "\r\n");
		builder.append("用法：");
		if (this.MODULE_USAGE.length == 0) {
			builder.append("无");
		} else {
			for (String temp : this.MODULE_USAGE) {
				builder.append(temp + "\r\n");
			}
		}

		builder.append("隐私声明：" + "\r\n");

		builder.append("存储：" + "\r\n");
		if (this.MODULE_PRIVACY_STORED.length == 0) {
			builder.append("无" + "\r\n");
		} else {
			builder.append(this.MODULE_PRIVACY_STORED.length);
			for (String temp : this.MODULE_PRIVACY_STORED) {
				builder.append(" " + temp + "\r\n");
			}
		}
		builder.append("缓存：" + "\r\n");
		if (this.MODULE_PRIVACY_CACHED.length == 0) {
			builder.append("无" + "\r\n");
		} else {
			builder.append(this.MODULE_PRIVACY_CACHED.length);
			for (String temp : this.MODULE_PRIVACY_CACHED) {
				builder.append(" " + temp + "\r\n");
			}
		}
		builder.append("获取：" + "\r\n");
		if (this.MODULE_PRIVACY_OBTAIN.length == 0) {
			builder.append("无" + "\r\n");
		} else {
			builder.append(this.MODULE_PRIVACY_OBTAIN.length);
			for (String temp : this.MODULE_PRIVACY_OBTAIN) {
				builder.append(" " + temp + "\r\n");
			}
		}
		return builder.toString();
	}

}
package studio.blacktech.coolqbot.furryblack.common.module;

import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;

public abstract class ModuleExecutor extends Module {

	private static final long serialVersionUID = 1L;

	// @formatter:off
	public ModuleExecutor(
			String MODULE_PACKAGENAME,
			String MODULE_COMMANDNAME,
			String MODULE_DISPLAYNAME,
			String MODULE_DESCRIPTION,
			String MODULE_VERSION,
			String[] MODULE_USAGE,
			String[] MODULE_PRIVACY_STORED,
			String[] MODULE_PRIVACY_CACHED,
			String[] MODULE_PRIVACY_OBTAIN
			) throws Exception {
		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);
	}
	// @formatter:on

	protected int COUNT_USER = 0;
	protected int COUNT_DISZ = 0;
	protected int COUNT_GROP = 0;

	protected boolean ENABLE_USER = false;
	protected boolean ENABLE_DISZ = false;
	protected boolean ENABLE_GROP = false;

	public int COUNT_USER() {
		return this.COUNT_USER;
	}

	public int COUNT_DISZ() {
		return this.COUNT_DISZ;
	}

	public int COUNT_GROP() {
		return this.COUNT_GROP;
	}

	public boolean ENABLE_USER() {
		return this.ENABLE_USER;
	}

	public boolean ENABLE_DISZ() {
		return this.ENABLE_DISZ;
	}

	public boolean ENABLE_GROP() {
		return this.ENABLE_GROP;
	}

	@Override
	public abstract LoggerX init(LoggerX logger) throws Exception;

	@Override
	public abstract LoggerX boot(LoggerX logger) throws Exception;

	@Override
	public abstract LoggerX shut(LoggerX logger) throws Exception;

	public abstract boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception;

	public abstract boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception;

	public abstract boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception;

	public boolean executeUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {
		this.COUNT_USER++;
		return this.doUserMessage(typeid, userid, message, messageid, messagefont);
	}

	public boolean executeDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {
		this.COUNT_DISZ++;
		return this.doDiszMessage(diszid, userid, message, messageid, messagefont);
	}

	public boolean executeGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {
		this.COUNT_GROP++;
		return this.doGropMessage(gropid, userid, message, messageid, messagefont);
	}

}
package studio.blacktech.coolqbot.furryblack.common.module;

import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;

public abstract class ModuleListener extends Module {

	private static final long serialVersionUID = 1L;

	// @formatter:off
	public ModuleListener(
			String MODULE_PACKAGENAME,
			String MODULE_COMMANDNAME,
			String MODULE_DISPLAYNAME,
			String MODULE_DESCRIPTION,
			String MODULE_VERSION,
			String[] MODULE_USAGE,
			String[] MODULE_PRIVACY_STORED,
			String[] MODULE_PRIVACY_CACHED,
			String[] MODULE_PRIVACY_OBTAIN
			) throws Exception {
		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);
	}
	// @formatter:on

	protected int COUNT_USER = 0;
	protected int COUNT_DISZ = 0;
	protected int COUNT_GROP = 0;

	protected boolean ENABLE_USER = false;
	protected boolean ENABLE_DISZ = false;
	protected boolean ENABLE_GROP = false;

	public int COUNT_USER() {
		return this.COUNT_USER;
	}

	public int COUNT_DISZ() {
		return this.COUNT_DISZ;
	}

	public int COUNT_GROP() {
		return this.COUNT_GROP;
	}

	public boolean ENABLE_USER() {
		return this.ENABLE_USER;
	}

	public boolean ENABLE_DISZ() {
		return this.ENABLE_DISZ;
	}

	public boolean ENABLE_GROP() {
		return this.ENABLE_GROP;
	}

	public abstract boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception;

	public abstract boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception;

	public abstract boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception;

	public boolean executeUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {
		this.COUNT_USER++;
		return this.doUserMessage(typeid, userid, message, messageid, messagefont);
	}

	public boolean executeDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {
		this.COUNT_DISZ++;
		return this.doDiszMessage(diszid, userid, message, messageid, messagefont);
	}

	public boolean executeGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {
		this.COUNT_GROP++;
		return this.doGropMessage(gropid, userid, message, messageid, messagefont);
	}
}
package studio.blacktech.coolqbot.furryblack.common.module;

public abstract class ModuleScheduler extends Module {

	private static final long serialVersionUID = 1L;

	// @formatter:off
	public ModuleScheduler(
			String MODULE_PACKAGENAME,
			String MODULE_COMMANDNAME,
			String MODULE_DISPLAYNAME,
			String MODULE_DESCRIPTION,
			String MODULE_VERSION,
			String[] MODULE_USAGE,
			String[] MODULE_PRIVACY_STORED,
			String[] MODULE_PRIVACY_CACHED,
			String[] MODULE_PRIVACY_OBTAIN
			) throws Exception {
		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);
	}
	// @formatter:on

	protected int COUNT = 0;

	protected boolean ENABLE = false;

	public boolean ENABLE() {
		return this.ENABLE;
	}

	public int COUNT() {
		return this.COUNT;
	}

}
package studio.blacktech.coolqbot.furryblack.common.module;

import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;

public abstract class ModuleTrigger extends Module {

	private static final long serialVersionUID = 1L;

	// @formatter:off
	public ModuleTrigger(
			String MODULE_PACKAGENAME,
			String MODULE_COMMANDNAME,
			String MODULE_DISPLAYNAME,
			String MODULE_DESCRIPTION,
			String MODULE_VERSION,
			String[] MODULE_USAGE,

			String[] MODULE_PRIVACY_STORED,
			String[] MODULE_PRIVACY_CACHED,
			String[] MODULE_PRIVACY_OBTAIN
			) throws Exception {
		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);
	}
	// @formatter:on

	protected int COUNT_USER = 0;
	protected int COUNT_DISZ = 0;
	protected int COUNT_GROP = 0;

	protected int BLOCK_USER = 0;
	protected int BLOCK_DISZ = 0;
	protected int BLOCK_GROP = 0;

	protected boolean ENABLE_USER = false;
	protected boolean ENABLE_DISZ = false;
	protected boolean ENABLE_GROP = false;

	public int COUNT_USER() {
		return this.COUNT_USER;
	}

	public int COUNT_DISZ() {
		return this.COUNT_DISZ;
	}

	public int COUNT_GROP() {
		return this.COUNT_GROP;
	}

	public int BLOCK_USER() {
		return this.BLOCK_USER;
	}

	public int BLOCK_DISZ() {
		return this.BLOCK_DISZ;
	}

	public int BLOCK_GROP() {
		return this.BLOCK_GROP;
	}

	public boolean ENABLE_USER() {
		return this.ENABLE_USER;
	}

	public boolean ENABLE_DISZ() {
		return this.ENABLE_DISZ;
	}

	public boolean ENABLE_GROP() {
		return this.ENABLE_GROP;
	}

	public abstract boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception;

	public abstract boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception;

	public abstract boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception;

	public boolean executeUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {
		this.COUNT_USER++;
		return this.doUserMessage(typeid, userid, message, messageid, messagefont);
	}

	public boolean executeDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {
		this.COUNT_DISZ++;
		return this.doDiszMessage(diszid, userid, message, messageid, messagefont);
	}

	public boolean executeGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {
		this.COUNT_GROP++;
		return this.doGropMessage(gropid, userid, message, messageid, messagefont);
	}

}
package studio.blacktech.coolqbot.furryblack.common.Security.Cipher;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.Provider;
import java.security.SecureRandom;
import java.security.Security;
import java.util.Arrays;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

/***
 * 使用标准JavaCipher包装的AES-128 CBC分组模式工具类，
 *
 * 包含三种加密模式：标准加密、使用HA-384进行消息验证、使用签名后不初始化的SHA-384进行消息验证。
 *
 * 带消息验证的数据帧为：
 *
 * 00 00 00 00 , 00 00 00 00 - 00 00 00 00 , 00 00 00 00 - XXXX
 *
 * 前8位 原始消息getBytes(UTF-8)后数组的长度 int → hexString → getBytes(UTF-8)
 *
 * 后8位 SHA-384的前8位
 *
 * 之后为原始数据getBytes(UTF-8)
 *
 * 数据帧经过AES加密和Base64编码，成为密文。
 *
 * @author Alceatraz Warprays
 *
 */
public class AESCipher {

	private SecretKeySpec sk;
	private IvParameterSpec iv;
	private Cipher encrypter;
	private Cipher decrypter;
	private BASE64Encoder encoder;
	private BASE64Decoder decoder;
	private MessageDigest staticDigester;
	private MessageDigest oneoffDigester;

	// ==========================================================================================================================================================
	//
	//
	//
	// ==========================================================================================================================================================

	/**
	 * 构造方法
	 *
	 * @param secretKey 随机种子，作为密钥生成器的随机数生成器的种子
	 */
	@Deprecated
	public AESCipher(String secretKey) {
		this(generateSecretKeySpec(secretKey), generateIvParameterSpec("0123456789ABCDEF"));
		System.err.println("Warning! Using fix IV is RISK! Only test purpose!");
	}

	/**
	 * 构造方法
	 *
	 * @param secretKeySpec 密钥
	 */
	@Deprecated
	public AESCipher(SecretKeySpec secretKeySpec) {
		this(secretKeySpec, generateIvParameterSpec("0123456789ABCDEF"));
		System.err.println("Warning! Using fix IV is RISK! Only test purpose!");
	}

	/**
	 * 构造方法
	 *
	 * @param secretKey     随机种子，作为密钥生成器的随机数生成器的种子
	 * @param initialVector 初始向量种子，MD5后用于生成初始向量
	 */
	public AESCipher(String secretKey, String initialVector) {
		this(generateSecretKeySpec(secretKey), generateIvParameterSpec(initialVector));
	}

	/**
	 * 构造方法
	 *
	 * @param secretKeySpec 密钥
	 * @param initialVector 初始向量种子，MD5后用于生成初始向量
	 */
	public AESCipher(SecretKeySpec secretKeySpec, String initialVector) {
		this(secretKeySpec, generateIvParameterSpec(initialVector));
	}

	/**
	 * 构造方法
	 *
	 * @param secretKey     随机种子，作为密钥生成器的随机数生成器的种子
	 * @param initialVector 初始向量
	 */
	public AESCipher(String secretKey, IvParameterSpec initialVector) {
		this(generateSecretKeySpec(secretKey), initialVector);
	}

	/**
	 * 构造方法
	 *
	 * @param secretKeySpec 密钥
	 * @param initialVector 初始向量
	 */
	public AESCipher(SecretKeySpec secretKeySpec, IvParameterSpec initialVector) {

		try {

			this.sk = secretKeySpec;
			this.iv = initialVector;

			this.encrypter = Cipher.getInstance("AES/CBC/PKCS5Padding");
			this.decrypter = Cipher.getInstance("AES/CBC/PKCS5Padding");

			this.encrypter.init(Cipher.ENCRYPT_MODE, this.sk, this.iv);
			this.decrypter.init(Cipher.DECRYPT_MODE, this.sk, this.iv);

			this.encoder = new BASE64Encoder();
			this.decoder = new BASE64Decoder();

			this.staticDigester = MessageDigest.getInstance("SHA-384");
			this.oneoffDigester = MessageDigest.getInstance("SHA-384");

		} catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | InvalidAlgorithmParameterException exception) {
			exception.printStackTrace();
			// 这些异常不可能发生 - 使用ADoptOpenJDK 8
			// NoSuchAlgorithmException ----------- 不允许用户自定义算法
			// NoSuchPaddingException ------------- 不允许用户自定义算法
			// InvalidKeyException ---------------- 密钥由生成器生成
			// InvalidAlgorithmParameterException - 不允许用户自定义算法
		}
	}

	/**
	 * 生成密钥
	 *
	 * @param secretKey 密钥种子，作为密钥生成器的随机数生成器的种子
	 * @return 密钥
	 */
	private static SecretKeySpec generateSecretKeySpec(String secretKey) {
		try {
			Provider provider = Security.getProvider("SUN");
			SecureRandom random = SecureRandom.getInstance("SHA1PRNG", provider);
			random.setSeed(secretKey.getBytes(StandardCharsets.UTF_8));
			KeyGenerator generator = KeyGenerator.getInstance("AES");
			generator.init(128, random);
			SecretKey skey = generator.generateKey();
			return new SecretKeySpec(skey.getEncoded(), "AES");
		} catch (NoSuchAlgorithmException exception) {
			return null;
		}
	}

	/**
	 * 生成初始向量
	 *
	 * @param initialVector 初始向量种子，MD5后用于生成初始向量
	 * @return 初始向量
	 */
	private static IvParameterSpec generateIvParameterSpec(String initialVector) {
		try {
			MessageDigest digest = MessageDigest.getInstance("MD5");
			digest.update(initialVector.getBytes(StandardCharsets.UTF_8));
			return new IvParameterSpec(digest.digest());
		} catch (NoSuchAlgorithmException exception) {
			return null;
		}
	}

	// ==========================================================================================================================================================
	//
	//
	//
	// ==========================================================================================================================================================

	/**
	 * 加密模式1
	 *
	 * @param content 原文
	 * @return 密文
	 */
	public String encrypt(String content) {

		try {

			byte[] tmp1 = content.getBytes(StandardCharsets.UTF_8);
			byte[] tmp2 = this.encrypter.doFinal(tmp1);
			return this.encoder.encode(tmp2);

		} catch (IllegalBlockSizeException | BadPaddingException exception) {
			exception.printStackTrace();
			return null;
			// 这些异常不可能发生
			// BadPaddingException ------- 不允许用户自定义算法
			// IllegalBlockSizeException - 不允许用户传入byte[]
		}
	}

	/**
	 * 解密模式1
	 *
	 * @param content 密文
	 * @return 原文
	 * @throws IOException 输入错误的内容
	 */
	public String decrypt(String content) throws IOException {

		try {

			byte[] tmp1 = this.decoder.decodeBuffer(content);
			byte[] tmp2 = this.decrypter.doFinal(tmp1);
			return new String(tmp2, StandardCharsets.UTF_8);

		} catch (IOException exception) {
			exception.printStackTrace();
			throw exception;

		} catch (IllegalBlockSizeException | BadPaddingException exception) {
			exception.printStackTrace();
			return null;
			// 这些异常不可能发生
			// BadPaddingException ------- 不允许用户自定义算法
			// IllegalBlockSizeException - 不允许用户传入byte[]
		}
	}

	/**
	 * 加密模式2
	 *
	 * @param content 原文
	 * @return 密文
	 */
	public String encryptHash(String content) {

		try {

			byte[] rawMessage = content.getBytes(StandardCharsets.UTF_8);

			byte[] sizePart = new byte[8];
			byte[] hashPart = new byte[8];

			int rawMessageLength = rawMessage.length;
			byte[] result = new byte[16 + rawMessageLength];

			sizePart = Integer.toHexString(rawMessageLength).getBytes(StandardCharsets.UTF_8);
			int sizePartLength = sizePart.length;
			System.arraycopy(sizePart, 0, result, 8 - sizePartLength, sizePartLength);

			this.oneoffDigester.update(rawMessage);
			hashPart = this.oneoffDigester.digest();
			System.arraycopy(hashPart, 0, result, 8, 8);

			System.arraycopy(rawMessage, 0, result, 16, rawMessageLength);

			return this.encoder.encode(this.encrypter.doFinal(result));

		} catch (IllegalBlockSizeException | BadPaddingException exception) {
			return null;
			// 这些异常不可能发生
			// BadPaddingException ------- 不允许用户自定义算法
			// IllegalBlockSizeException - 不允许用户传入byte[]
		}
	}

	/**
	 * 解密模式2
	 *
	 * @param content 密文
	 * @return 原文
	 * @throws IOException                     输入了错误的内容
	 * @throws MessageSizeCheckFailedException 消息长度验证不通过
	 * @throws MessageHashCheckFailedException 消息哈希验证不通过
	 */
	public String decryptHash(String content) throws IOException, MessageSizeCheckFailedException, MessageHashCheckFailedException {

		try {

			byte[] rawMessage = this.decrypter.doFinal(this.decoder.decodeBuffer(content));

			byte[] sizePart = new byte[8];
			byte[] hashPart = new byte[8];

			int actualMessageLength = rawMessage.length - 16;

			System.arraycopy(rawMessage, 0, sizePart, 0, 8);
			int claminMessagelength = Integer.valueOf(new String(sizePart).trim(), 16);
			if (claminMessagelength != actualMessageLength) { throw new MessageSizeCheckFailedException(claminMessagelength, actualMessageLength); }

			System.arraycopy(rawMessage, 8, hashPart, 0, 8);

			byte[] mesgPart = new byte[claminMessagelength];
			System.arraycopy(rawMessage, 16, mesgPart, 0, claminMessagelength);
			this.oneoffDigester.update(mesgPart);
			byte[] digest = this.oneoffDigester.digest();

			if (!isSame(hashPart, digest)) { throw new MessageHashCheckFailedException(hashPart, digest); }

			return new String(mesgPart, StandardCharsets.UTF_8);

		} catch (IllegalBlockSizeException | BadPaddingException exception) {
			return null;
			// 这些异常不可能发生
			// BadPaddingException ------- 不允许用户自定义算法
			// IllegalBlockSizeException - 不允许用户传入byte[]
		}
	}

	public String encraptPhaseHash(String content) {

		try {

			byte[] rawMessage = content.getBytes(StandardCharsets.UTF_8);

			byte[] sizePart = new byte[8];
			byte[] hashPart = new byte[8];

			int rawMessageLength = rawMessage.length;
			byte[] result = new byte[16 + rawMessageLength];

			sizePart = Integer.toHexString(rawMessageLength).getBytes(StandardCharsets.UTF_8);
			int sizePartLength = sizePart.length;
			System.arraycopy(sizePart, 0, result, 8 - sizePartLength, sizePartLength);

			this.staticDigester.update(rawMessage);
			hashPart = ((MessageDigest) this.staticDigester.clone()).digest();
			System.arraycopy(hashPart, 0, result, 8, 8);

			System.arraycopy(rawMessage, 0, result, 16, rawMessageLength);

			return this.encoder.encode(this.encrypter.doFinal(result));

		} catch (IllegalBlockSizeException | BadPaddingException | CloneNotSupportedException exception) {
			return null;
			// 这些异常不可能发生
			// BadPaddingException -------- 不允许用户自定义算法
			// IllegalBlockSizeException -- 不允许用户传入byte[]
			// CloneNotSupportedException - MessageDigest是能够克隆的
		}
	}

	public String decryptPhaseHash(String content) throws IOException, MessageSizeCheckFailedException, MessageHashCheckFailedException {
		try {

			byte[] rawMessage = this.decrypter.doFinal(this.decoder.decodeBuffer(content));

			byte[] sizePart = new byte[8];
			byte[] hashPart = new byte[8];

			int actualMessageLength = rawMessage.length - 16;

			System.arraycopy(rawMessage, 0, sizePart, 0, 8);
			int claminMessagelength = Integer.valueOf(new String(sizePart).trim(), 16);
			if (claminMessagelength != actualMessageLength) { throw new MessageSizeCheckFailedException(claminMessagelength, actualMessageLength); }

			System.arraycopy(rawMessage, 8, hashPart, 0, 8);

			byte[] mesgPart = new byte[claminMessagelength];
			System.arraycopy(rawMessage, 16, mesgPart, 0, claminMessagelength);

			this.staticDigester.update(mesgPart);
			byte[] digest = ((MessageDigest) this.staticDigester.clone()).digest();

			if (!isSame(hashPart, digest)) { throw new MessageHashCheckFailedException(hashPart, digest); }

			return new String(mesgPart, StandardCharsets.UTF_8);

		} catch (IOException exception) {
			exception.printStackTrace();
			throw exception;

		} catch (IllegalBlockSizeException | BadPaddingException | CloneNotSupportedException exception) {
			return null;
			// 这些异常不可能发生
			// BadPaddingException ------- 不允许用户自定义算法
			// NoSuchAlgorithmException -- 不允许用户自定义算法
			// IllegalBlockSizeException - 不允许用户传入byte[]
		}
	}

	private static boolean isSame(byte[] A, byte[] B) {
		// 只发送前8位，所以只比较前8位，java没有数组截取 "python[0:7]" 所以只能写的这么蠢
		// @formatter:off
		return	(A[0] == B[0]) && (A[1] == B[1]) && (A[2] == B[2]) && (A[3] == B[3]) &&
				(A[4] == B[4]) && (A[5] == B[5]) && (A[6] == B[6]) && (A[7] == B[7]) ;
		// @formatter:on
	}

	// ==========================================================================================================================================================
	//
	//
	//
	// ==========================================================================================================================================================

	public static class MessageSizeCheckFailedException extends GeneralSecurityException {
		private static final long serialVersionUID = 0;

		public MessageSizeCheckFailedException(int claimSize, int actualSize) {
			super("Message claim length is " + claimSize + ", But actual length is " + actualSize);
		}
	}

	public static class MessageHashCheckFailedException extends GeneralSecurityException {
		private static final long serialVersionUID = 0;

		public MessageHashCheckFailedException(byte[] claimHash, byte[] actualHash) {
			super("Message claim digest is " + Arrays.toString(claimHash) + ", But actual digest is " + Arrays.toString(Arrays.copyOfRange(actualHash, 0, 8)));
		}
	}

}
package studio.blacktech.coolqbot.furryblack.common.Security.Cipher;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.Provider;
import java.security.SecureRandom;
import java.security.Security;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Arrays;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;

import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

/**
 * 使用标准JavaCipher包装的RSA工具类，
 *
 * 包含三种加密模式：标准加密、使用HA-384进行消息验证、使用签名后不初始化的SHA-384进行消息验证。
 *
 * 带消息验证的数据帧为：
 *
 * 00 00 00 00 , 00 00 00 00 - 00 00 00 00 , 00 00 00 00 - XXXX
 *
 * 前8位 原始消息getBytes(UTF-8)后数组的长度 int → hexString → getBytes(UTF-8)
 *
 * 后8位 SHA-384的前8位
 *
 * 之后为原始数据getBytes(UTF-8)
 *
 * 数据帧经过RSA加密和Base64编码，成为密文。
 *
 * @author Alceatraz Warprays
 *
 */
public class RSACipher {

	private Cipher encrypter;
	private Cipher decrypter;
	private BASE64Encoder encoder;
	private BASE64Decoder decoder;
	private RSAPublicKey publicKey;
	private RSAPrivateKey privateKey;
	private MessageDigest staticDigester;
	private MessageDigest oneoffDigester;

	// ==========================================================================================================================================================
	//
	//
	//
	// ==========================================================================================================================================================

	/**
	 * 构造方法
	 *
	 * @param secretKey 随机种子，作为密钥生成器的随机数生成器的种子
	 * @param keyLength 密钥长度，至少为512
	 * @throws InvalidKeyException 错误的密钥
	 */
	public RSACipher(String secretKey, int keyLength) throws InvalidKeyException {
		this(generateKeyPair(secretKey, keyLength));
	}

	/**
	 * 构造方法
	 *
	 * @param keyPair 密钥对
	 */
	public RSACipher(KeyPair keyPair) {
		this((RSAPublicKey) keyPair.getPublic(), (RSAPrivateKey) keyPair.getPrivate());
	}

	/**
	 * 构造方法
	 *
	 * @param publicKey Base64编码的X509格式公钥
	 * @throws InvalidPublicKeyException 公钥格式错误
	 */
	public RSACipher(String publicKey) throws InvalidPublicKeyException {
		this(getRSAPublicKeyFromString(publicKey));
	}

	/**
	 * 构造方法
	 *
	 * @param publicKey  Base64编码的X509格式公钥
	 * @param privateKey Base64编码的PKCS8格式私钥
	 * @throws InvalidPublicKeyException  公钥格式错误
	 * @throws InvalidPrivateKeyException 私钥格式错误
	 */
	public RSACipher(String publicKey, String privateKey) throws InvalidPublicKeyException, InvalidPrivateKeyException {
		this(getRSAPublicKeyFromString(publicKey), getRSAPrivateKeyFromString(privateKey));
	}

	/**
	 * 构造方法
	 *
	 * @param publicKey RSA公钥
	 */
	public RSACipher(RSAPublicKey publicKey) {

		try {

			this.publicKey = publicKey;

			this.encrypter = Cipher.getInstance("RSA");

			this.encrypter.init(Cipher.ENCRYPT_MODE, this.publicKey);

			this.encoder = new BASE64Encoder();

			this.staticDigester = MessageDigest.getInstance("SHA-384");
			this.oneoffDigester = MessageDigest.getInstance("SHA-384");

		} catch (InvalidKeyException | NoSuchAlgorithmException | NoSuchPaddingException exception) {
			// 这些异常不可能发生 - 使用ADoptOpenJDK 8
			// InvalidKeyException ---------------- 由密钥生成器生成，输入密钥错误已经在上一级构造方法抛出
			// NoSuchPaddingException ------------- 不允许用户自定义算法
			// NoSuchAlgorithmException ----------- 不允许用户自定义算法
		}
	}

	/**
	 * 构造方法
	 *
	 * @param publicKey  RSA公钥
	 * @param privateKey RSA私钥
	 */
	public RSACipher(RSAPublicKey publicKey, RSAPrivateKey privateKey) {

		try {

			this.publicKey = publicKey;
			this.privateKey = privateKey;

			this.encrypter = Cipher.getInstance("RSA");
			this.decrypter = Cipher.getInstance("RSA");

			this.encrypter.init(Cipher.ENCRYPT_MODE, this.publicKey);
			this.decrypter.init(Cipher.DECRYPT_MODE, this.privateKey);

			this.encoder = new BASE64Encoder();
			this.decoder = new BASE64Decoder();

			this.staticDigester = MessageDigest.getInstance("SHA-384");
			this.oneoffDigester = MessageDigest.getInstance("SHA-384");

		} catch (InvalidKeyException | NoSuchAlgorithmException | NoSuchPaddingException exception) {
			// 这些异常不可能发生 - 使用ADoptOpenJDK 8
			// InvalidKeyException ---------------- 由密钥生成器生成，输入密钥错误已经在上一级构造方法抛出
			// NoSuchPaddingException ------------- 不允许用户自定义算法
			// NoSuchAlgorithmException ----------- 不允许用户自定义算法
		}
	}

	private static RSAPublicKey getRSAPublicKeyFromString(String publicKey) throws InvalidPublicKeyException {
		try {
			KeyFactory factory = KeyFactory.getInstance("RSA");
			byte[] publicKeyString = new BASE64Decoder().decodeBuffer(publicKey);
			return (RSAPublicKey) factory.generatePublic(new X509EncodedKeySpec(publicKeyString));
		} catch (IOException | InvalidKeySpecException exception) {
			throw new InvalidPublicKeyException("Invalidate publickey, make sure is formated as X509 and encode with BASE64.");
		} catch (NoSuchAlgorithmException exception) {
			return null;
			// 这些异常不可能发生 - 使用ADoptOpenJDK 8
			// NoSuchAlgorithmException ----------- 不允许用户自定义算法
		}
	}

	private static RSAPrivateKey getRSAPrivateKeyFromString(String privateKey) throws InvalidPrivateKeyException {
		try {
			KeyFactory factory = KeyFactory.getInstance("RSA");
			byte[] privateKeyString = new BASE64Decoder().decodeBuffer(privateKey);
			return (RSAPrivateKey) factory.generatePrivate(new PKCS8EncodedKeySpec(privateKeyString));
		} catch (IOException | InvalidKeySpecException exception) {
			throw new InvalidPrivateKeyException("Invalidate publickey, make sure is formated as X509 and encode with BASE64.");
		} catch (NoSuchAlgorithmException exception) {
			return null;
			// 这些异常不可能发生 - 使用ADoptOpenJDK 8
			// NoSuchAlgorithmException ----------- 不允许用户自定义算法
		}

	}

	private static KeyPair generateKeyPair(String randomSeed, int keyLength) {
		try {

			Provider provider = Security.getProvider("SUN");
			SecureRandom random = SecureRandom.getInstance("SHA1PRNG", provider);
			random.setSeed(randomSeed.getBytes(StandardCharsets.UTF_8));

			KeyPairGenerator generator = KeyPairGenerator.getInstance("RSA");
			generator.initialize(keyLength, random);

			return generator.generateKeyPair();

		} catch (NoSuchAlgorithmException exception) {
			return null;
			// 这些异常不可能发生 - 使用ADoptOpenJDK 8
			// NoSuchAlgorithmException ----------- 不允许用户自定义算法
		}
	}

	// ==========================================================================================================================================================
	//
	//
	//
	// ==========================================================================================================================================================

	/**
	 * 加密模式1
	 *
	 * @param content 原文
	 * @return 密文
	 */
	public String encrypt(String content) {

		try {

			byte[] tmp1 = content.getBytes(StandardCharsets.UTF_8);
			byte[] tmp2 = this.encrypter.doFinal(tmp1);
			return this.encoder.encode(tmp2);

		} catch (IllegalBlockSizeException | BadPaddingException exception) {
			exception.printStackTrace();
			return null;
			// 这些异常不可能发生
			// BadPaddingException ------- 不允许用户自定义算法
			// IllegalBlockSizeException - 不允许用户传入byte[]
		}
	}

	/**
	 * 解密模式1
	 *
	 * @param content 密文
	 * @return 原文
	 * @throws IOException 输入错误的内容
	 */
	public String decrypt(String content) throws IOException {

		try {

			byte[] tmp1 = this.decoder.decodeBuffer(content);
			byte[] tmp2 = this.decrypter.doFinal(tmp1);
			return new String(tmp2, StandardCharsets.UTF_8);

		} catch (IOException exception) {
			exception.printStackTrace();
			throw exception;

		} catch (IllegalBlockSizeException | BadPaddingException exception) {
			exception.printStackTrace();
			return null;
			// 这些异常不可能发生
			// BadPaddingException ------- 不允许用户自定义算法
			// IllegalBlockSizeException - 不允许用户传入byte[]
		}
	}

	/**
	 * 加密模式2
	 *
	 * @param content 原文
	 * @return 密文
	 */
	public String encryptHash(String content) {

		try {

			byte[] rawMessage = content.getBytes(StandardCharsets.UTF_8);

			byte[] sizePart = new byte[8];
			byte[] hashPart = new byte[8];

			int rawMessageLength = rawMessage.length;
			byte[] result = new byte[16 + rawMessageLength];

			sizePart = Integer.toHexString(rawMessageLength).getBytes(StandardCharsets.UTF_8);
			int sizePartLength = sizePart.length;
			System.arraycopy(sizePart, 0, result, 8 - sizePartLength, sizePartLength);

			this.oneoffDigester.update(rawMessage);
			hashPart = this.oneoffDigester.digest();
			System.arraycopy(hashPart, 0, result, 8, 8);

			System.arraycopy(rawMessage, 0, result, 16, rawMessageLength);

			return this.encoder.encode(this.encrypter.doFinal(result));

		} catch (IllegalBlockSizeException | BadPaddingException exception) {
			return null;
			// 这些异常不可能发生
			// BadPaddingException ------- 不允许用户自定义算法
			// IllegalBlockSizeException - 不允许用户传入byte[]
		}
	}

	/**
	 * 解密模式2
	 *
	 * @param content 密文
	 * @return 原文
	 * @throws IOException                     输入了错误的内容
	 * @throws MessageSizeCheckFailedException 消息长度验证不通过
	 * @throws MessageHashCheckFailedException 消息哈希验证不通过
	 */
	public String decryptHash(String content) throws IOException, MessageSizeCheckFailedException, MessageHashCheckFailedException {

		try {

			byte[] rawMessage = this.decrypter.doFinal(this.decoder.decodeBuffer(content));

			byte[] sizePart = new byte[8];
			byte[] hashPart = new byte[8];

			int actualMessageLength = rawMessage.length - 16;

			System.arraycopy(rawMessage, 0, sizePart, 0, 8);
			int claminMessagelength = Integer.valueOf(new String(sizePart).trim(), 16);
			if (claminMessagelength != actualMessageLength) { throw new MessageSizeCheckFailedException(claminMessagelength, actualMessageLength); }

			System.arraycopy(rawMessage, 8, hashPart, 0, 8);

			byte[] mesgPart = new byte[claminMessagelength];
			System.arraycopy(rawMessage, 16, mesgPart, 0, claminMessagelength);
			this.oneoffDigester.update(mesgPart);
			byte[] digest = this.oneoffDigester.digest();

			if (!isSame(hashPart, digest)) { throw new MessageHashCheckFailedException(hashPart, digest); }

			return new String(mesgPart, StandardCharsets.UTF_8);

		} catch (IllegalBlockSizeException | BadPaddingException exception) {
			return null;
			// 这些异常不可能发生
			// BadPaddingException ------- 不允许用户自定义算法
			// IllegalBlockSizeException - 不允许用户传入byte[]
		}
	}

	public String encraptPhaseHash(String content) {

		try {

			byte[] rawMessage = content.getBytes(StandardCharsets.UTF_8);

			byte[] sizePart = new byte[8];
			byte[] hashPart = new byte[8];

			int rawMessageLength = rawMessage.length;
			byte[] result = new byte[16 + rawMessageLength];

			sizePart = Integer.toHexString(rawMessageLength).getBytes(StandardCharsets.UTF_8);
			int sizePartLength = sizePart.length;
			System.arraycopy(sizePart, 0, result, 8 - sizePartLength, sizePartLength);

			this.staticDigester.update(rawMessage);
			hashPart = ((MessageDigest) this.staticDigester.clone()).digest();
			System.arraycopy(hashPart, 0, result, 8, 8);

			System.arraycopy(rawMessage, 0, result, 16, rawMessageLength);

			return this.encoder.encode(this.encrypter.doFinal(result));

		} catch (IllegalBlockSizeException | BadPaddingException | CloneNotSupportedException exception) {
			return null;
			// 这些异常不可能发生
			// BadPaddingException -------- 不允许用户自定义算法
			// IllegalBlockSizeException -- 不允许用户传入byte[]
			// CloneNotSupportedException - MessageDigest是能够克隆的
		}
	}

	public String decryptPhaseHash(String content) throws IOException, MessageSizeCheckFailedException, MessageHashCheckFailedException {
		try {

			byte[] rawMessage = this.decrypter.doFinal(this.decoder.decodeBuffer(content));

			byte[] sizePart = new byte[8];
			byte[] hashPart = new byte[8];

			int actualMessageLength = rawMessage.length - 16;

			System.arraycopy(rawMessage, 0, sizePart, 0, 8);
			int claminMessagelength = Integer.valueOf(new String(sizePart).trim(), 16);
			if (claminMessagelength != actualMessageLength) { throw new MessageSizeCheckFailedException(claminMessagelength, actualMessageLength); }

			System.arraycopy(rawMessage, 8, hashPart, 0, 8);

			byte[] mesgPart = new byte[claminMessagelength];
			System.arraycopy(rawMessage, 16, mesgPart, 0, claminMessagelength);

			this.staticDigester.update(mesgPart);
			byte[] digest = ((MessageDigest) this.staticDigester.clone()).digest();

			if (!isSame(hashPart, digest)) { throw new MessageHashCheckFailedException(hashPart, digest); }

			return new String(mesgPart, StandardCharsets.UTF_8);

		} catch (IOException exception) {
			exception.printStackTrace();
			throw exception;

		} catch (IllegalBlockSizeException | BadPaddingException | CloneNotSupportedException exception) {
			return null;
			// 这些异常不可能发生
			// BadPaddingException ------- 不允许用户自定义算法
			// NoSuchAlgorithmException -- 不允许用户自定义算法
			// IllegalBlockSizeException - 不允许用户传入byte[]
		}
	}

	private static boolean isSame(byte[] A, byte[] B) {
		// 只发送前8位，所以只比较前8位，java没有数组截取 "python[0:7]" 所以只能写的这么蠢
		// @formatter:off
		return	(A[0] == B[0]) && (A[1] == B[1]) && (A[2] == B[2]) && (A[3] == B[3]) &&
				(A[4] == B[4]) && (A[5] == B[5]) && (A[6] == B[6]) && (A[7] == B[7]) ;
		// @formatter:on
	}

	// ==========================================================================================================================================================
	//
	//
	//
	// ==========================================================================================================================================================

	public String getEncodedPublicKey() {
		return this.encoder.encode(this.publicKey.getEncoded());
	}

	public String getEncodedPrivateKey() {
		return this.encoder.encode(this.privateKey.getEncoded());
	}

	// ==========================================================================================================================================================
	//
	//
	//
	// ==========================================================================================================================================================

	public static class MessageSizeCheckFailedException extends GeneralSecurityException {
		private static final long serialVersionUID = 0;

		public MessageSizeCheckFailedException(int claimSize, int actualSize) {
			super("Message claim length is " + claimSize + ", But actual length is " + actualSize);
		}
	}

	public static class MessageHashCheckFailedException extends GeneralSecurityException {
		private static final long serialVersionUID = 0;

		public MessageHashCheckFailedException(byte[] claimHash, byte[] actualHash) {
			super("Message claim digest is " + Arrays.toString(claimHash) + ", But actual digest is " + Arrays.toString(Arrays.copyOfRange(actualHash, 0, 8)));
		}
	}

	public static class InvalidPublicKeyException extends InvalidKeyException {
		private static final long serialVersionUID = 0;

		public InvalidPublicKeyException(String message) {
			super(message);
		}
	}

	public static class InvalidPrivateKeyException extends InvalidKeyException {
		private static final long serialVersionUID = 0;

		public InvalidPrivateKeyException(String message) {
			super(message);
		}
	}
}
package studio.blacktech.coolqbot.furryblack.common.Security.Utility;

import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.Provider;
import java.security.SecureRandom;
import java.security.Security;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.X509EncodedKeySpec;

import javax.crypto.KeyAgreement;
import javax.crypto.interfaces.DHPublicKey;
import javax.crypto.spec.DHParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

/***
 * 使用标准JavaCipher包装的Diffie Hellman密钥交换算法，生成标准SecretKeySpec密钥。 *
 *
 * @author Alceatraz Warprays
 *
 */
public class DiffieHellmanKeyGenerator {

	private BASE64Encoder encoder;
	private BASE64Decoder decoder;

	private KeyFactory factory;
	private KeyAgreement agreement;

	private KeyPair keyPair;

	/**
	 * 双方都使用此构造函数
	 */
	public DiffieHellmanKeyGenerator() {

		this.encoder = new BASE64Encoder();
		this.decoder = new BASE64Decoder();

		try {

			this.factory = KeyFactory.getInstance("DH");
			this.agreement = KeyAgreement.getInstance(this.factory.getAlgorithm());

		} catch (NoSuchAlgorithmException exception) {
			// 这些异常不可能发生 - 使用ADoptOpenJDK 8
			// NoSuchAlgorithmException ----------- 不允许用户自定义算法
		}

	}

	/**
	 * 发起方（Alice）使用这个方法初始化
	 *
	 * @return 发起方公钥
	 */
	public String init() {

		try {

			Provider provider = Security.getProvider("SUN");
			SecureRandom random = SecureRandom.getInstance("SHA1PRNG", provider);
			KeyPairGenerator generator = KeyPairGenerator.getInstance(this.factory.getAlgorithm());
			generator.initialize(4096, random);

			this.keyPair = generator.generateKeyPair();
			this.agreement.init(this.keyPair.getPrivate());

			return this.encoder.encode(this.keyPair.getPublic().getEncoded());

		} catch (NoSuchAlgorithmException | InvalidKeyException exception) {
			// 这些异常不可能发生 - 使用ADoptOpenJDK 8
			// NoSuchAlgorithmException ----------- 不允许用户自定义算法
			// InvalidKeyException ---------------- 密钥由生成器生成
			return null;

		}
	}

	/**
	 * 接收方（Bob）使用这个方法初始化
	 *
	 * @param publicKeyString 发起方的公钥
	 * @return 接收方的公钥
	 * @throws InvalidKeyException 传入了错误的密钥，请确保是init()方法返回的密钥
	 */
	public String init(String publicKeyString) throws InvalidKeyException {

		try {

			byte[] publicKeyByte = this.decoder.decodeBuffer(publicKeyString);

			X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(publicKeyByte);
			DHPublicKey publicKey = (DHPublicKey) this.factory.generatePublic(x509KeySpec);
			DHParameterSpec dhParamSpec = publicKey.getParams();
			KeyPairGenerator generator = KeyPairGenerator.getInstance(this.factory.getAlgorithm());
			generator.initialize(dhParamSpec);

			this.keyPair = generator.generateKeyPair();
			this.agreement.init(this.keyPair.getPrivate());
			this.agreement.doPhase(publicKey, true);

			return this.encoder.encode(this.keyPair.getPublic().getEncoded());

		} catch (IOException | InvalidKeyException exception) {

			throw new InvalidKeyException("传入了不合法的密钥");

		} catch (InvalidAlgorithmParameterException | NoSuchAlgorithmException | InvalidKeySpecException exception) {

			// 这些异常不可能发生 (非标准JVM和lib除外，经过测试ADoptOpenJDK不会出现错误)
			// NoSuchAlgorithmException ----------- 不能自定义算法保证绝对合法
			// InvalidKeySpecException ------------ 合法密钥不会生成无效值保证绝对合法
			// InvalidAlgorithmParameterException - 加密解密模式是写死的保证绝对合法
			return null;

		}
	}

	/**
	 * 接收方（Bob）使用此方法生成最终密钥
	 *
	 * @return SecretKeySpec密钥
	 */
	public SecretKeySpec generateFinalKey() {

		byte[] secret = this.agreement.generateSecret();
		return new SecretKeySpec(secret, 0, 16, "AES");

	}

	/**
	 * 发起方（Alice）使用此方法生成最终密钥
	 *
	 * @param publicKeyString 接收方的公钥
	 * @return SecretKeySpec密钥
	 * @throws InvalidKeyException 传入了错误的密钥
	 */
	public SecretKeySpec generateFinalKey(String publicKeyString) throws InvalidKeyException {

		try {

			byte[] publicKeyByte = this.decoder.decodeBuffer(publicKeyString);
			X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(publicKeyByte);
			DHPublicKey publicKey = (DHPublicKey) this.factory.generatePublic(x509KeySpec);

			this.agreement.doPhase(publicKey, true);
			byte[] secret = this.agreement.generateSecret();

			return new SecretKeySpec(secret, 0, 16, "AES");

		} catch (IOException | InvalidKeyException exception) {

			throw new InvalidKeyException("传入了不合法的密钥");

		} catch (InvalidKeySpecException exception) {

			// 这些异常不可能发生 (非标准JVM和lib除外，经过测试ADoptOpenJDK不会出现错误)
			// InvalidKeySpecException ------------ 合法密钥不会生成无效值保证绝对合法
			return null;
		}
	}

}
package studio.blacktech.coolqbot.furryblack.common.Security.Utility;

import java.security.SecureRandom;

public class RandomTools {

	private static final String RANDOMRANGE = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

	public static final String genRandomPort() {
		SecureRandom random = new SecureRandom();
		return String.valueOf(random.nextInt(64512) + 1024);
	}

	public static final String genRandomString() {
		return RandomTools.genRandomString(new SecureRandom());
	}

	public static final String genRandomString(int size) {
		return RandomTools.genRandomString(new SecureRandom(), size);
	}

	public static final String genRandomString(SecureRandom random) {
		return RandomTools.genRandomString(new SecureRandom(), 16);
	}

	public static final String genRandomString(SecureRandom random, int size) {
		StringBuilder builder = new StringBuilder();
		for (int i = 0; i < size; i++) {
			builder.append(RandomTools.RANDOMRANGE.charAt(random.nextInt(62)));
		}
		return builder.toString();
	}
}
package studio.blacktech.coolqbot.furryblack.common.Security.Utility;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class TimeBaseVerification {

	public TimeBaseVerification(String key) {

		try {

			MessageDigest digest = MessageDigest.getInstance("SHA-512");
			digest.update(key.getBytes(StandardCharsets.UTF_8));

		} catch (NoSuchAlgorithmException exception) {

		}

	}
}
package studio.blacktech.coolqbot.furryblack;

import java.io.File;
import java.io.FileWriter;
import java.nio.file.Paths;

import org.meowy.cqp.jcq.entity.CoolQ;
import org.meowy.cqp.jcq.entity.ICQVer;
import org.meowy.cqp.jcq.entity.IMsg;
import org.meowy.cqp.jcq.entity.IRequest;
import org.meowy.cqp.jcq.event.JcqApp;
import org.meowy.cqp.jcq.event.JcqListener;

import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.exception.NotAFolderException;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleExecutor;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleListener;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleScheduler;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleTrigger;
import studio.blacktech.coolqbot.furryblack.modules.Systemd;

/**
 * 整个BOT的核心，JcqApp的入口类文件 JCQ将会调用约定的生命周期函数
 *
 * 我们不用IoC 我们不用DI 我们只制作高度耦合的专用框架 专用的永远是最好的
 *
 * 拒绝反射地狱 拒绝注解噩梦 拒绝配置 直观 简单 见名知意
 *
 * @author Alceatraz Warprays
 */
public class entry extends JcqApp implements ICQVer, IMsg, IRequest, JcqListener {

	// 绝对不能修改 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓

	public final static String AppID = "studio.blacktech.coolqbot.furryblack.entry";

	@Override
	public String appInfo() {
		return ICQVer.CQAPIVER + "," + AppID;
	}

	// 绝对不能修改 ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑

	/**
	 * Java通常的入口方法，JCQ并不使用这个方法，JCQ使用以下生命周期函数
	 *
	 * startup, enable, disable, exit
	 *
	 * @param parameters 命令行参数
	 */
	public static void main(String[] parameters) {
		System.out.println("This is a JCQ plugin, Not a executable jar file!");
	}

	// ==========================================================================================================================================================
	//
	// 公共恒量
	//
	// ==========================================================================================================================================================

	// 版本ID
	public final static String VerID = "13.3 2019-11-19 (20:30)";

	// 启动时间戳
	public final static long BOOTTIME = System.currentTimeMillis();

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	// 是否启用DEBUG的开关 启动过程为true 启动完成时改为false 此设计有助于debug和启动时异常排查
	private static boolean DEBUG = true;

	private File FOLDER_ROOT;
//	private File FOLDER_CONF;
//	private File FOLDER_DATA;
	private File FOLDER_LOGS;
	private File FILE_LOGGER;

	// 启动日志
	private static LoggerX bootLoggerX;

	// Systemd 对象的持有
	private static Systemd SYSTEMD;

	// ==========================================================================================================================================================
	//
	// 生命周期函数
	//
	// ==========================================================================================================================================================

	// CQ对象的持有
	private static CoolQ CQ;

	// 继承自JCQ JcqAbstract包含这个对象
	private static boolean enable = false;

	// 继承自JCQ JcqAbstract包含这个对象
	private static String appDirectory;

	/**
	 * JCQ 1.3.0 更改了使用方式 南荒喵原话：
	 *
	 * 现在都不提供静态加载的了 不过你可以写个静态变量，然后加载的时候赋值，即可
	 *
	 * 如果说是用的有参构造方法加载的，需要继承JcqApp的
	 *
	 * 还是老的方式的话 那就不用强制继承的，只需要类里提供个CQ变量的
	 *
	 * 嗯 推荐继承JcqApp 不过之后的 JcqAppAbstract 也不会移除 移除的是，无参的构造方式
	 *
	 * @param CQ CQ对象
	 */

	public entry(CoolQ CQ) {
		super(CQ);
		entry.CQ = CQ;
	}

	/**
	 * 生命周期函数：CoolQ启动
	 */
	@Override
	public int startup() {
		return 0;
	}

	/**
	 * 生命周期函数：JcqApp启动
	 */
	@Override
	public int enable() {

		bootLoggerX = new LoggerX();

		bootLoggerX.info(LoggerX.datetime());

		try {

			bootLoggerX.info("Core_Entry", "启动", LoggerX.datetime());

			// ==========================================================================================================================
			// 获取APP存储目录 继承自JCQ JcqAbstract包含这个对象

			appDirectory = CQ.getAppDirectory();

			// ==========================================================================================================================
			// 实例化 data/ logs/ 对象

			this.FOLDER_ROOT = Paths.get(appDirectory, "Core_Entry").toFile();
//			this.FOLDER_CONF = Paths.get(appDirectory, "Core_Entry", "conf").toFile();
//			this.FOLDER_DATA = Paths.get(appDirectory, "Core_Entry", "data").toFile();
			this.FOLDER_LOGS = Paths.get(appDirectory, "Core_Entry", "logs").toFile();
			this.FILE_LOGGER = Paths.get(appDirectory, "Core_Entry", "logs", LoggerX.formatTime("yyyy_MM_dd_HH_mm_ss") + ".txt").toFile();

			this.FOLDER_ROOT = Paths.get(entry.getAppDirectory(), "Core_Entry").toFile();
//			this.FOLDER_CONF = Paths.get(entry.getAppDirectory(), "Core_Entry", "conf").toFile();
//			this.FOLDER_DATA = Paths.get(entry.getAppDirectory(), "Core_Entry", "data").toFile();
			this.FOLDER_LOGS = Paths.get(entry.getAppDirectory(), "Core_Entry", "logs").toFile();

			// ==========================================================================================================================

			bootLoggerX.full("Core_Entry", "存储目录", appDirectory);

			// ==========================================================================================================================
			// 初始化文件夹

			if (!this.FOLDER_ROOT.exists()) {
				bootLoggerX.seek("Core_Entry", "创建目录", this.FOLDER_ROOT.getAbsolutePath());
				this.FOLDER_ROOT.mkdirs();
			}
//			if (!this.FOLDER_CONF.exists()) { bootLoggerX.seek("Core_Entry", "创建目录", this.FOLDER_CONF.getAbsolutePath()); this.FOLDER_CONF.mkdirs(); }
//			if (!this.FOLDER_DATA.exists()) { bootLoggerX.seek("Core_Entry", "创建目录", this.FOLDER_DATA.getAbsolutePath()); this.FOLDER_DATA.mkdirs(); }
			if (!this.FOLDER_LOGS.exists()) {
				bootLoggerX.seek("Core_Entry", "创建目录", this.FOLDER_LOGS.getAbsolutePath());
				this.FOLDER_LOGS.mkdirs();
			}

			if (!this.FOLDER_ROOT.isDirectory()) { throw new NotAFolderException("文件夹被文件占位：" + this.FOLDER_ROOT.getAbsolutePath()); }
//			if (!this.FOLDER_CONF.isDirectory()) { throw new NotAFolderException("文件夹被文件占位：" + this.FOLDER_CONF.getAbsolutePath()); }
//			if (!this.FOLDER_DATA.isDirectory()) { throw new NotAFolderException("文件夹被文件占位：" + this.FOLDER_DATA.getAbsolutePath()); }
			if (!this.FOLDER_LOGS.isDirectory()) { throw new NotAFolderException("文件夹被文件占位：" + this.FOLDER_LOGS.getAbsolutePath()); }

			// ==========================================================================================================================
			// 初始化 启动 系统

			SYSTEMD = new Systemd();

			SYSTEMD.init(bootLoggerX);
			SYSTEMD.boot(bootLoggerX);

			// ==========================================================================================================================

			bootLoggerX.info("Core_Entry", "完成", LoggerX.datetime());
			bootLoggerX.info("Core_Entry", "耗时", (System.currentTimeMillis() - BOOTTIME) + "ms");

			// ==========================================================================================================================

			FileWriter writer = new FileWriter(this.FILE_LOGGER, true);
			writer.append("Bootup ->\n");
			writer.append(bootLoggerX.make(3));
			writer.append("\n");
			writer.flush();
			writer.close();

			// ==========================================================================================================================
			// 启动完成 关闭debug
			// 启动完成 启动Jcq的开关

			DEBUG = false;
			enable = true;

			entry.adminInfo("启动完成 " + LoggerX.datetime());

		} catch (Exception exce) {
			exce.printStackTrace();
			enable = false;
			SYSTEMD.adminInfo(bootLoggerX.make(3));
		}
		return 0;
	}

	/**
	 * 生命周期函数：JcqApp卸载
	 */
	@Override
	public int disable() {
		LoggerX logger = new LoggerX();
		enable = false;
		try {
			logger.info(LoggerX.datetime());
			bootLoggerX.info("Core_Entry", "保存", LoggerX.datetime());
			SYSTEMD.save(logger);
			bootLoggerX.info("Core_Entry", "关闭", LoggerX.datetime());
			SYSTEMD.shut(logger);
			FileWriter writer = new FileWriter(this.FILE_LOGGER, true);
			writer.append("Shutdown ->\n");
			writer.append(logger.make(3));
			writer.flush();
			writer.close();
		} catch (Exception exception) {
			logger.info(exception.getMessage());
		}
		return 0;
	}

	/**
	 * 生命周期函数：CoolQ关闭
	 */
	@Override
	public int exit() {
		return this.disable();
	}

	// ==========================================================================================================================================================
	//
	// 消息处理函数
	//
	// ==========================================================================================================================================================

	/**
	 * 私聊消息处理方法 不应该在此处修改任何内容
	 */
	@Override
	public int privateMsg(int typeid, int messageid, long userid, String message, int messagefont) {
		try {
			SYSTEMD.doUserMessage(typeid, userid, new MessageUser(typeid, userid, message, messageid, messagefont), messageid, messagefont);
		} catch (Exception exception) {
			exception.printStackTrace();
			StringBuilder builder = new StringBuilder();
			builder.append("[私聊消息异常] - " + LoggerX.time() + "\r\n");
			builder.append("用户ID：" + userid + "\r\n");
			builder.append("消息ID：" + messageid + "\r\n");
			builder.append("消息内容：" + message + "\r\n");
			builder.append("消息转储：" + LoggerX.unicode(message) + "\r\n");
			builder.append("异常原因：" + exception.getCause() + "\r\n");
			builder.append("异常消息：" + exception.getMessage() + "\r\n");
			builder.append("异常栈：" + exception.getClass().getName() + "\r\n");
			for (StackTraceElement temp : exception.getStackTrace()) {
				builder.append("        at " + temp.getClassName() + "(" + temp.getMethodName() + ":" + temp.getLineNumber() + ")\r\n");
			}
			SYSTEMD.adminInfo(builder.toString());
			System.out.println(builder.toString());
		}
		return IMsg.MSG_IGNORE;
	}

	/**
	 * 组聊消息处理方法 不应该在此处修改任何内容
	 */
	@Override
	public int discussMsg(int typeid, int messageid, long diszid, long userid, String message, int messagefont) {
		try {
			SYSTEMD.doDiszMessage(diszid, userid, new MessageDisz(diszid, userid, message, messageid, messagefont), messageid, messagefont);
		} catch (Exception exception) {
			exception.printStackTrace();
			StringBuilder builder = new StringBuilder();
			builder.append("[组聊消息异常] - " + LoggerX.time() + "\r\n");
			builder.append("组聊ID：" + diszid + "\r\n");
			builder.append("用户ID：" + userid + "\r\n");
			builder.append("消息ID：" + messageid + "\r\n");
			builder.append("消息内容：" + message + "\r\n");
			builder.append("消息转储：" + LoggerX.unicode(message) + "\r\n");
			builder.append("异常原因：" + exception.getCause() + "\r\n");
			builder.append("异常消息：" + exception.getMessage() + "\r\n");
			builder.append("异常栈：" + exception.getClass().getName() + "\r\n");
			for (StackTraceElement temp : exception.getStackTrace()) {
				builder.append("        at " + temp.getClassName() + "(" + temp.getMethodName() + ":" + temp.getLineNumber() + ")\r\n");
			}
			SYSTEMD.adminInfo(builder.toString());
			System.out.println(builder.toString());
		}
		return IMsg.MSG_IGNORE;
	}

	/**
	 * 群聊消息处理方法 不应该在此处修改任何内容
	 */
	@Override
	public int groupMsg(int typeid, int messageid, long gropid, long userid, String anonymous, String message, int messagefont) {
		try {
			SYSTEMD.doGropMessage(gropid, userid, new MessageGrop(gropid, userid, message, messageid, messagefont), messageid, messagefont);
		} catch (Exception exception) {
			exception.printStackTrace();
			StringBuilder builder = new StringBuilder();
			builder.append("[群聊消息异常] - " + LoggerX.time() + "\r\n");
			builder.append("群聊ID：" + gropid + "\r\n");
			builder.append("用户ID：" + userid + "\r\n");
			builder.append("消息ID：" + messageid + "\r\n");
			builder.append("消息内容：" + message + "\r\n");
			builder.append("消息转储：" + LoggerX.unicode(message) + "\r\n");
			builder.append("异常原因：" + exception.getCause() + "\r\n");
			builder.append("异常消息：" + exception.getMessage() + "\r\n");
			builder.append("异常栈：" + exception.getClass().getName() + "\r\n");
			for (StackTraceElement temp : exception.getStackTrace()) {
				builder.append("        at " + temp.getClassName() + "(" + temp.getMethodName() + ":" + temp.getLineNumber() + ")\r\n");
			}
			SYSTEMD.adminInfo(builder.toString());
			System.out.println(builder.toString());
		}
		return IMsg.MSG_IGNORE;
	}

	// ==========================================================================================================================================================
	//
	// 群成员变动函数
	//
	// ==========================================================================================================================================================

	/**
	 * 成员加群处理方法 不应该在此处修改任何内容
	 */
	@Override
	public int groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) {
		StringBuilder builder = new StringBuilder();
		builder.append("[成员增加] - " + LoggerX.time() + "\r\n");
		builder.append("类型：" + (typeid == 1 ? "自主申请" : "邀请进群") + "\r\n");
		builder.append("群聊ID：" + gropid + "\r\n");
		builder.append("管理ID：" + operid + "(" + SYSTEMD.getNickname(operid) + ")" + "\r\n");
		builder.append("用户ID：" + userid + "(" + SYSTEMD.getNickname(userid) + ")" + "\r\n");
		try {
			SYSTEMD.groupMemberIncrease(typeid, sendtime, gropid, operid, userid);
		} catch (Exception exception) {
			exception.printStackTrace();
			builder.append("[发生异常]\r\n");
			builder.append("异常原因：" + exception.getCause() + "\r\n");
			builder.append("异常消息：" + exception.getMessage() + "\r\n");
			builder.append("异常栈：" + exception.getClass().getName() + "\r\n");
			for (StackTraceElement temp : exception.getStackTrace()) {
				builder.append("        at " + temp.getClassName() + "(" + temp.getMethodName() + ":" + temp.getLineNumber() + ")\r\n");
			}
		} finally {
			System.out.println(builder.toString());
			SYSTEMD.adminInfo(builder.toString());
		}
		return IMsg.MSG_IGNORE;
	}

	/**
	 * 成员退群处理方法 不应该在此处修改任何内容
	 */
	@Override
	public int groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) {
		StringBuilder builder = new StringBuilder();
		builder.append("[成员减少] - " + LoggerX.time() + "\r\n");
		builder.append("类型：" + (typeid == 1 ? "自主退群" : "管理踢出") + "\r\n");
		builder.append("群聊ID：" + gropid + "\r\n");
		builder.append("管理ID：" + operid + "(" + SYSTEMD.getNickname(operid) + ")" + "\r\n");
		builder.append("用户ID：" + userid + "(" + SYSTEMD.getNickname(userid) + ")" + "\r\n");
		try {
			SYSTEMD.groupMemberDecrease(typeid, sendtime, gropid, operid, userid);
		} catch (Exception exception) {
			exception.printStackTrace();
			builder.append("[发生异常]\r\n");
			builder.append("异常原因：" + exception.getCause() + "\r\n");
			builder.append("异常消息：" + exception.getMessage() + "\r\n");
			builder.append("异常栈：" + exception.getClass().getName() + "\r\n");
			for (StackTraceElement temp : exception.getStackTrace()) {
				builder.append("        at " + temp.getClassName() + "(" + temp.getMethodName() + ":" + temp.getLineNumber() + ")\r\n");
			}
		} finally {
			System.out.println(builder.toString());
			SYSTEMD.adminInfo(builder.toString());
		}
		return IMsg.MSG_IGNORE;
	}

	// ==========================================================================================================================================================
	//
	// 事件函数
	//
	// ==========================================================================================================================================================

	/**
	 * 好友添加成功的处理函数 不应该在此处修改任何内容
	 *
	 * 发送欢迎信息 实际工作中，这个东西会提示无法发送消息 貌似是 这个事件触发时 还未建立好友关系 但是添加延时依然无效 原因未知
	 *
	 */
	@Override
	public int friendAdd(int typeid, int sendtime, long userid) {
		new Thread(() -> this.sendFriendAddMessage(userid)).start();
		return 0;
	}

	private void sendFriendAddMessage(long userid) {
		SYSTEMD.userInfo(userid, "你好，在下人工智障。为了礼貌和避免打扰，本BOT不接入AI聊天功能也不支持AT。使用即表示同意最终用户许可，可由/eula查看。\r\n发送/help获取通用帮助\r\n发送/list获取可用命令列表\r\n私聊、讨论组、群聊可用的命令有所不同");
		SYSTEMD.sendEula(userid);
		SYSTEMD.sendHelp(userid);
		SYSTEMD.sendListUser(userid);
		SYSTEMD.sendListDisz(userid);
		SYSTEMD.sendListGrop(userid);
	}

	/**
	 * 好友添加请求 不应该在此处修改任何内容
	 */
	@Override
	public int requestAddFriend(int typeid, int sendtime, long userid, String message, String flag) {
		StringBuilder builder = new StringBuilder();
		builder.append("[添加好友请求] - " + LoggerX.time() + "\r\n");
		builder.append("用户ID：" + userid + "(" + SYSTEMD.getNickname(userid) + ")\r\n");
		builder.append("请求时间：" + sendtime + "\r\n");
		builder.append("验证消息：" + message + "\r\n");
		SYSTEMD.adminInfo(builder.toString());
		CQ.setFriendAddRequest(flag, IRequest.REQUEST_ADOPT, String.valueOf(userid));
		return 0;
	}

	/**
	 * 群组添加请求 不应该在此处修改任何内容
	 */
	@Override
	public int requestAddGroup(int typeid, int sendtime, long gropid, long userid, String message, String flag) {
		StringBuilder builder = new StringBuilder();
		switch (typeid) {
		case 1:
			builder.append("[申请入群] - " + LoggerX.time() + "\r\n");
			builder.append("群聊ID：" + gropid + "\r\n");
			builder.append("用户ID：" + userid + "(" + SYSTEMD.getNickname(userid) + ")\r\n");
			builder.append("请求时间：" + sendtime + "\r\n");
			builder.append("验证消息：" + (message.length() == 0 ? "无" : message));
			break;
		case 2:
			builder.append("[邀请入群] - " + LoggerX.time() + "\r\n");
			builder.append("群聊ID：" + gropid + "\r\n");
			builder.append("用户ID：" + userid + "(" + SYSTEMD.getNickname(userid) + ")\r\n");
			builder.append("请求时间：" + sendtime + "\r\n");
			builder.append("验证消息：" + (message.length() == 0 ? "无" : message));
			CQ.setGroupAddRequest(flag, IRequest.REQUEST_GROUP_INVITE, IRequest.REQUEST_ADOPT, null);
			break;
		}

		SYSTEMD.adminInfo(builder.toString());
		return 0;
	}

	/**
	 * 禁言事件 不应该在此处修改任何内容
	 *
	 */
	@Override
	public int groupBan(int typeid, int sendtime, long gropid, long operid, long userid, long duration) {
		StringBuilder builder = new StringBuilder();
		builder.append(userid == 0 ? "[全体" : "[");
		builder.append(typeid == 1 ? "解禁]" : "禁言]");
		builder.append(LoggerX.time() + "\r\n");
		builder.append("群聊ID：" + gropid + "\r\n");
		builder.append("管理ID：" + operid + "(" + SYSTEMD.getNickname(operid) + ")\r\n");
		if (userid != 0) { builder.append("用户ID：" + userid + "(" + SYSTEMD.getNickname(userid) + ")\r\n"); }
		if (userid != 1) { builder.append("时间：" + duration); }
		SYSTEMD.adminInfo(builder.toString());
		return 0;
	}

	/**
	 * 文件上传事件 不应该在此处修改任何内容
	 */
	@Override
	public int groupUpload(int typeid, int sendtime, long gropid, long userid, String file) {
		return 0;
	}

	/**
	 * 管理员变动事件 不应该在此处修改任何内容
	 */
	@Override
	public int groupAdmin(int typeid, int sendtime, long gropid, long userid) {
		StringBuilder builder = new StringBuilder();
		builder.append("[");
		builder.append(typeid == 1 ? "解除" : "任命");
		builder.append("管理] - " + LoggerX.time() + "\r\n");
		builder.append("群聊ID：" + gropid + "\r\n");
		builder.append("用户ID：" + userid + "(" + SYSTEMD.getNickname(userid) + ")\r\n");
		SYSTEMD.adminInfo(builder.toString());
		return 0;
	}

	// ==========================================================================================================================================================
	//
	// 工具函数
	//
	// ==========================================================================================================================================================

	/**
	 * 获取Systemd对象
	 *
	 * @return Systemd对象
	 */
	public static Systemd getSystemd() {
		return SYSTEMD;
	}

	/**
	 * 切换DEBUG模式
	 *
	 * @return 是否开启DEBUG模式
	 */
	public static boolean switchDEBUG() {
		DEBUG = !DEBUG;
		return DEBUG;
	}

	/**
	 * 获取是否开启DEBUG模式
	 *
	 * @return 是否开启DEBUG模式
	 */
	public static boolean DEBUG() {
		return DEBUG;
	}

	/**
	 * 获取启动日志
	 *
	 * @param level 日志级别
	 * @return 启动日志
	 */
	public static String getBootLogger(int level) {
		return bootLoggerX.make(level);
	}

	/**
	 * 获取开关状态
	 *
	 * @return 开 / 关
	 */
	public static boolean isEnable() {
		return enable;
	}

	/**
	 * 设置开关
	 *
	 * @param mode 开 / 关
	 */
	public static void setEnable(boolean mode) {
		enable = mode;
	}

	/**
	 * 获取CQ对象 1.3.0开始CQ不再是静态调用
	 *
	 * @return CQ对象
	 */
	public static CoolQ getCQ() {
		return CQ;
	}

	/**
	 * 获取存储目录的路径
	 *
	 * @return 存储路径
	 */
	public static String getAppDirectory() {
		return appDirectory;
	}

	// ==========================================================================================================================================================
	//
	// 方法传递
	//
	// ==========================================================================================================================================================

	/**
	 * 判断一个ID是否为BOT自身
	 *
	 * @param userid 用户ID
	 * @return 是 / 否
	 */
	public static boolean isMyself(long userid) {
		return SYSTEMD.isMyself(userid);
	}

	/**
	 * 判断一个ID是否为管理员（JCQ设置的管理，并非qq群管理）
	 *
	 * @param userid 用户ID
	 * @return 是 / 否
	 */
	public static boolean isAdmin(long userid) {
		return SYSTEMD.isAdmin(userid);
	}

	/**
	 * 给管理员发消息
	 *
	 * @param message 消息
	 */
	public static void adminInfo(String message) {
		SYSTEMD.adminInfo(message);
	}

	/**
	 * 给管理员发消息
	 *
	 * @param message 消息
	 */
	public static void adminInfo(String[] message) {
		SYSTEMD.adminInfo(message);
	}

	/**
	 * 给用户发私聊
	 *
	 * @param userid  用户ID
	 * @param message 消息
	 */
	public static void userInfo(long userid, String message) {
		SYSTEMD.userInfo(userid, message);
	}

	/**
	 * 给用户发私聊
	 *
	 * @param userid  用户ID
	 * @param message 消息
	 */
	public static void userInfo(long userid, String[] message) {
		SYSTEMD.userInfo(userid, message);
	}

	/**
	 * 在讨论组发消息
	 *
	 * @param diszid  讨论组ID
	 * @param message 消息
	 */
	public static void diszInfo(long diszid, String message) {
		SYSTEMD.diszInfo(diszid, message);
	}

	/**
	 * 在讨论组发消息
	 *
	 * @param diszid  讨论组ID
	 * @param message 消息
	 */
	public static void diszInfo(long diszid, String[] message) {
		SYSTEMD.diszInfo(diszid, message);
	}

	/**
	 * 在讨论组发消息 并at某人
	 *
	 * @param diszid  讨论组ID
	 * @param userid  用户ID
	 * @param message 消息
	 */
	public static void diszInfo(long diszid, long userid, String message) {
		SYSTEMD.diszInfo(diszid, userid, message);
	}

	/**
	 * 在群聊发消息
	 *
	 * @param gropid  群组ID
	 * @param message 消息
	 */
	public static void gropInfo(long gropid, String message) {
		SYSTEMD.gropInfo(gropid, message);
	}

	/**
	 * 在群聊发消息
	 *
	 * @param gropid  群组ID
	 * @param message 消息
	 */
	public static void gropInfo(long gropid, String[] message) {
		SYSTEMD.gropInfo(gropid, message);
	}

	/**
	 * 在群聊发消息 并at某人
	 *
	 * @param gropid  群组ID
	 * @param userid  用户ID
	 * @param message 消息
	 */
	public static void gropInfo(long gropid, long userid, String message) {
		SYSTEMD.gropInfo(gropid, userid, message);
	}

	/**
	 * 私聊某人 /info
	 *
	 * @param userid 用户ID
	 */
	public static void sendInfo(long userid) {
		SYSTEMD.sendInfo(userid);
	}

	/**
	 * 私聊某人 /eula
	 *
	 * @param userid 用户ID
	 */
	public static void sendEula(long userid) {
		SYSTEMD.sendEula(userid);
	}

	/**
	 * 私聊某人 /help
	 *
	 * @param userid 用户ID
	 */
	public static void sendHelp(long userid) {
		SYSTEMD.sendHelp(userid);
	}

	/**
	 * 私聊某人 /help $name
	 *
	 * @param userid 用户ID
	 * @param name   模块名
	 */
	public static void sendHelp(long userid, String name) {
		SYSTEMD.sendHelp(userid, name);
	}

	/**
	 * 私聊某人 私聊模式/list
	 *
	 * @param userid 用户ID
	 */
	public static void sendListUser(long userid) {
		SYSTEMD.sendListUser(userid);
	}

	/**
	 * 私聊某人 讨论组模式/list
	 *
	 * @param userid 用户ID
	 */
	public static void sendListDisz(long userid) {
		SYSTEMD.sendListDisz(userid);
	}

	/**
	 * 私聊某人 群组模式/list
	 *
	 * @param userid 用户ID
	 */
	public static void sendListGrop(long userid) {
		SYSTEMD.sendListGrop(userid);
	}

	/**
	 * 从昵称对应表查找昵称
	 *
	 * @param userid 用户ID
	 * @return 昵称
	 */
	public static String getNickname(long userid) {
		return SYSTEMD.getNickname(userid);
	}

	/**
	 * 从昵称对应表查找昵称
	 *
	 * @param gropid 群组ID
	 * @param userid 用户ID
	 * @return 昵称
	 */
	public static String getGropnick(long gropid, long userid) {
		return SYSTEMD.getGropNick(gropid, userid);
	}

	/**
	 * 获取定时器
	 *
	 * @param name 名称
	 * @return 实例
	 */
	public static ModuleScheduler getScheduler(String name) {
		return SYSTEMD.getScheduler(name);
	}

	/**
	 * 获取触发器
	 *
	 * @param name 名称
	 * @return 实例
	 */
	public static ModuleTrigger getTrigger(String name) {
		return SYSTEMD.getTrigger(name);
	}

	/**
	 * 获取监听器
	 *
	 * @param name 名称
	 * @return 实例
	 */
	public static ModuleListener getListener(String name) {
		return SYSTEMD.getListener(name);
	}

	/**
	 * 获取执行器
	 *
	 * @param name 名称
	 * @return 实例
	 */
	public static ModuleExecutor getExecutor(String name) {
		return SYSTEMD.getExecutor(name);
	}

}
package studio.blacktech.coolqbot.furryblack.modules.Executor;

import java.math.BigInteger;
import java.util.HashMap;

import studio.blacktech.coolqbot.furryblack.entry;
import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.message.Message;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleExecutor;

public class Executor_acon extends ModuleExecutor {

	private static final long serialVersionUID = 1L;

	// ==========================================================================================================================================================
	//
	// 模块基本配置
	//
	// ==========================================================================================================================================================

	private static String MODULE_PACKAGENAME = "Executor_Acon";
	private static String MODULE_COMMANDNAME = "acon";
	private static String MODULE_DISPLAYNAME = "空调";
	private static String MODULE_DESCRIPTION = "本群冷气开放";
	private static String MODULE_VERSION = "3.0";
	private static String[] MODULE_USAGE = new String[] {
			"/acon cost - 耗电量",
			"/acon off - 关机",
			"/acon wet - 加湿",
			"/acon dry - 除湿",
			"/acon cold - 制冰模式",
			"/acon cool - 制冷模式",
			"/acon warm - 制热模式",
			"/acon bake - 烘烤模式",
			"/acon burn - 烧烤模式",
			"/acon fire - 焚化模式",
			"/acon c2h2 - 乙炔炬模式",
			"/acon argon - 氩气引弧模式",
			"/acon plasma - 等离子模式",
			"/acon nova - 点亮一颗新星",
			"/acon cfnuke - 点燃一颗冷核武器",
			"/acon trnuke - 点燃一颗热核武器",
			"/acon tpnuke - 点燃一颗三相热核弹",
			"/acon ianova - Ia级超新星吸积引燃",
			"/acon ibnova - Ib级超新星吸积引燃",
			"/acon icnova - Ic级超新星吸积引燃",
			"/acon iinova - II级超新星吸积引燃",
			"/acon ~!C??? - Fy:????",
			"/acon ~!R[?? - FT//s??"
	};
	private static String[] MODULE_PRIVACY_STORED = new String[] {};
	private static String[] MODULE_PRIVACY_CACHED = new String[] {
			"按群存储耗电量 - JCQ停止时释放",
			"按群存储耗工作模式 - JCQ停止时释放",
			"按群存储上次更改模式的时间戳 - JCQ停止时释放",
	};
	public static String[] MODULE_PRIVACY_OBTAIN = new String[] {};

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	private HashMap<Long, BigInteger> CONSUMPTION;
	private HashMap<Long, Long> LASTCHANGED;
	private HashMap<Long, Long> WORKINGMODE;

	// ==========================================================================================================================================================
	//
	// 生命周期函数
	//
	// ==========================================================================================================================================================

	public Executor_acon() throws Exception {

		// @formatter:off

		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);

		// @formatter:on

	}

	@Override
	public LoggerX init(LoggerX logger) throws Exception {

		this.CONSUMPTION = new HashMap<>();
		this.LASTCHANGED = new HashMap<>();
		this.WORKINGMODE = new HashMap<>();

		this.ENABLE_USER = false;
		this.ENABLE_DISZ = false;
		this.ENABLE_GROP = true;

		return logger;
	}

	@Override
	public LoggerX boot(LoggerX logger) throws Exception {
		return logger;

	}

	@Override
	public LoggerX shut(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX save(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX exec(LoggerX logger, Message message) throws Exception {
		return logger;
	}

	@Override
	public void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {
		return true;
	}

	@Override
	public boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {
		return true;
	}

	@Override
	public boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {

		long currentTime = System.currentTimeMillis() / 1000;
		long elapseTime = 0L;

		if (!this.CONSUMPTION.containsKey(gropid)) {
			this.CONSUMPTION.put(gropid, BigInteger.ZERO);
			this.LASTCHANGED.put(gropid, currentTime);
			this.WORKINGMODE.put(gropid, 0L);
		}

		if (message.getSection() > 0) {

			BigInteger powerConsumption = this.CONSUMPTION.get(gropid);
			long lastChangModeTime = this.LASTCHANGED.get(gropid);
			long workingmode = this.WORKINGMODE.get(gropid);

			elapseTime = currentTime - lastChangModeTime;

			boolean isChangeMode = true;

			switch (message.getSegment()[0]) {

			case "off":
				entry.gropInfo(gropid, "空调已关闭");
				this.WORKINGMODE.put(gropid, 1L);
				break;

			case "dry":
				entry.gropInfo(gropid, "切换至除湿模式");
				this.WORKINGMODE.put(gropid, 5880L);
				break;

			case "wet":
				entry.gropInfo(gropid, "切换至加湿模式");
				this.WORKINGMODE.put(gropid, 5880L);
				break;

			case "cold":
				entry.gropInfo(gropid, "切换至制冰模式 -20°");
				this.WORKINGMODE.put(gropid, 14700L);
				break;

			case "cool":
				entry.gropInfo(gropid, "切换至制冷模式 26.5°");
				this.WORKINGMODE.put(gropid, 7350L);
				break;

			case "warm":
				entry.gropInfo(gropid, "切换至制热模式 25.5°");
				this.WORKINGMODE.put(gropid, 7350L);
				break;

			case "bake":
				entry.gropInfo(gropid, "切换至烘烤模式 285°");
				this.WORKINGMODE.put(gropid, 14700L);
				break;

			case "burn":
				entry.gropInfo(gropid, "切换至烧烤模式 960°");
				this.WORKINGMODE.put(gropid, 22050L);
				break;

			case "fire":
				entry.gropInfo(gropid, "切换至焚化模式 1,200°");
				this.WORKINGMODE.put(gropid, 29400L);
				break;

			case "c2h2":
				entry.gropInfo(gropid, "切换至乙炔炬模式 3,300°");
				this.WORKINGMODE.put(gropid, 33075L);
				break;

			case "argon":
				entry.gropInfo(gropid, "切换至氩气弧模式 7,550°");
				this.WORKINGMODE.put(gropid, 36750L);
				break;

			case "plasma":
				entry.gropInfo(gropid, "切换至等离子模式 23,500°");
				this.WORKINGMODE.put(gropid, 44100L);
				break;

			case "nova":
				entry.gropInfo(gropid, "切换至新星模式 1,000,000°");
				this.WORKINGMODE.put(gropid, 7350000L);
				break;

			case "cfnuke":
				entry.gropInfo(gropid, "切换至冷核模式 100,000,000°");
				this.WORKINGMODE.put(gropid, 29400000L);
				break;

			case "trnuke":
				entry.gropInfo(gropid, "切换至热核模式 120,000,000°");
				this.WORKINGMODE.put(gropid, 33075000L);
				break;

			case "tfnuke":
				entry.gropInfo(gropid, "切换至三相热核模式 150,000,000°");
				this.WORKINGMODE.put(gropid, 44100000L);
				break;

			case "ianova":
				entry.gropInfo(gropid, "切换至Ia星爆发模式 800,000,000°");
				this.WORKINGMODE.put(gropid, 294000000L);
				break;

			case "ibnova":
				entry.gropInfo(gropid, "切换至Ib新星爆发模式 2,600,000,000°");
				this.WORKINGMODE.put(gropid, 330750000L);
				break;

			case "icnova":
				entry.gropInfo(gropid, "切换至Ic新星爆发模式 2,800,000,000°");
				this.WORKINGMODE.put(gropid, 441000000L);
				break;

			case "iinova":
				entry.gropInfo(gropid, "切换至II新星爆发模式 3,000,000,000°");
				this.WORKINGMODE.put(gropid, 514500000L);
				break;

			case "samrage":
				entry.gropInfo(gropid, "父王之怒 10,000,000,000,000,000,000,000,000,000°");
				this.WORKINGMODE.put(gropid, 73500000000L);
				break;

			case "samrape":
				entry.gropInfo(gropid, "父王之怒 -273.16°");
				this.WORKINGMODE.put(gropid, 73500000000L);
				break;

			case "cost":

				powerConsumption = powerConsumption.add(BigInteger.valueOf(elapseTime * workingmode));

				isChangeMode = false;

				// @formatter:off
				entry.gropInfo(gropid, String.format("累计共耗电：%skW(%s)度\r\n群主须支付：%s元",
						powerConsumption.divide(BigInteger.valueOf(1000)).toString(),
						powerConsumption.divide(BigInteger.valueOf(3600000L)).toString(),
						powerConsumption.divide(BigInteger.valueOf(1936800L)).toString()
						));

				// @formatter:on

				break;

			default:
				break;

			}

			if (isChangeMode) { powerConsumption = powerConsumption.add(BigInteger.valueOf(elapseTime * workingmode)); }

			this.CONSUMPTION.put(gropid, powerConsumption);
			this.LASTCHANGED.put(gropid, currentTime);

		}

		return true;
	}

	// ==========================================================================================================================================================
	//
	// 工具函数
	//
	// ==========================================================================================================================================================

	@Override
	public String[] generateReport(int mode, Message message, Object... parameters) {
		return new String[0];
	}

}package studio.blacktech.coolqbot.furryblack.modules.Executor;

import studio.blacktech.coolqbot.furryblack.entry;
import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.message.Message;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleExecutor;

public class Executor_admin extends ModuleExecutor {

	private static final long serialVersionUID = 1L;

	// ==========================================================================================================================================================
	//
	// 模块基本配置
	//
	// ==========================================================================================================================================================

	private static String MODULE_PACKAGENAME = "Executor_Admin";
	private static String MODULE_COMMANDNAME = "admin";
	private static String MODULE_DISPLAYNAME = "管理工具";
	private static String MODULE_DESCRIPTION = "管理员控制台";
	private static String MODULE_VERSION = "11.0";
	private static String[] MODULE_USAGE = new String[] {};
	private static String[] MODULE_PRIVACY_STORED = new String[] {};
	private static String[] MODULE_PRIVACY_CACHED = new String[] {};
	private static String[] MODULE_PRIVACY_OBTAIN = new String[] {};

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	public final static String MESSAGE_bootlog = "Logger Level\r\n0 mini - 必须介入的消息\r\n1 info - 需要知晓的消息\r\n2 seek - 自动执行的消息\r\n3 full - 所有消息";
	public final static String MESSAGE_initlvl = "init 0 - 切换起停\r\ninit 1 - 初始化\r\ninit 2 - 启动\r\ninit 3 - 保存\r\ninit 4 - 丢弃关闭\r\ninit 5 - 保存关闭\r\ninit 6 - 保存重启";

	// ==========================================================================================================================================================
	//
	// 生命周期函数
	//
	// ==========================================================================================================================================================

	public Executor_admin() throws Exception {

		// @formatter:off

		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);

		// @formatter:on

	}

	@Override
	public LoggerX init(LoggerX logger) throws Exception {

		this.ENABLE_USER = true;
		this.ENABLE_DISZ = true;
		this.ENABLE_GROP = true;

		return logger;
	}

	@Override
	public LoggerX boot(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX shut(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX save(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX exec(LoggerX logger, Message message) throws Exception {
		return logger;
	}

	@Override
	public void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {

		if (entry.isAdmin(userid)) {

			if (message.getSection() == 0) {
				entry.adminInfo(entry.getSystemd().generateReport(0, message, null, null));
			} else {
				switch (message.getSegment(0)) {
				case "report":
					entry.adminInfo(entry.getSystemd().generateReport(10, message, null, null));
					break;
				case "exec":
					entry.adminInfo(entry.getSystemd().exec(new LoggerX(), message).make(3));
					break;
				case "debug":
					entry.adminInfo(entry.switchDEBUG() ? "DEBUG → Enable" : "DEBUG → Disable");
					break;
				}
			}

			return true;

		} else {

			entry.userInfo(userid, "你不是我的Master");
			return false;

		}
	}

	@Override
	public boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {
		if (entry.isAdmin(userid)) {
			if (message.getSection() == 0) {
				entry.adminInfo(entry.getSystemd().generateReport(0, message, null, null));
			} else {
			}
			return true;
		} else {
			entry.diszInfo(diszid, "你不是我的Master");
			return false;
		}
	}

	@Override
	public boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {
		if (entry.isAdmin(userid)) {
			if (message.getSection() == 0) {
				entry.adminInfo(entry.getSystemd().generateReport(0, message, null, null));
			} else {
				switch (message.getSegment(0)) {
				case "report":
					entry.gropInfo(gropid, entry.getSystemd().generateReport(10, message, null, null));
					break;
				case "debug":
					entry.gropInfo(gropid, entry.switchDEBUG() ? "DEBUG → Enable" : "DEBUG → Disable");
					break;
				}
			}
			return true;
		} else {
			entry.gropInfo(gropid, "你不是我的Master");
			return false;
		}
	}

	// ==========================================================================================================================================================
	//
	// 工具函数
	//
	// ==========================================================================================================================================================

	@Override
	public String[] generateReport(int mode, Message message, Object... parameters) {
		return new String[0];
	}

}
package studio.blacktech.coolqbot.furryblack.modules.Executor;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import org.meowy.cqp.jcq.entity.Group;
import org.meowy.cqp.jcq.entity.Member;
import org.meowy.cqp.jcq.entity.QQInfo;

import studio.blacktech.coolqbot.furryblack.entry;
import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.message.Message;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleExecutor;

public class Executor_chou extends ModuleExecutor {

	private static final long serialVersionUID = 1L;

	// ==========================================================================================================================================================
	//
	// 模块基本配置
	//
	// ==========================================================================================================================================================

	private static String MODULE_PACKAGENAME = "Executor_Chou";
	private static String MODULE_COMMANDNAME = "chou";
	private static String MODULE_DISPLAYNAME = "随机抽人";
	private static String MODULE_DESCRIPTION = "从当前群随机选择一个成员";
	private static String MODULE_VERSION = "6.2";
	private static String[] MODULE_USAGE = new String[] {
			"/chou - 随机抽一个人",
			"/chou 理由 - 以某个理由抽一个人"
	};

	private static String[] MODULE_PRIVACY_STORED = new String[] {};
	private static String[] MODULE_PRIVACY_CACHED = new String[] {};
	private static String[] MODULE_PRIVACY_OBTAIN = new String[] {
			"获取命令发送人",
			"获取群成员列表"
	};

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	private HashMap<Long, ArrayList<Long>> MEMBERS;
	private HashMap<Long, ArrayList<Long>> IGNORES;

	private File FILE_IGNORE_USER;

	// ==========================================================================================================================================================
	//
	// 生命周期函数
	//
	// ==========================================================================================================================================================

	public Executor_chou() throws Exception {

		// @formatter:off

		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);

		// @formatter:on

	}

	@Override
	public LoggerX init(LoggerX logger) throws Exception {

		this.initAppFolder(logger);
		this.initConfFolder(logger);

		this.MEMBERS = new HashMap<>();
		this.IGNORES = new HashMap<>();

		this.FILE_IGNORE_USER = Paths.get(this.FOLDER_CONF.getAbsolutePath(), "ignore_user.txt").toFile();

		if (!this.FILE_IGNORE_USER.exists()) { this.FILE_IGNORE_USER.createNewFile(); }

		List<Group> groups = entry.getCQ().getGroupList();

		for (Group group : groups) {
			this.MEMBERS.put(group.getId(), new ArrayList<Long>());
			this.IGNORES.put(group.getId(), new ArrayList<Long>());
		}

		long gropid;
		long userid;

		String line;
		String[] temp;

		BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(this.FILE_IGNORE_USER), StandardCharsets.UTF_8));

		while ((line = reader.readLine()) != null) {

			if (line.startsWith("#")) { continue; }
			if (!line.contains(":")) { continue; }
			if (line.contains("#")) { line = line.substring(0, line.indexOf("#")).trim(); }

			temp = line.split(":");

			if (temp.length != 2) {
				logger.mini(Executor_chou.MODULE_PACKAGENAME, "配置无效", line);
				continue;
			}

			gropid = Long.parseLong(temp[0]);
			userid = Long.parseLong(temp[1]);

			if (this.IGNORES.containsKey(gropid)) {
				this.IGNORES.get(gropid).add(userid);
				logger.seek(Executor_chou.MODULE_PACKAGENAME, "排除用户", gropid + " > " + userid);
			} else {
				logger.seek(Executor_chou.MODULE_PACKAGENAME, "排除用户", "群不存在 " + gropid);
			}

		}

		reader.close();

		ArrayList<Long> tempMembers;
		ArrayList<Long> tempIgnores;

		for (Group group : groups) {

			tempMembers = this.MEMBERS.get(group.getId());
			tempIgnores = this.IGNORES.get(group.getId());

			for (Member member : entry.getCQ().getGroupMemberList(group.getId())) {
				if (entry.isMyself(member.getQQId())) { continue; }
				if (tempIgnores.contains(member.getQQId())) { continue; }
				tempMembers.add(member.getQQId());
			}
		}

		this.ENABLE_USER = false;
		this.ENABLE_DISZ = false;
		this.ENABLE_GROP = true;

		return logger;

	}

	@Override
	public LoggerX boot(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX save(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX shut(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX exec(LoggerX logger, Message message) throws Exception {
		return logger;
	}

	@Override
	public void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) {
		ArrayList<Long> tempMembers = new ArrayList<>();
		if (this.IGNORES.containsKey(gropid)) {
			ArrayList<Long> tempIgnores = this.IGNORES.get(gropid);
			for (Member tempUserid : entry.getCQ().getGroupMemberList(gropid)) {
				if (!tempIgnores.contains(tempUserid.getQQId())) { tempMembers.add(tempUserid.getQQId()); }
			}
		} else {
			for (Member tempUserid : entry.getCQ().getGroupMemberList(gropid)) {
				tempMembers.add(tempUserid.getQQId());
			}
		}
		this.MEMBERS.put(gropid, tempMembers);
	}

	@Override
	public void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) {
		ArrayList<Long> tempMembers = this.MEMBERS.get(gropid);
		tempMembers.remove(userid);
	}

	// ==========================================================================================================================================================
	//
	// 工作函数
	//
	// ==========================================================================================================================================================

	@Override
	public boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {
		return true;
	}

	@Override
	public boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {
		return true;
	}

	@Override
	public boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {
		SecureRandom random = new SecureRandom();
		ArrayList<Long> members = this.MEMBERS.get(gropid);
		int size = members.size();
		if (size < 3) {
			entry.gropInfo(gropid, userid, "至少需要三个成员");
		} else {
			long chouid = 0;
			do {
				chouid = members.get(random.nextInt(size));
			} while (chouid == userid);
			QQInfo member = entry.getCQ().getStrangerInfo(chouid);
			if (message.getSection() == 1) {
				entry.gropInfo(gropid, userid, "随机抽到 " + entry.getGropnick(gropid, member.getQQId()) + "(" + chouid + ")");
			} else {
				entry.gropInfo(gropid, userid, "随机抽到 " + entry.getGropnick(gropid, member.getQQId()) + "(" + chouid + ")： " + message.getOptions());
			}
		}
		return true;
	}

	// ==========================================================================================================================================================
	//
	// 工具函数
	//
	// ==========================================================================================================================================================

	@Override
	public String[] generateReport(int mode, Message message, Object... parameters) {
		return new String[0];
	}
}
package studio.blacktech.coolqbot.furryblack.modules.Executor;

import java.security.SecureRandom;

import studio.blacktech.coolqbot.furryblack.entry;
import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.message.Message;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleExecutor;

public class Executor_dice extends ModuleExecutor {

	private static final long serialVersionUID = 1L;

	// ==========================================================================================================================================================
	//
	// 模块基本配置
	//
	// ==========================================================================================================================================================

	private static String MODULE_PACKAGENAME = "Executor_Dice";
	private static String MODULE_COMMANDNAME = "dice";
	private static String MODULE_DISPLAYNAME = "掷骰子";
	private static String MODULE_DESCRIPTION = "发送一个骰子的魔法表情";
	private static String MODULE_VERSION = "1.0";
	private static String[] MODULE_USAGE = new String[] {
			"/dice - 发送一个魔法表情",
			"/dice 理由 - 为某事投掷一枚骰子"
	};
	private static String[] MODULE_PRIVACY_STORED = new String[] {};
	private static String[] MODULE_PRIVACY_CACHED = new String[] {};
	private static String[] MODULE_PRIVACY_OBTAIN = new String[] {
			"获取命令发送人"
	};

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	// ==========================================================================================================================================================
	//
	// 生命周期函数
	//
	// ==========================================================================================================================================================

	public Executor_dice() throws Exception {

		// @formatter:off

		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);

		// @formatter:on

	}

	@Override
	public LoggerX init(LoggerX logger) throws Exception {

		this.ENABLE_USER = true;
		this.ENABLE_DISZ = true;
		this.ENABLE_GROP = true;

		return logger;
	}

	@Override
	public LoggerX boot(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX shut(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX save(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX exec(LoggerX logger, Message message) throws Exception {
		return logger;
	}

	@Override
	public void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {
		// entry.userInfo(userid, message.getOptions() + "[CQ:dice]");
		entry.userInfo(userid, message.getOptions() + "[CQ:emoji,id=100000" + (new SecureRandom().nextInt(5) + 49) + "]");
		return true;
	}

	@Override
	public boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {
		// entry.diszInfo(diszid, userid, message.getOptions() + "[CQ:dice]");
		entry.diszInfo(diszid, userid, message.getOptions() + "[CQ:emoji,id=100000" + (new SecureRandom().nextInt(5) + 49) + "]");
		return true;
	}

	@Override
	public boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {
		// entry.gropInfo(gropid, userid, message.getOptions() + "[CQ:dice]");
		entry.gropInfo(gropid, userid, message.getOptions() + "[CQ:emoji,id=100000" + (new SecureRandom().nextInt(5) + 49) + "]");
		return true;
	}

	// ==========================================================================================================================================================
	//
	// 工具函数
	//
	// ==========================================================================================================================================================

	@Override
	public String[] generateReport(int mode, Message message, Object... parameters) {
		return new String[0];
	}

}
package studio.blacktech.coolqbot.furryblack.modules.Executor;

import studio.blacktech.coolqbot.furryblack.entry;
import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.message.Message;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleExecutor;

public class Executor_echo extends ModuleExecutor {

	private static final long serialVersionUID = 1L;

	// ==========================================================================================================================================================
	//
	// 模块基本配置
	//
	// ==========================================================================================================================================================

	private static String MODULE_PACKAGENAME = "Executor_Echo";
	private static String MODULE_COMMANDNAME = "echo";
	private static String MODULE_DISPLAYNAME = "回显";
	private static String MODULE_DESCRIPTION = "&0>1";
	private static String MODULE_VERSION = "1.0";
	private static String[] MODULE_USAGE = new String[] {
			"/echo 内容 - &0>1"
	};
	private static String[] MODULE_PRIVACY_STORED = new String[] {};
	private static String[] MODULE_PRIVACY_CACHED = new String[] {};
	private static String[] MODULE_PRIVACY_OBTAIN = new String[] {
			"获取命令发送人"
	};

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	// ==========================================================================================================================================================
	//
	// 生命周期函数
	//
	// ==========================================================================================================================================================

	public Executor_echo() throws Exception {

		// @formatter:off

		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);

		// @formatter:on

	}

	@Override
	public LoggerX init(LoggerX logger) throws Exception {

		this.ENABLE_USER = true;
		this.ENABLE_DISZ = true;
		this.ENABLE_GROP = true;

		return logger;
	}

	@Override
	public LoggerX boot(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX save(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX shut(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX exec(LoggerX logger, Message message) throws Exception {
		return logger;
	}

	@Override
	public void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {
		entry.userInfo(userid, message.getSection() == 0 ? "echo null" : message.getOptions());
		return true;
	}

	@Override
	public boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {
		entry.diszInfo(diszid, userid, message.getSection() == 0 ? "echo null" : message.getOptions());
		return true;
	}

	@Override
	public boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {
		entry.gropInfo(gropid, userid, message.getSection() == 0 ? "echo null" : message.getOptions());
		return true;
	}

	@Override
	public String[] generateReport(int mode, Message message, Object... parameters) {
		return new String[0];
	}

}
package studio.blacktech.coolqbot.furryblack.modules.Executor;

import java.security.SecureRandom;
import java.util.TreeMap;

import studio.blacktech.coolqbot.furryblack.entry;
import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.message.Message;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleExecutor;

/**
 * 这个模块是应邀添加的
 *
 * “那你不怕随机出来鸡蛋壳炒西瓜皮？”
 *
 * “草”
 *
 * @author netuser
 *
 */
public class Executor_food extends ModuleExecutor {

	private static final long serialVersionUID = 1L;

	// ==========================================================================================================================================================
	//
	// 模块基本配置
	//
	// ==========================================================================================================================================================

	private static String MODULE_PACKAGENAME = "Executor_Food";
	private static String MODULE_COMMANDNAME = "food";
	private static String MODULE_DISPLAYNAME = "今天吃什么";
	private static String MODULE_DESCRIPTION = "随机生成看起来可以吃的东西";
	private static String MODULE_VERSION = "1.0";
	private static String[] MODULE_USAGE = new String[] {};
	public static String[] MODULE_PRIVACY_STORED = new String[] {};
	public static String[] MODULE_PRIVACY_CACHED = new String[] {};
	public static String[] MODULE_PRIVACY_OBTAIN = new String[] {};

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	private TreeMap<Integer, TreeMap<Integer, String>> MENU;

	// ==========================================================================================================================================================
	//
	// 生命周期函数
	//
	// ==========================================================================================================================================================

	public Executor_food() throws Exception {

		// @formatter:off

		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);

		// @formatter:on

	}

	@Override
	public LoggerX init(LoggerX logger) throws Exception {

		this.MENU = new TreeMap<>();

		// @formatter:off

		String[][] menu = new String[][] {
			{ "快餐小吃", "自选快餐", "炒饭", "盖饭", "日式咖喱", "泰式咖喱", "印度咖喱", "麻辣烫", "肉夹馍", "黄焖鸡", "鸡公煲", "糯米鸡", "手抓饼", "臭豆腐", "水煮鱼", "酸菜鱼", "串串香" },
			{ "米线粉丝汤", "泡面", "炒粉", "米线", "馄饨", "拉面", "烧饼", "土豆粉", "汆丸子", "云吞面", "热干面", "油泼面", "臊子面", "酸辣粉", "包子粥", "馄饨", "饺子", "肠粉" },
			{ "西式", "汉堡", "披萨", "炸鸡", "牛排", "猪排", "意面", "沙拉", "千层面" },
			{ "硬菜", "锅包肉", "清蒸白鱼", "猪肉炖粉条", "烤鸭", "锅巴菜", "驴肉火烧", "烩面", "九转大肠", "羊杂割", "葫芦鸡", "河西羊羔", "羊杂碎汤", "大盘鸡", "氽灌肠", "松鼠桂鱼", "八宝鸭", "西湖醋鱼", "麻婆豆腐", "辣子鸡", "沔阳三蒸", "剁椒鱼头", "佛跳墙", "臭鳜鱼", "螺蛳粉", "盐焗鸡", "汽锅鸡", "三杯鸡", "酸汤鱼", "清蒸羊羔肉", "烤全羊", "白切文昌鸡", "撒尿牛丸", "葡国鸡", "卤肉饭"	},
			{ "今天群主请客", "蒸羊羔", "蒸熊掌", "蒸鹿尾儿", "烧花鸭", "烧雏鸡", "烧子鹅", "卤猪", "卤鸭", "酱鸡", "腊肉", "松花", "小肚儿", "晾肉", "香肠儿", "什锦苏盘儿", "熏鸡白肚儿", "清蒸八宝猪", "江米酿鸭子", "罐儿野鸡", "罐儿鹌鹑", "卤什件儿", "卤子鹅", "山鸡", "兔脯", "菜蟒", "银鱼", "清蒸哈士蟆", "烩腰丝", "烩鸭腰", "烩鸭条", "清拌鸭丝儿", "黄心管儿", "焖白鳝", "焖黄鳝", "豆豉鲶鱼", "锅烧鲤鱼", "锅烧鲶鱼", "清蒸甲鱼", "抓炒鲤鱼", "抓炒对虾", "软炸里脊", "软炸鸡", "什锦套肠儿", "麻酥油卷儿", "卤煮寒鸦儿", "熘鲜蘑", "熘鱼脯", "熘鱼肚", "熘鱼骨", "熘鱼片儿", "醋熘肉片儿", "烩三鲜儿", "烩白蘑", "烩全饤儿", "烩鸽子蛋", "炒虾仁儿", "烩虾仁儿", "烩腰花儿", "烩海参", "炒蹄筋儿", "锅烧海参", "锅烧白菜", "炸开耳", "炒田鸡", "桂花翅子", "清蒸翅子", "炒飞禽", "炸什件儿", "清蒸江瑶柱", "糖熘芡实米", "拌鸡丝", "拌肚丝", "什锦豆腐", "什锦丁儿", "糟鸭", "糟蟹", "糟鱼", "糟熘鱼片", "熘蟹肉", "炒蟹肉", "清拌蟹肉", "蒸南瓜", "酿倭瓜", "炒丝瓜", "酿冬瓜", "焖鸡掌儿", "焖鸭掌儿", "焖笋", "烩茭白", "茄干晒炉肉", "鸭羹", "蟹肉羹", "三鲜木樨汤", "还有红丸子", "白丸子", "熘丸子", "炸丸子", "南煎丸子", "苜蓿丸子", "三鲜丸子", "四喜丸子", "鲜虾丸子", "鱼脯丸子", "饹炸丸子", "豆腐丸子", "氽丸子", "一品肉", "樱桃肉", "马牙肉", "红焖肉", "黄焖肉", "坛子肉", "烀肉", "扣肉", "松肉", "罐儿肉", "烧肉", "烤肉", "大肉", "白肉", "酱豆腐肉", "红肘子", "白肘子", "水晶肘子", "蜜蜡肘子", "酱豆腐肘子", "扒肘子", "炖羊肉", "烧羊肉", "烤羊肉", "煨羊肉",	"涮羊肉", "五香羊肉", "爆羊肉", "氽三样儿", "爆三样儿", "烩银丝", "烩散丹", "熘白杂碎", "三鲜鱼翅", "栗子鸡", "煎氽活鲤鱼", "板鸭", "筒子鸡" },
			{ "黑暗料理", "黑木耳炒土豆粉丝", "鸡蛋壳烩牛腩炒西瓜皮", "橙子炖三文鱼", "月饼炒西红柿", "鹌鹑蛋炒圣女果", "五花肉爆炒雪莲", "油爆枇杷", "巴黎水炒生姜", "香蕉皮炒猪皮", "神农小土豆炒葡萄皮", "瓜子皮拌秋葵", "菠菜炖蚕豆", "蛇果焗鸡胸", "西瓜汁配泥鳅", "烟台梨焖豆角" }
		};

		// @formatter:on

		for (int i = 1; i < (menu.length + 1); i++) {
			String[] tempmenu = menu[i - 1];
			TreeMap<Integer, String> tempmap = new TreeMap<>();
			for (int j = 0; j < tempmenu.length; j++) {
				tempmap.put(j, tempmenu[j]);
			}
			this.MENU.put(i, tempmap);
		}

		this.ENABLE_USER = true;
		this.ENABLE_DISZ = true;
		this.ENABLE_GROP = true;

		return logger;
	}

	@Override
	public LoggerX boot(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX save(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX shut(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX exec(LoggerX logger, Message message) throws Exception {
		return logger;
	}

	@Override
	public void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {
		entry.userInfo(userid, this.chooseFood(message));
		return true;
	}

	@Override
	public boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {
		entry.diszInfo(diszid, userid, this.chooseFood(message));
		return true;
	}

	@Override
	public boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {
		entry.gropInfo(gropid, userid, this.chooseFood(message));
		return true;
	}

	// ==========================================================================================================================================================
	//
	// 工具函数
	//
	// ==========================================================================================================================================================

	@Override
	public String[] generateReport(int mode, Message message, Object... parameters) {
		return new String[0];
	}

	public String chooseFood(Message message) {
		// food 1
		StringBuilder builder = new StringBuilder();

		if (message.getSection() == 0) {
			for (int mode : this.MENU.keySet()) {
				TreeMap<Integer, String> temp = this.MENU.get(mode);
				builder.append("类别 " + mode + "：" + temp.get(0) + " " + (temp.size() - 1) + "种" + "\r\n");
			}
			builder.setLength(builder.length() - 2);
		} else {
			int mode = Integer.parseInt(message.getSegment(0));
			if (this.MENU.containsKey(mode)) {
				TreeMap<Integer, String> temp = this.MENU.get(mode);
				SecureRandom random = new SecureRandom();
				int res = random.nextInt(temp.size() - 1) + 1;
				builder.append("从 " + temp.get(0) + " 抽到了：" + temp.get(res));
			} else {
				builder.append("没有这个种类，你在想Peach。");
			}
		}
		return builder.toString();
	}

}
package studio.blacktech.coolqbot.furryblack.modules.Executor;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;

import org.meowy.cqp.jcq.entity.Group;
import org.meowy.cqp.jcq.entity.Member;

import studio.blacktech.coolqbot.furryblack.entry;
import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.message.Message;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleExecutor;

public class Executor_jrjp extends ModuleExecutor {

	private static final long serialVersionUID = 1L;

	// ==========================================================================================================================================================
	//
	// 模块基本配置
	//
	// ==========================================================================================================================================================

	private static String MODULE_PACKAGENAME = "Executor_JRJP";
	private static String MODULE_COMMANDNAME = "jrjp";
	private static String MODULE_DISPLAYNAME = "祭祀";
	private static String MODULE_DESCRIPTION = "献祭一个成员 召唤一个视频";
	private static String MODULE_VERSION = "1.2";
	private static String[] MODULE_USAGE = new String[] {
			"/jrjp - 查看今日祭品"
	};
	private static String[] MODULE_PRIVACY_STORED = new String[] {};
	private static String[] MODULE_PRIVACY_CACHED = new String[] {
			"群号-QQ号对应表 - 每日UTC+8 00:00 清空",
			"群号-AV号对应表 - 每日UTC+8 00:00 清空"
	};
	private static String[] MODULE_PRIVACY_OBTAIN = new String[] {
			"获取命令发送人",
			"被抽到成员的昵称和群昵称"
	};

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	private HashMap<Long, Long> AVCODE;
	private HashMap<Long, Long> VICTIM;

	private HashMap<Long, ArrayList<Long>> MEMBERS;
	private HashMap<Long, ArrayList<Long>> IGNORES;

	private File USER_IGNORE;

	private Thread thread;

	private SecureRandom random = new SecureRandom();
	// ==========================================================================================================================================================
	//
	// 生命周期函数
	//
	// ==========================================================================================================================================================

	public Executor_jrjp() throws Exception {

		// @formatter:off

		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);

		// @formatter:on

	}

	@Override
	public LoggerX init(LoggerX logger) throws Exception {

		this.initAppFolder(logger);
		this.initConfFolder(logger);

		this.AVCODE = new HashMap<>();
		this.VICTIM = new HashMap<>();
		this.MEMBERS = new HashMap<>();
		this.IGNORES = new HashMap<>();

		this.USER_IGNORE = Paths.get(this.FOLDER_CONF.getAbsolutePath(), "ignore_user.txt").toFile();

		if (!this.USER_IGNORE.exists()) { this.USER_IGNORE.createNewFile(); }

		List<Group> groups = entry.getCQ().getGroupList();

		for (Group group : groups) {
			this.MEMBERS.put(group.getId(), new ArrayList<Long>());
			this.IGNORES.put(group.getId(), new ArrayList<Long>());
		}

		long gropid;
		long userid;

		BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(this.USER_IGNORE), StandardCharsets.UTF_8));

		String line;
		String[] temp;

		while ((line = reader.readLine()) != null) {

			if (line.startsWith("#")) { continue; }
			if (!line.contains(":")) { continue; }
			if (line.contains("#")) { line = line.substring(0, line.indexOf("#")).trim(); }

			temp = line.split(":");

			if (temp.length != 2) {
				logger.mini(Executor_jrjp.MODULE_PACKAGENAME, "配置错误", line);
				continue;
			}

			gropid = Long.parseLong(temp[0]);
			userid = Long.parseLong(temp[1]);

			if (this.IGNORES.containsKey(gropid)) {
				this.IGNORES.get(gropid).add(userid);
				logger.seek(Executor_jrjp.MODULE_PACKAGENAME, "排除用户", gropid + " > " + userid);
			} else {
				logger.seek(Executor_jrjp.MODULE_PACKAGENAME, "排除用户", "群不存在 " + gropid);
			}

		}

		reader.close();

		for (Group group : groups) {

			ArrayList<Long> tempMembers = this.MEMBERS.get(group.getId());
			ArrayList<Long> tempIgnores = this.IGNORES.get(group.getId());

			for (Member member : entry.getCQ().getGroupMemberList(group.getId())) {

				if (entry.isMyself(member.getQQId())) { continue; }
				if (tempIgnores.contains(member.getQQId())) { continue; }

				tempMembers.add(member.getQQId());
			}

			Executor_jrjp.this.VICTIM.put(group.getId(), tempMembers.get(this.random.nextInt(tempMembers.size())));
			Executor_jrjp.this.AVCODE.put(group.getId(), (long) this.random.nextInt(70000000));

		}

		this.ENABLE_USER = false;
		this.ENABLE_DISZ = false;
		this.ENABLE_GROP = true;

		return logger;
	}

	@Override
	public LoggerX boot(LoggerX logger) throws Exception {

		logger.info(Executor_jrjp.MODULE_PACKAGENAME, "启动工作线程");
		this.thread = new Thread(new Worker());
		this.thread.start();

		return logger;
	}

	@Override
	public LoggerX save(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX shut(LoggerX logger) throws Exception {

		logger.info(Executor_jrjp.MODULE_PACKAGENAME, "终止工作线程");
		this.thread.interrupt();
		this.thread.join();

		return logger;

	}

	@Override
	public LoggerX exec(LoggerX logger, Message message) throws Exception {
		return logger;
	}

	@Override
	public void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {
		return true;
	}

	@Override
	public boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {
		return true;
	}

	@Override
	public boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {

		long victim = this.VICTIM.get(gropid);
		entry.gropInfo(gropid, entry.getGropnick(gropid, victim) + " (" + victim + ") 被作为祭品献祭掉了，召唤出一个神秘视频 https://www.bilibili.com/video/av" + this.AVCODE.get(gropid));
		return true;

	}
	// ==========================================================================================================================================================
	//
	// 工具函数
	//
	// ==========================================================================================================================================================

	@Override
	public String[] generateReport(int mode, Message message, Object... parameters) {
		return new String[0];
	}

	@SuppressWarnings("deprecation")
	class Worker implements Runnable {

		@Override
		public void run() {

			long time;
			Date date;

			do {

				try {

					while (true) {

						date = new Date();
						time = 86400L;
						time = time - date.getSeconds();
						time = time - (date.getMinutes() * 60);
						time = time - (date.getHours() * 3600);
						time = time * 1000;
						Thread.sleep(time);

						Executor_jrjp.this.AVCODE.clear();
						Executor_jrjp.this.VICTIM.clear();

						ArrayList<Long> temp;

						long victim;
						long avcode;

						StringBuilder builder = new StringBuilder();

						for (Long group : Executor_jrjp.this.MEMBERS.keySet()) {

							temp = Executor_jrjp.this.MEMBERS.get(group);
							victim = temp.get(Executor_jrjp.this.random.nextInt(temp.size()));
							avcode = Executor_jrjp.this.random.nextInt(60000000);

							Executor_jrjp.this.VICTIM.put(group, victim);
							Executor_jrjp.this.AVCODE.put(group, avcode);

							builder.append(group + " - " + " AV" + avcode + "\r\n");

						}
					}

				} catch (InterruptedException exception) {

					if (entry.isEnable()) {
						entry.getCQ().logWarning(Executor_jrjp.MODULE_PACKAGENAME, "异常");
					} else {
						entry.getCQ().logInfo(Executor_jrjp.MODULE_PACKAGENAME, "关闭");
					}
				}

			} while (entry.isEnable());
		}
	}
}
package studio.blacktech.coolqbot.furryblack.modules.Executor;

import java.security.SecureRandom;
import java.util.Date;
import java.util.HashMap;

import studio.blacktech.coolqbot.furryblack.entry;
import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.message.Message;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleExecutor;

public class Executor_jrrp extends ModuleExecutor {

	private static final long serialVersionUID = 1L;

	// ==========================================================================================================================================================
	//
	// 模块基本配置
	//
	// ==========================================================================================================================================================

	private static String MODULE_PACKAGENAME = "Executor_JRRP";
	private static String MODULE_COMMANDNAME = "jrrp";
	private static String MODULE_DISPLAYNAME = "今日运气";
	private static String MODULE_DESCRIPTION = "查看今天的运气值";
	private static String MODULE_VERSION = "1.0";
	private static String[] MODULE_USAGE = new String[] {
			"/jrrp - 查看今日运气"
	};
	private static String[] MODULE_PRIVACY_STORED = new String[] {};
	private static String[] MODULE_PRIVACY_CACHED = new String[] {
			"用户与运气对应表 - 每日UTC+8 00:00 清空"
	};
	private static String[] MODULE_PRIVACY_OBTAIN = new String[] {
			"获取命令发送人"
	};

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	private HashMap<Long, Integer> JRRP;

	private Thread thread;

	// ==========================================================================================================================================================
	//
	// 生命周期函数
	//
	// ==========================================================================================================================================================

	public Executor_jrrp() throws Exception {

		// @formatter:off

		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);

		// @formatter:on

	}

	@Override
	public LoggerX init(LoggerX logger) throws Exception {

		this.JRRP = new HashMap<>();

		this.ENABLE_USER = true;
		this.ENABLE_DISZ = true;
		this.ENABLE_GROP = true;

		return logger;
	}

	@Override
	public LoggerX boot(LoggerX logger) throws Exception {

		logger.info(Executor_jrrp.MODULE_PACKAGENAME, "启动工作线程");

		this.thread = new Thread(new Worker());
		this.thread.start();

		return logger;
	}

	@Override
	public LoggerX save(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX shut(LoggerX logger) throws Exception {

		logger.info(Executor_jrrp.MODULE_PACKAGENAME, "终止工作线程");

		this.thread.interrupt();
		this.thread.join();

		return logger;
	}

	@Override
	public LoggerX exec(LoggerX logger, Message message) throws Exception {
		return logger;
	}

	@Override
	public void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {
		if (!this.JRRP.containsKey(userid)) {
			SecureRandom random = new SecureRandom();
			this.JRRP.put(userid, random.nextInt(100));
		}
		entry.userInfo(userid, "今天的运气是" + this.JRRP.get(userid) + "%!!!");
		return true;
	}

	@Override
	public boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {
		if (!this.JRRP.containsKey(userid)) {
			SecureRandom random = new SecureRandom();
			this.JRRP.put(userid, random.nextInt(100));
		}
		entry.diszInfo(diszid, userid, "今天的运气是" + this.JRRP.get(userid) + "%!!!");
		return true;
	}

	@Override
	public boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {
		if (!this.JRRP.containsKey(userid)) {
			SecureRandom random = new SecureRandom();
			this.JRRP.put(userid, random.nextInt(100));
		}
		entry.gropInfo(gropid, userid, "今天的运气是" + this.JRRP.get(userid) + "%!!!");
		return true;
	}

	@Override
	public String[] generateReport(int mode, Message message, Object... parameters) {
		return new String[0];
		/*
		 * if (this.COUNT_USER + this.COUNT_DISZ + this.COUNT_GROP == 0) { return null;
		 * } TreeMap<Integer, Integer> frequency = new TreeMap<>(); for (long temp :
		 * this.JRRP.keySet()) { int luck = this.JRRP.get(temp); frequency.put(luck,
		 * frequency.containsKey(luck) ? frequency.get(luck) + 1 : 1); } int size =
		 * this.JRRP.size(); StringBuilder builder = new StringBuilder();
		 * builder.append("共生成了 "); builder.append(size); builder.append("次"); for
		 * (Entry<Integer, Integer> temp : frequency.entrySet()) {
		 * builder.append("\r\n"); builder.append(temp.getKey()); builder.append(" : ");
		 * builder.append(temp.getValue() * 100 / size); builder.append("%"); } String
		 * res[] = new String[1]; res[0] = builder.toString(); return res;
		 */
	}

	@SuppressWarnings("deprecation")
	class Worker implements Runnable {

		@Override

		public void run() {

			long time;
			Date date;

			do {

				try {

					while (true) {

						date = new Date();
						time = 86400L;
						time = time - date.getSeconds();
						time = time - (date.getMinutes() * 60);
						time = time - (date.getHours() * 3600);
						time = time * 1000;
						Thread.sleep(time);

						Executor_jrrp.this.JRRP.clear();

					}

				} catch (Exception exception) {

					if (entry.isEnable()) {
						entry.getCQ().logWarning(Executor_jrrp.MODULE_PACKAGENAME, "异常");
					} else {
						entry.getCQ().logInfo(Executor_jrrp.MODULE_PACKAGENAME, "关闭");
					}
				}

			} while (entry.isEnable());
		}
	}
}
package studio.blacktech.coolqbot.furryblack.modules.Executor;

import studio.blacktech.coolqbot.furryblack.entry;
import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.message.Message;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleExecutor;

public class Executor_kong extends ModuleExecutor {

	private static final long serialVersionUID = 1L;

	// ==========================================================================================================================================================
	//
	// 模块基本配置
	//
	// ==========================================================================================================================================================

	private static String MODULE_PACKAGENAME = "Executor_Kong";
	private static String MODULE_COMMANDNAME = "kong";
	private static String MODULE_DISPLAYNAME = "变臭";
	private static String MODULE_DESCRIPTION = "给文字添加空格";
	private static String MODULE_VERSION = "1.0";
	private static String[] MODULE_USAGE = new String[] {
			"/kong 原句 - 给原句添加空格"
	};
	private static String[] MODULE_PRIVACY_STORED = new String[] {};
	private static String[] MODULE_PRIVACY_CACHED = new String[] {};
	private static String[] MODULE_PRIVACY_OBTAIN = new String[] {
			"获取命令发送人"
	};

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	// ==========================================================================================================================================================
	//
	// 生命周期函数
	//
	// ==========================================================================================================================================================

	public Executor_kong() throws Exception {

		// @formatter:off

		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);

		// @formatter:on

	}

	@Override
	public LoggerX init(LoggerX logger) throws Exception {
		this.ENABLE_USER = true;
		this.ENABLE_DISZ = true;
		this.ENABLE_GROP = true;

		return logger;
	}

	@Override
	public LoggerX boot(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX save(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX shut(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX exec(LoggerX logger, Message message) throws Exception {
		return logger;
	}

	@Override
	public void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {
		entry.userInfo(userid, message.getSection() == 0 ? "你 想 把 空 气 变 臭 吗" : Executor_kong.kong(message));
		return true;
	}

	@Override
	public boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {
		entry.diszInfo(diszid, userid, message.getSection() == 0 ? "你 想 把 空 气 变 臭 吗" : Executor_kong.kong(message));
		return true;
	}

	@Override
	public boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {
		entry.gropInfo(gropid, userid, message.getSection() == 0 ? "你 想 把 空 气 变 臭 吗" : Executor_kong.kong(message));
		return true;
	}

	private static String kong(Message message) {
		String temp;
		temp = message.getOptions();
		temp = temp.replaceAll(" ", "");
		temp = temp.replaceAll("\\[CQ:.+\\]", "");
		temp = temp.trim();
		StringBuilder builder = new StringBuilder();
		for (int i = 0; i < temp.length(); i++) {
			builder.append(temp.charAt(i));
			builder.append(" ");
		}
		builder.setLength(builder.length() - 1);
		return builder.toString();
	}

	// ==========================================================================================================================================================
	//
	// 工具函数
	//
	// ==========================================================================================================================================================

	@Override
	public String[] generateReport(int mode, Message message, Object... parameters) {
		return new String[0];
	}

}
package studio.blacktech.coolqbot.furryblack.modules.Executor;

import java.security.SecureRandom;

import studio.blacktech.coolqbot.furryblack.entry;
import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.message.Message;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleExecutor;

public class Executor_roll extends ModuleExecutor {

	private static final long serialVersionUID = 1L;

	// ==========================================================================================================================================================
	//
	// 模块基本配置
	//
	// ==========================================================================================================================================================

	private static String MODULE_PACKAGENAME = "Executor_Roll";
	private static String MODULE_COMMANDNAME = "roll";
	private static String MODULE_DISPLAYNAME = "生成随机数";
	private static String MODULE_DESCRIPTION = "生成随机数";
	private static String MODULE_VERSION = "1.1";
	private static String[] MODULE_USAGE = new String[] {
			"/roll - 抽取真假",
			"/roll 数字 - 从零到给定数字任选一个数字",
			"/roll 数字 数字 - 从给定两个数字中间抽取一个"
	};
	private static String[] MODULE_PRIVACY_STORED = new String[] {};
	private static String[] MODULE_PRIVACY_CACHED = new String[] {};
	private static String[] MODULE_PRIVACY_OBTAIN = new String[] {
			"获取命令发送人"
	};

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	private int mode_1 = 0;
	private int mode_2 = 0;
	private int mode_3 = 0;

	private int mode_fucked = 0;
	private int mode_fucker = 0;

	// ==========================================================================================================================================================
	//
	// 生命周期函数
	//
	// ==========================================================================================================================================================

	public Executor_roll() throws Exception {

		// @formatter:off

		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);

		// @formatter:on

	}

	@Override
	public LoggerX init(LoggerX logger) throws Exception {
		this.ENABLE_USER = true;
		this.ENABLE_DISZ = true;
		this.ENABLE_GROP = true;
		return logger;
	}

	@Override
	public LoggerX boot(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX save(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX shut(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX exec(LoggerX logger, Message message) throws Exception {
		return logger;
	}

	@Override
	public void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {
		entry.userInfo(userid, this.roll(message));
		return true;
	}

	@Override
	public boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {
		entry.diszInfo(diszid, userid, this.roll(message));
		return true;
	}

	@Override
	public boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {
		entry.gropInfo(gropid, userid, this.roll(message));
		return true;
	}

	private String roll(Message message) {

		String res = null;
		SecureRandom random = new SecureRandom();

		switch (message.getSection()) {

		// ============================================================

		case 0:
			if (random.nextBoolean()) {
				this.mode_fucker++;
				res = " [CQ:emoji,id=10000049]";
			} else {
				this.mode_fucked++;
				res = " [CQ:emoji,id=10000048]";
			}
			this.mode_1++;
			break;

		// ============================================================

		case 1:
			int range = 100;
			try {
				range = Integer.parseInt(message.getSegment()[0]);
				res = Integer.toString(random.nextInt(range));
				this.mode_2++;
			} catch (Exception exce) {
				res = message.getOptions() + " 是 ";
				if (random.nextBoolean()) {
					this.mode_fucker++;
					res = res + "[CQ:emoji,id=10000049]";
				} else {
					this.mode_fucked++;
					res = res + "[CQ:emoji,id=10000048]";
				}
				this.mode_1++;
			}
			break;

		// ============================================================

		case 2:
			int min = 100;
			int max = 200;
			try {
				min = Integer.parseInt(message.getSegment()[0]);
				max = Integer.parseInt(message.getSegment()[1]);
			} catch (Exception exce) {
				return "参数必须是罗马数字";
			}
			int temp = random.nextInt(max);
			if (temp < min) { temp = ((temp / max) * (max - min)) + min; }
			res = Integer.toString(temp);
			this.mode_3++;
			break;
		}

		// ============================================================

		return res;
	}

	@Override
	public String[] generateReport(int mode, Message message, Object... parameters) {
		if ((this.COUNT_USER + this.COUNT_DISZ + this.COUNT_GROP) == 0) { return null; }
		StringBuilder builder = new StringBuilder();
		builder.append("模式1 - 真假: ");
		builder.append(this.mode_1);
		builder.append(" (");
		builder.append(this.mode_fucker);
		builder.append("/");
		builder.append(this.mode_fucked);
		builder.append(")\r\n模式2 - 单限: ");
		builder.append(this.mode_2);
		builder.append("\r\n模式3 - 双限: ");
		builder.append(this.mode_3);
		String[] res = new String[] {
				builder.toString()
		};
		return res;
	}

}
package studio.blacktech.coolqbot.furryblack.modules.Executor;

import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;

import org.meowy.cqp.jcq.entity.Member;

import studio.blacktech.coolqbot.furryblack.entry;
import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.message.Message;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleExecutor;

public class Executor_roulette extends ModuleExecutor {

	private static final long serialVersionUID = 1L;

	// ==========================================================================================================================================================
	//
	// 模块基本配置
	//
	// ==========================================================================================================================================================

	private static String MODULE_PACKAGENAME = "Executor_Roulette";
	private static String MODULE_COMMANDNAME = "roulette";
	private static String MODULE_DISPLAYNAME = "俄罗斯轮盘赌";
	private static String MODULE_DESCRIPTION = "你看这子弹又尖又长，这名单又大又宽";
	private static String MODULE_VERSION = "1.0";
	private static String[] MODULE_USAGE = new String[] {
			"/roulette 筹码 - 加入或者发起一局俄罗斯轮盘赌，十分钟仍未满员则自动解散对局"
	};
	private static String[] MODULE_PRIVACY_STORED = new String[] {};
	private static String[] MODULE_PRIVACY_CACHED = new String[] {
			"按照\"群-成员-回合\"的层级关系存储 - 回合结束或超时后下一次第一名玩家加入时释放"
	};
	private static String[] MODULE_PRIVACY_OBTAIN = new String[] {
			"获取命令发送人"
	};

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	private HashMap<Long, RouletteRound> ROULETTE_ROUNDS;
	private ArrayList<Integer> ROULETTE_FREQ;
	private int ROUND_EXPIRED = 0;
	private int ROUND_SUCCESS = 0;

	// ==========================================================================================================================================================
	//
	// 生命周期函数
	//
	// ==========================================================================================================================================================

	public Executor_roulette() throws Exception {

		// @formatter:off

		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);

		// @formatter:on

	}

	@Override
	public LoggerX init(LoggerX logger) throws Exception {

		this.ROULETTE_ROUNDS = new HashMap<>();
		this.ROULETTE_FREQ = new ArrayList<>();

		this.ROULETTE_FREQ.add(0);
		this.ROULETTE_FREQ.add(0);
		this.ROULETTE_FREQ.add(0);
		this.ROULETTE_FREQ.add(0);
		this.ROULETTE_FREQ.add(0);
		this.ROULETTE_FREQ.add(0);

		this.ENABLE_USER = false;
		this.ENABLE_DISZ = false;
		this.ENABLE_GROP = true;

		return logger;
	}

	@Override
	public LoggerX boot(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX save(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX shut(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX exec(LoggerX logger, Message message) throws Exception {
		return logger;
	}

	@Override
	public void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {
		return true;
	}

	@Override
	public boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {
		return true;
	}

	@Override
	public boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {

		// 只有命令 没下注
		if (message.getSection() == 0) {
			entry.gropInfo(gropid, userid, "不下注是8koi的");
			return true;
		}

		// 对局不存在 创建一个
		if (!this.ROULETTE_ROUNDS.containsKey(gropid)) { this.ROULETTE_ROUNDS.put(gropid, new RouletteRound()); }

		// 获取本群对局
		RouletteRound round = this.ROULETTE_ROUNDS.get(gropid);

		if (round.lock) {
			// 本来是有锁的，但是我觉得没人能正好在100ms内再加入所以删了
			// SX found this BUG
			// Module.gropInfo(gropid, "你是最佳第七人，你妈妈不爱你，你甚至不配拥有名字。");
			return false;
		}

		// 对局超时就新建一个
		if ((round.time.getTime() + 600000) < new Date().getTime()) {
			this.ROUND_EXPIRED++;
			round = new RouletteRound();
			this.ROULETTE_ROUNDS.remove(gropid);
			this.ROULETTE_ROUNDS.put(gropid, round);
		}

		if (round.join(gropid, userid, message)) {

			entry.gropInfo(gropid, "名单已凑齐 装填子弹中");
			int bullet = new SecureRandom().nextInt(6);
			Member member;
			for (int i = 0; i < 6; i++) {
				member = entry.getCQ().getGroupMemberInfo(gropid, round.player.get(i));
				if (i == bullet) {
					this.ROULETTE_FREQ.set(i, this.ROULETTE_FREQ.get(i) + 1);
					entry.gropInfo(gropid, entry.getGropnick(gropid, member.getQQId()) + " (" + round.player.get(i) + "): [CQ:face,id=169][CQ:emoji,id=10060]");
				} else {
					entry.gropInfo(gropid, entry.getGropnick(gropid, member.getQQId()) + " (" + round.player.get(i) + "): [CQ:face,id=169][CQ:emoji,id=11093]");
				}

			}
			entry.gropInfo(gropid, "@平安中国 目标已击毙:  [CQ:at,qq=" + round.player.get(bullet) + "]\r\n" + round.chip.get(bullet));
			this.ROULETTE_ROUNDS.remove(gropid);
			this.ROUND_SUCCESS++;
		}

		return true;
	}

	private class RouletteRound {

		public Date time;

		ArrayList<String> chip = new ArrayList<>();
		ArrayList<Long> player = new ArrayList<>();

		int players = 0;
		boolean lock = false;

		RouletteRound() {
			this.time = new Date();
		}

		public boolean join(long gropid, long userid, Message message) {
			if (this.player.contains(userid)) {
				entry.gropInfo(gropid, "你8koi离开，不准放过");
			} else {
				this.time = new Date();
				this.players++;
				this.player.add(userid);
				this.chip.add(message.getOptions());
				StringBuilder buffer = new StringBuilder();
				buffer.append("俄罗斯轮盘 - 当前人数 (");
				buffer.append(this.players);
				buffer.append("/6)");
				int i = 0;
				for (; i < this.players; i++) {
					buffer.append("\r\n");
					buffer.append(i + 1);
					buffer.append(" - ");
					buffer.append(this.player.get(i));
					buffer.append(" : ");
					buffer.append(this.chip.get(i));
				}
				for (; i < 6; i++) {
					buffer.append("\r\n");
					buffer.append(i + 1);
					buffer.append(" - 等待加入");
				}
				entry.gropInfo(gropid, buffer.toString());
			}
			this.lock = this.players > 5;
			return this.lock;
		}
	}

	@Override
	public String[] generateReport(int mode, Message message, Object... parameters) {
		if ((this.COUNT_USER + this.COUNT_DISZ + this.COUNT_GROP) == 0) { return null; }
		StringBuilder builder = new StringBuilder();
		builder.append("成功回合 : ");
		builder.append(this.ROUND_SUCCESS);
		builder.append("\r\n失败回合 : ");
		builder.append(this.ROUND_EXPIRED);
		if (this.ROUND_SUCCESS > 0) {
			builder.append("\r\n第一发 : ");
			builder.append(this.ROULETTE_FREQ.get(0));
			builder.append(" - ");
			builder.append((this.ROULETTE_FREQ.get(0) * 100) / this.ROUND_SUCCESS);
			builder.append("%\r\n第二发 : ");
			builder.append(this.ROULETTE_FREQ.get(1));
			builder.append(" - ");
			builder.append((this.ROULETTE_FREQ.get(1) * 100) / this.ROUND_SUCCESS);
			builder.append("%\r\n第三发 : ");
			builder.append(this.ROULETTE_FREQ.get(2));
			builder.append(" - ");
			builder.append((this.ROULETTE_FREQ.get(2) * 100) / this.ROUND_SUCCESS);
			builder.append("%\r\n第四发 : ");
			builder.append(this.ROULETTE_FREQ.get(3));
			builder.append(" - ");
			builder.append((this.ROULETTE_FREQ.get(3) * 100) / this.ROUND_SUCCESS);
			builder.append("%\r\n第五发 : ");
			builder.append(this.ROULETTE_FREQ.get(4));
			builder.append(" - ");
			builder.append((this.ROULETTE_FREQ.get(4) * 100) / this.ROUND_SUCCESS);
			builder.append("%\r\n第六发 : ");
			builder.append(this.ROULETTE_FREQ.get(5));
			builder.append(" - ");
			builder.append((this.ROULETTE_FREQ.get(5) * 100) / this.ROUND_SUCCESS);
			builder.append("%");
		}
		String[] res = new String[] {
				builder.toString()
		};
		return res;
	}
}
package studio.blacktech.coolqbot.furryblack.modules.Executor;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.TimeZone;

import org.junit.jupiter.api.Test;

import studio.blacktech.coolqbot.furryblack.entry;
import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.message.Message;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleExecutor;

public class Executor_time extends ModuleExecutor {

	private static final long serialVersionUID = 1L;

	// ==========================================================================================================================================================
	//
	// 模块基本配置
	//
	// ==========================================================================================================================================================

	private static String MODULE_PACKAGENAME = "Executor_Time";
	private static String MODULE_COMMANDNAME = "time";
	private static String MODULE_DISPLAYNAME = "环球时间";
	private static String MODULE_DESCRIPTION = "那谁睡觉了吗";
	private static String MODULE_VERSION = "1.0";
	private static String[] MODULE_USAGE = new String[] {
			"/time 看看谁该睡觉了"
	};

	public static String[] MODULE_PRIVACY_STORED = new String[] {};
	public static String[] MODULE_PRIVACY_CACHED = new String[] {};
	public static String[] MODULE_PRIVACY_OBTAIN = new String[] {};

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	private static final TimeZone zone_W8 = TimeZone.getTimeZone("America/Los_Angeles");
	private static final TimeZone zone_W4 = TimeZone.getTimeZone("America/New_York");
	private static final TimeZone zone_00 = TimeZone.getTimeZone("UTC");
	private static final TimeZone zone_E0 = TimeZone.getTimeZone("Europe/London");
	// private static final TimeZone zone_E1 =
	// TimeZone.getTimeZone("Europe/Stockholm");
	private static final TimeZone zone_E8 = TimeZone.getTimeZone("Asia/Shanghai");

	// ==========================================================================================================================================================
	//
	// 生命周期函数
	//
	// ==========================================================================================================================================================

	public Executor_time() throws Exception {

		// @formatter:off

		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);

		// @formatter:on

	}

	@Override
	public LoggerX init(LoggerX logger) throws Exception {

		this.ENABLE_USER = true;
		this.ENABLE_DISZ = true;
		this.ENABLE_GROP = true;

		return logger;
	}

	@Override
	public LoggerX boot(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX save(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX shut(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX exec(LoggerX logger, Message message) throws Exception {
		return logger;
	}

	@Override
	public void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {
		entry.userInfo(userid, this.getTime());
		return true;
	}

	@Override
	public boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {
		entry.diszInfo(diszid, this.getTime());
		return true;
	}

	@Override
	public boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {
		entry.gropInfo(gropid, this.getTime());
		return true;
	}

	private String getTime() {
		return
		// @formatter:off
				//
				"世界协调时(UTC) " + LoggerX.formatTime("yyyy-MM-dd HH:mm", Executor_time.zone_00) + "\r\n" +
				"美国西部(UTC-8) " + LoggerX.formatTime("HH:mm", Executor_time.zone_W8) + this.format(Executor_time.zone_W8) + "\r\n" +
				"美国东部(UTC-4) " + LoggerX.formatTime("HH:mm", Executor_time.zone_W4) + this.format(Executor_time.zone_W4) + "\r\n" +
				"欧洲英国(UTC+0) " + LoggerX.formatTime("HH:mm", Executor_time.zone_E0) + this.format(Executor_time.zone_E0) + "\r\n" +
				//        "欧洲瑞典(UTC+1) " + LoggerX.formatTime("HH:mm", zone_E1) + this.format(zone_E1) + "\r\n" +
				"亚洲中国(UTC+8) " + LoggerX.formatTime("HH:mm", Executor_time.zone_E8)
				// @formatter:on
		;
	}

	@SuppressWarnings("deprecation")
	private String format(TimeZone timezone) {
		// @formatter:off
		boolean isEnableDST = false;
		boolean isDisableDST = false;
		StringBuilder builder = new StringBuilder();
		Calendar today = Calendar.getInstance(timezone);
		long current = today.getTimeInMillis();
		Date begin = new Date(current);
		begin.setMonth(1);
		begin.setDate(1);
		begin.setHours(0);
		begin.setMinutes(0);
		begin.setSeconds(0);
		Calendar temp = Calendar.getInstance(timezone);
		temp.setTime(new Date((begin.getTime() / 1000) * 1000));
		for (long i = temp.getTimeInMillis(); i < current; i = temp.getTimeInMillis()) {
			temp.add(Calendar.DATE, 1);
			long t = temp.getTimeInMillis();
			if ((t - i) < 86400000) {
				isEnableDST = true;
			} else if ((t - i) > 86400000) {
				isDisableDST = true;
			}
		}
		if (isEnableDST ^ isDisableDST) { builder.append(" 夏令时"); }
		int TZ_DATE = Integer.parseInt(LoggerX.formatTime("dd", timezone));
		int E8_DATE = Integer.parseInt(LoggerX.formatTime("dd", Executor_time.zone_E8));
		if ((E8_DATE - TZ_DATE) > 0) {
			builder.append(" 昨天," + TZ_DATE + "日");
		} else if ((E8_DATE - TZ_DATE) < 0) {
			builder.append(" 明天," + TZ_DATE + "日");
		}
		// @formatter:on
		return builder.toString();
	}

	// ==========================================================================================================================================================
	//
	// 工具函数
	//
	// ==========================================================================================================================================================

	@Override
	public String[] generateReport(int mode, Message message, Object... parameters) {
		return new String[0];
	}

	@Test
	void findAllDSTDate() {
		TimeZone timezone = Executor_time.zone_E0;
		SimpleDateFormat fmt = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		Calendar start = Calendar.getInstance(timezone);
		start.setTime(new Date(0));
		long end = Calendar.getInstance(timezone).getTimeInMillis();
		System.out.println("Time Zone is " + timezone.getDisplayName() + " " + timezone.getID());
		for (long i = start.getTimeInMillis(); i < end; i = start.getTimeInMillis()) {
			start.add(Calendar.DATE, 1);
			if (((start.getTimeInMillis() - i) % (24 * 3600 * 1000L)) != 0) { System.out.println("from " + fmt.format(new Date(i)) + " to " + fmt.format(start.getTime()) + " has " + (start.getTimeInMillis() - i) + "ms" + "[" + ((start.getTimeInMillis() - i) / (3600 * 1000L)) + "hours]"); }
		}
	}
}
package studio.blacktech.coolqbot.furryblack.modules.Executor;

import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.TreeMap;

import studio.blacktech.coolqbot.furryblack.entry;
import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.message.Message;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleExecutor;

public class Executor_zhan extends ModuleExecutor {

	private static final long serialVersionUID = 1L;

	// ==========================================================================================================================================================
	//
	// 模块基本配置
	//
	// ==========================================================================================================================================================

	private static String MODULE_PACKAGENAME = "Executor_Zhan";
	private static String MODULE_COMMANDNAME = "zhan";
	private static String MODULE_DISPLAYNAME = "占卜";
	private static String MODULE_DESCRIPTION = "大阿卡那塔罗牌占卜";
	private static String MODULE_VERSION = "1.0";
	private static String[] MODULE_USAGE = new String[] {
			"/zhan 理由 - 为某事占卜"
	};

	private static String[] MODULE_PRIVACY_STORED = new String[] {};
	private static String[] MODULE_PRIVACY_CACHED = new String[] {};
	private static String[] MODULE_PRIVACY_OBTAIN = new String[] {
			"获取命令发送人"
	};

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	private TreeMap<Integer, String> CARD;
	private ArrayList<Integer> FREQ;

	// ==========================================================================================================================================================
	//
	// 生命周期函数
	//
	// ==========================================================================================================================================================

	public Executor_zhan() throws Exception {

		// @formatter:off

		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);

		// @formatter:on

	}

	@Override
	public LoggerX init(LoggerX logger) throws Exception {

		this.CARD = new TreeMap<>();
		this.FREQ = new ArrayList<>();

		// =======================================
		//
		// 为什么不读配置文件？
		// 我有理由相信，塔罗牌会保持44张不会变
		//
		// =======================================

		this.CARD.put(1, "O. THE FOOL 愚者正位\r\n愚蠢 狂躁 挥霍无度 神志不清");
		this.CARD.put(2, "O. THE FOOL 愚者逆位\r\n疏忽 缺乏 暮气 无效 虚荣");
		this.CARD.put(3, "I. THE MAGICIAN 魔术师正位\r\n手段 灾难 痛苦 损失");
		this.CARD.put(4, "I. THE MAGICIAN 魔术师逆位\r\n羞辱 忧虑 精神疾病");
		this.CARD.put(5, "II. THE HIGH PRIESTESS 女祭司正位\r\n秘密 神秘 未来不明朗 英明");
		this.CARD.put(6, "II. THE HIGH PRIESTESS 女祭司逆位\r\n冲动 狂热 自负 浮于表面");
		this.CARD.put(7, "III. THE EMPRESS 皇后正位\r\n丰收 倡议 隐秘 困难 无知");
		this.CARD.put(8, "III. THE EMPRESS 皇后逆位\r\n光明 真相 喜悦");
		this.CARD.put(9, "IV. THE EMPEROR 皇帝正位\r\n稳定 力量 帮助 保护 信念");
		this.CARD.put(10, "IV. THE EMPEROR 皇帝逆位\r\n仁慈 同情 赞许 阻碍 不成熟");
		this.CARD.put(11, "V. THE HIEROPHANT 教皇正位\r\n宽恕 束缚 奴役 灵感");
		this.CARD.put(12, "V. THE HIEROPHANT 教皇逆位\r\n善解人意 和睦 过度善良 软弱");
		this.CARD.put(13, "VI. THE LOVERS 恋人正位\r\n吸引 爱 美丽 通过试炼");
		this.CARD.put(14, "VI. THE LOVERS 恋人逆位\r\n失败 愚蠢的设计");
		this.CARD.put(15, "VII. THE CHARIOT 战车正位\r\n救助 天意 胜利 复仇");
		this.CARD.put(16, "VII. THE CHARIOT 战车逆位\r\n打败 狂暴 吵架 诉讼");
		this.CARD.put(17, "VIII. THE STRENGTH 力量正位\r\n能量 行动 勇气 海量");
		this.CARD.put(18, "VIII. THE STRENGTH 力量逆位\r\n专断 弱点 滥用力量 不和");
		this.CARD.put(19, "IX. THE HERMIT 隐者正位\r\n慎重 叛徒 掩饰 堕落 恶事");
		this.CARD.put(20, "IX. THE HERMIT 隐者逆位\r\n隐蔽 害怕 伪装 过分小心");
		this.CARD.put(21, "X. THE WHEEL OF FORTUNE 命运之轮正位\r\n命运 好运 成功 幸福");
		this.CARD.put(22, "X. THE WHEEL OF FORTUNE 命运之轮逆位\r\n增加 丰富 多余");
		this.CARD.put(23, "XI. THE JUSTICE 正义正位\r\n公平 正义 廉洁 行政");
		this.CARD.put(24, "XI. THE JUSTICE 正义逆位\r\n偏执 不公 过度俭朴");
		this.CARD.put(25, "XII. THE HANGED MAN 吊人正位\r\n智慧 牺牲 审判 细心 眼光");
		this.CARD.put(26, "XII. THE HANGED MAN 吊人逆位\r\n自私 群众 人民");
		this.CARD.put(27, "XIII. DEATH 死亡正位\r\n终结 死亡 毁灭 腐朽");
		this.CARD.put(28, "XIII. DEATH 死亡逆位\r\n惯性 石化 梦游 昏 睡");
		this.CARD.put(29, "XIV. TEMPERANCE 节制正位\r\n经济 适度 节俭 管理 住所");
		this.CARD.put(30, "XIV. TEMPERANCE 节制逆位\r\n教会 分离 不幸的组合 冲突的利益");
		this.CARD.put(31, "XV. THE DEVIL 恶魔正位\r\n毁坏 暴力 强迫 愤怒 额外努力 死亡");
		this.CARD.put(32, "XV. THE DEVIL 恶魔逆位\r\n死亡 弱点 盲目 琐事");
		this.CARD.put(33, "XVI. THE TOWER 高塔正位\r\n苦难 废墟 贫乏 耻辱 灾害 逆境 骗局");
		this.CARD.put(34, "XVI. THE TOWER 高塔逆位\r\n专断 监禁 受苦 损害");
		this.CARD.put(35, "XVII. THE STAR 星星正位\r\n丢失 窃贼 匮乏 放弃 未来的希望");
		this.CARD.put(36, "XVII. THE STAR 星星逆位\r\n傲慢 无能 傲气");
		this.CARD.put(37, "XVIII. THE MOON 月亮正位\r\n隐藏的敌人 诽谤 危险 黑暗 恐怖 错误");
		this.CARD.put(38, "XVIII. THE MOON 月亮逆位\r\n不稳定 易变 骗局 错误");
		this.CARD.put(39, "XIX. THE SUN 太阳正位\r\n喜悦 结婚 满意");
		this.CARD.put(40, "XIX. THE SUN 太阳逆位\r\n开心 满意");
		this.CARD.put(41, "XX. THE LAST JUDGMENT 审判正位\r\n变位 复兴 结果");
		this.CARD.put(42, "XX. THE LAST JUDGMENT 审判逆位\r\n弱点 胆怯 天真 决定 熟虑");
		this.CARD.put(43, "XXI. THE WORLD 世界正位\r\n成功 道路 航程 换位");
		this.CARD.put(44, "XXI. THE WORLD 世界逆位\r\n惯性 固执 停滞 持久");

		// @formatter:off
		this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);
		this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);
		this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);
		this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);
		this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);
		this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);
		this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);
		this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);
		this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);        this.FREQ.add(0);        // @formatter:on

		this.ENABLE_USER = true;
		this.ENABLE_DISZ = true;
		this.ENABLE_GROP = true;
		return logger;
	}

	@Override
	public LoggerX boot(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX save(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX shut(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX exec(LoggerX logger, Message message) throws Exception {
		return logger;
	}

	@Override
	public void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {
		if (message.getSection() == 0) {
			entry.userInfo(userid, "你不能占卜空气");
		} else {
			SecureRandom random = new SecureRandom();
			int urandom = random.nextInt(43) + 1;
			StringBuilder builder = new StringBuilder();
			builder.append("你因为 ");
			builder.append(message.getOptions());
			builder.append(" 抽到了：\r\n");
			builder.append(this.CARD.get(urandom));
			this.FREQ.set(urandom, this.FREQ.get(urandom) + 1);
			entry.userInfo(userid, builder.toString());
		}
		return true;
	}

	@Override
	public boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {
		if (message.getSection() == 0) {
			entry.diszInfo(diszid, userid, "你不能占卜空气");
		} else {
			SecureRandom random = new SecureRandom();
			int urandom = random.nextInt(43) + 1;
			StringBuilder builder = new StringBuilder();
			builder.append("你因为 ");
			builder.append(message.getOptions());
			builder.append(" 抽到了：\r\n");
			builder.append(this.CARD.get(urandom));
			this.FREQ.set(urandom, this.FREQ.get(urandom) + 1);
			entry.diszInfo(diszid, userid, builder.toString());
		}
		return true;
	}

	@Override
	public boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {
		if (message.getSection() == 0) {
			entry.gropInfo(gropid, userid, "你不能占卜空气");
		} else {
			SecureRandom random = new SecureRandom();
			int urandom = random.nextInt(43) + 1;
			StringBuilder builder = new StringBuilder();
			builder.append("你因为 ");
			builder.append(message.getOptions());
			builder.append(" 抽到了：\r\n");
			builder.append(this.CARD.get(urandom));
			this.FREQ.set(urandom, this.FREQ.get(urandom) + 1);
			entry.gropInfo(gropid, userid, builder.toString());
		}
		return true;
	}

	@Override
	public String[] generateReport(int mode, Message message, Object... parameters) {
		if ((this.COUNT_USER + this.COUNT_DISZ + this.COUNT_GROP) == 0) { return null; }
		StringBuilder builder = new StringBuilder();
		int coverage = 0;
		for (int i = 0; i < 44; i++) {
			if (this.FREQ.get(i) == 0) { coverage++; }
		}
		coverage = 44 - coverage;
		for (int i = 0; i < 44; i++) {
			if (this.FREQ.get(i) == 0) { continue; }
			builder.append("\r\n第 ");
			builder.append(i + 1);
			builder.append(" 张 : ");
			builder.append(this.FREQ.get(i));
			builder.append(" - ");
			builder.append((this.FREQ.get(i) * 100) / coverage);
			builder.append("%");
		}
		String[] res = new String[] {
				builder.toString()
		};
		return res;
	}

}
package studio.blacktech.coolqbot.furryblack.modules.Listener;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.TreeMap;

import org.meowy.cqp.jcq.entity.Group;
import org.meowy.cqp.jcq.entity.Member;
import org.meowy.cqp.jcq.message.CQCode;

import studio.blacktech.coolqbot.furryblack.entry;
import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.message.Message;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleListener;

public class Listener_TopSpeak extends ModuleListener {

	private static final long serialVersionUID = 1L;

	// ==========================================================================================================================================================
	//
	// 模块基本配置
	//
	// ==========================================================================================================================================================

	private static String MODULE_PACKAGENAME = "Listener_TopSpeak";
	private static String MODULE_COMMANDNAME = "shui";
	private static String MODULE_DISPLAYNAME = "水群统计";
	private static String MODULE_DESCRIPTION = "水群统计";
	private static String MODULE_VERSION = "29.1";
	private static String[] MODULE_USAGE = new String[] {};
	private static String[] MODULE_PRIVACY_STORED = new String[] {
			"按照\"群-成员-消息\"的层级关系保存所有聊天内容"
	};
	private static String[] MODULE_PRIVACY_CACHED = new String[] {};
	private static String[] MODULE_PRIVACY_OBTAIN = new String[] {};

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	private ArrayList<Long> GROUP_REPORT;
	private HashMap<Long, GroupStatus> GROUP_STATUS;

	private Thread thread;

	private File CONFIG_ENABLE_REPORT;

	private File GROUP_STATUS_STORAGE;

	// ==========================================================================================================================================================
	//
	// 生命周期函数
	//
	// ==========================================================================================================================================================

	public Listener_TopSpeak() throws Exception {

		// @formatter:off

		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);

		// @formatter:on

	}

	@SuppressWarnings("unchecked")
	@Override
	public LoggerX init(LoggerX logger) throws Exception {

		this.initAppFolder(logger);
		this.initConfFolder(logger);
		this.initDataFolder(logger);

		this.GROUP_REPORT = new ArrayList<>();

		this.CONFIG_ENABLE_REPORT = Paths.get(this.FOLDER_CONF.getAbsolutePath(), "daily_report.txt").toFile();
		this.GROUP_STATUS_STORAGE = Paths.get(this.FOLDER_DATA.getAbsolutePath(), "topspeaks.serial").toFile();

		String line;

		if (this.CONFIG_ENABLE_REPORT.exists()) {

			BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(this.CONFIG_ENABLE_REPORT), StandardCharsets.UTF_8));

			while ((line = reader.readLine()) != null) {

				if (line.startsWith("#")) { continue; }
				if (line.contains("#")) { line = line.substring(0, line.indexOf("#")).trim(); }

				this.GROUP_REPORT.add(Long.parseLong(line));
			}

			logger.seek(MODULE_PACKAGENAME, "每日汇报启用");

			for (Long temp : this.GROUP_REPORT) {
				logger.seek(MODULE_PACKAGENAME, "  " + temp);
			}

			reader.close();

		} else {

			this.CONFIG_ENABLE_REPORT.createNewFile();
		}

		if (this.GROUP_STATUS_STORAGE.exists()) {

			ObjectInputStream loader = new ObjectInputStream(new FileInputStream(this.GROUP_STATUS_STORAGE));
			this.GROUP_STATUS = (HashMap<Long, GroupStatus>) loader.readObject();
			loader.close();

			logger.seek(MODULE_PACKAGENAME, "读取存档", this.GROUP_STATUS.size() == 0 ? "空" : "包含" + this.GROUP_STATUS.size() + "个群");

			for (long gropid : this.GROUP_STATUS.keySet()) {

				long time = this.GROUP_STATUS.get(gropid).initdt;
				logger.seek(MODULE_PACKAGENAME, "群 " + gropid, LoggerX.datetime(new Date(time)) + "(" + time + ")");

			}

			File GROUP_STATUS_LEGACY = Paths.get(this.FOLDER_DATA.getAbsolutePath(), LoggerX.formatTime("yyyy_MM_dd_HH_mm_ss") + ".old").toFile();
			this.GROUP_STATUS_STORAGE.renameTo(GROUP_STATUS_LEGACY);
			this.GROUP_STATUS_STORAGE.delete();

		} else {

			this.GROUP_STATUS = new HashMap<>();

		}

		List<Group> groups = entry.getCQ().getGroupList();

		logger.seek(MODULE_PACKAGENAME, "存档一致性检查");

		for (Group group : groups) {

			if (this.GROUP_STATUS.containsKey(group.getId())) {

				GroupStatus groupStatus = this.GROUP_STATUS.get(group.getId());
				List<Member> members = entry.getCQ().getGroupMemberList(group.getId());

				for (Member member : members) {

					if (!groupStatus.USER_STATUS.containsKey(member.getQQId())) {

						groupStatus.USER_STATUS.put(member.getQQId(), new UserStatus(member.getQQId()));

						logger.seek(MODULE_PACKAGENAME, "新建成员" + group.getId() + " > " + entry.getNickname(member.getQQId()) + "(" + member.getQQId() + ")");

					}
				}

			} else {

				this.GROUP_STATUS.put(group.getId(), new GroupStatus(group.getId()));

				logger.seek(MODULE_PACKAGENAME, "新建群" + group.getName() + "(" + group.getId() + ")");

			}

		}

		this.ENABLE_USER = false;
		this.ENABLE_DISZ = false;
		this.ENABLE_GROP = true;

		return logger;
	}

	@Override
	public LoggerX boot(LoggerX logger) throws Exception {

		logger.info(Listener_TopSpeak.MODULE_PACKAGENAME, "启动工作线程");

		this.thread = new Thread(new Worker());
		this.thread.start();

		return logger;
	}

	@Override
	public LoggerX save(LoggerX logger) throws Exception {

		logger.info(Listener_TopSpeak.MODULE_PACKAGENAME, "数据序列化");

		this.saveData(this.GROUP_STATUS_STORAGE);

		return logger;
	}

	@Override
	public LoggerX shut(LoggerX logger) throws Exception {

		logger.info(Listener_TopSpeak.MODULE_PACKAGENAME, "终止工作线程");

		this.thread.interrupt();
		this.thread.join();

		return logger;
	}

	@Override
	public LoggerX exec(LoggerX logger, Message message) throws Exception {

		if (message.getSection() < 1) {
			logger.info(MODULE_PACKAGENAME, "参数不足");
			return logger;
		}

		String command = message.getSegment()[1];

		switch (command) {

		case "save":

			File DAILY_BACKUP = Paths.get(this.FOLDER_DATA.getAbsolutePath(), LoggerX.formatTime("yyyy_MM_dd_HH_mm_ss") + ".bak").toFile();

			this.saveData(DAILY_BACKUP);

			logger.info(MODULE_PACKAGENAME, "保存存档", DAILY_BACKUP.getAbsolutePath());

			break;

		}

		return logger;
	}

	@Override
	public void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) {

		if (entry.isMyself(userid)) {

			this.GROUP_STATUS.put(gropid, new GroupStatus(gropid));

		} else {

			this.GROUP_STATUS.get(gropid).USER_STATUS.put(userid, new UserStatus(userid));

		}
	}

	@Override
	public void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) {

		if (entry.isMyself(userid)) {

			this.GROUP_STATUS.remove(gropid);

		} else {

			this.GROUP_STATUS.get(gropid).USER_STATUS.remove(userid);

		}
	}

	// ==========================================================================================================================================================
	//
	//
	//
	// ==========================================================================================================================================================
	@Override
	public boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {
		return false;
	}

	@Override
	public boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {
		return false;
	}

	@Override
	public boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {
		this.GROUP_STATUS.get(gropid).say(userid, message);
		return true;
	}

	// ==========================================================================================================================================================
	//
	//
	//
	// ==========================================================================================================================================================

	@Override
	public String[] generateReport(int mode, Message message, Object... parameters) {

		String report[] = null;

		switch (mode) {

		case 10:

			if (message.hasSwitch("gropid")) {

				long gropid = Long.parseLong(message.getSwitch("gropid"));

				int limitRank = 10;
				int limitRepeat = 10;
				int limitPicture = 3;

				if (message.hasSwitch("limit")) {

					String[] limits = message.getSwitch("limit").split(",");

					switch (limits.length) {

					case 3:
						limitPicture = Integer.parseInt(limits[2]);
					case 2:
						limitRepeat = Integer.parseInt(limits[1]);
					case 1:
						limitRank = Integer.parseInt(limits[0]);

					}

				}

				report = this.generateMemberRank(gropid, limitRank, limitRepeat, limitPicture);

			} else {

				report = new String[] {
						"参数错误 --gropid 为空"
				};

			}
			break;
		}

		return report;
	}

	// ==========================================================================================================================

	public String[] generateMemberRank(long gropid, int limitRank, int limitRepeat, int limitPicture) {

		StringBuilder builder;
		LinkedList<String> report = new LinkedList<>();
		GroupStatus groupStatus = this.GROUP_STATUS.get(gropid).sum();

		// ===========================================================

		builder = new StringBuilder();

		// ===========================================================

		builder.append("（1/4）水群统计 " + limitRank + "/" + limitRepeat + "/" + limitPicture + "\r\n");
		builder.append("自" + LoggerX.formatTime("yyyy-MM-dd HH", new Date(groupStatus.initdt)) + ":00 以来" + "\r\n");
		builder.append("总消息数：" + groupStatus.GROP_MESSAGES + "\r\n");
		builder.append("发言条数：" + (groupStatus.GROP_SENTENCE.size() + groupStatus.GROP_PURECCODE) + "\r\n");
		builder.append("发言字数：" + groupStatus.GROP_CHARACTER + "\r\n");
		builder.append("命令次数：" + groupStatus.GROP_COMMANDS.size() + "\r\n");
		builder.append("发言图数：" + groupStatus.GROP_PICTURES.size() + "\r\n");
		builder.append("闪照图数：" + groupStatus.GROP_SNAPSHOT + "\r\n");
		builder.append("视频个数：" + groupStatus.GROP_TAPVIDEO + "\r\n");
		builder.append("红包个数：" + groupStatus.GROP_HONGBAOS);

		report.add(builder.toString());

		// ===========================================================

		if (limitRank >= 0) {

			UserStatus userStatus;
			TreeMap<Integer, HashSet<Long>> allMemberRank = new TreeMap<>((a, b) -> b - a);

			for (long userid : groupStatus.USER_STATUS.keySet()) {

				userStatus = groupStatus.USER_STATUS.get(userid);

				int userCharacter = userStatus.USER_SENTENCE.size() + userStatus.USER_PURECCODE;

				if (userCharacter > 0) {

					if (allMemberRank.containsKey(userCharacter)) {
						allMemberRank.get(userCharacter).add(userid);
					} else {
						HashSet<Long> tempSet = new HashSet<>();
						tempSet.add(userid);
						allMemberRank.put(userCharacter, tempSet);
					}

				}
			}

			if (allMemberRank.size() > 0) {

				builder = new StringBuilder();
				builder.append("（2/4）成员排行：" + "\r\n");

				int i = 1;
				int limit = 0;
				int slice = 0;

				for (int userRank : allMemberRank.keySet()) {

					HashSet<Long> tempSet = allMemberRank.get(userRank);

					for (Long userid : tempSet) {

						userStatus = groupStatus.USER_STATUS.get(userid);

						builder.append("No." + i + " - " + entry.getGropnick(gropid, userid) + "(" + userid + ") " + (userStatus.USER_SENTENCE.size() + userStatus.USER_PURECCODE) + "句/" + userStatus.USER_CHARACTER + "字");

						if (userStatus.USER_PICTURES.size() > 0) { builder.append("/" + userStatus.USER_PICTURES.size() + "图"); }
						if (userStatus.USER_SNAPSHOT > 0) { builder.append("/" + userStatus.USER_SNAPSHOT + "闪"); }
						if (userStatus.USER_TAPVIDEO > 0) { builder.append("/" + userStatus.USER_TAPVIDEO + "片"); }
						if (userStatus.USER_HONGBAOS > 0) { builder.append("/" + userStatus.USER_HONGBAOS + "包"); }

						builder.append("\r\n");

						limit++;
						slice++;

						if (slice == 30) {
							report.add(builder.substring(0, builder.length() - 2).toString());
							builder = new StringBuilder();
							slice = 0;
						}

						if ((limitRank != 0) && (limit >= limitRank)) { break; }
					}

					if ((limitRank != 0) && (limit >= limitRank)) { break; }
					i = i + tempSet.size();
				}
				report.add(builder.substring(0, builder.length() - 2).toString());
			}
		}

		// ===========================================================

		if (limitRepeat >= 0) {

			HashMap<String, Integer> allMessageRankTemp = new HashMap<>();

			for (String messageContent : groupStatus.GROP_SENTENCE) {

				messageContent = messageContent.trim();

				if (messageContent.length() == 0) {
					continue;
				} else if (messageContent.matches("\\s+")) {
					continue;
				} else if (messageContent.equals("¿")) {
					messageContent = "？";
				} else if (messageContent.equals("?")) {
					messageContent = "？";
				} else if (messageContent.equals("??")) {
					messageContent = "？？";
				} else if (messageContent.equals("???")) {
					messageContent = "？？？";
				} else if (messageContent.equals("????")) {
					messageContent = "？？？？";
				} else if (messageContent.equals("wky")) {
					messageContent = "我可以";
				} else if (messageContent.equals("whl")) {
					messageContent = "我好了";
				} else if (messageContent.equals("hso")) {
					messageContent = "好骚哦";
				} else if (messageContent.equals("tql")) {
					messageContent = "太强了";
				} else if (messageContent.equals("tfl")) {
					messageContent = "太富了";
				} else if (messageContent.equals("tcl")) {
					messageContent = "太草了";
				} else if (messageContent.equals("ghs")) {
					messageContent = "搞黄色";
				} else if (messageContent.equals("草")) {
					messageContent = "草";
				} else if (messageContent.equals("操")) {
					messageContent = "草";
				} else if (messageContent.equals("艹")) {
					messageContent = "草";
				} else if (messageContent.equals("好色哦")) {
					messageContent = "好骚哦";
				} else {
					// SAM IS RAGE
					// SAM IS RAGE
				}

				if (allMessageRankTemp.containsKey(messageContent)) {
					allMessageRankTemp.put(messageContent, allMessageRankTemp.get(messageContent) + 1);
				} else {
					allMessageRankTemp.put(messageContent, 1);
				}
			}

			TreeMap<Integer, HashSet<String>> allMessageRank = new TreeMap<>((a, b) -> b - a);

			for (String raw : allMessageRankTemp.keySet()) {

				int tempCount = allMessageRankTemp.get(raw);

				if (allMessageRank.containsKey(tempCount)) {
					allMessageRank.get(tempCount).add(raw);
				} else {
					HashSet<String> tempSet = new HashSet<>();
					tempSet.add(raw);
					allMessageRank.put(tempCount, tempSet);
				}

			}

			allMessageRank.remove(1);

			if (allMessageRank.size() > 0) {

				builder = new StringBuilder();
				builder.append("（3/4）整句排行：" + "\r\n");

				int order = 1;
				int limit = 0;
				int slice = 0;

				for (int messageRank : allMessageRank.keySet()) {

					HashSet<String> tempSet = allMessageRank.get(messageRank);

					for (String messageContent : tempSet) {
						builder.append("No." + order + " - " + messageRank + "次：" + messageContent + "\r\n");
						limit++;
						slice++;
						if (slice == 50) {
							report.add(builder.substring(0, builder.length() - 2).toString());
							builder = new StringBuilder();
							slice = 0;
						}
						if ((limitRepeat != 0) && (limit >= limitRepeat)) { break; }
					}
					if ((limitRepeat != 0) && (limit >= limitRepeat)) { break; }
					order = order + tempSet.size();
				}
				report.add(builder.substring(0, builder.length() - 2).toString());
			}
		}

		// ===========================================================

		if (limitPicture >= 0) {

			HashMap<String, Integer> allPictureRankTemp = new HashMap<>();

			for (String messageContent : groupStatus.GROP_PICTURES) {
				if (allPictureRankTemp.containsKey(messageContent)) {
					allPictureRankTemp.put(messageContent, allPictureRankTemp.get(messageContent) + 1);
				} else {
					allPictureRankTemp.put(messageContent, 1);
				}
			}

			TreeMap<Integer, HashSet<String>> allPictureRank = new TreeMap<>((a, b) -> b - a);

			for (String raw : allPictureRankTemp.keySet()) {
				int tempCount = allPictureRankTemp.get(raw);
				if (allPictureRank.containsKey(tempCount)) {
					allPictureRank.get(tempCount).add(raw);
				} else {
					HashSet<String> tempSet = new HashSet<>();
					tempSet.add(raw);
					allPictureRank.put(tempCount, tempSet);
				}
			}

			allPictureRank.remove(1);

			if (allPictureRank.size() > 0) {
				int order = 1;
				int limit = 0;
				for (int pictureRank : allPictureRank.keySet()) {
					HashSet<String> tempSet = allPictureRank.get(pictureRank);
					for (String picture : tempSet) {
						limit++;
						String image = CQCode.getInstance().getCQImage(picture).getUrl();
						report.add("No." + order + " - " + pictureRank + "次：" + image.substring(0, image.indexOf("?")));
						if ((limitPicture != 0) && (limit >= limitPicture)) { break; }
					}
					order = order + tempSet.size();
					if ((limitPicture != 0) && (limit >= limitPicture)) { break; }
				}
			}
		}

		// ===========================================================

		return report.toArray(new String[report.size()]);
	}

	private void saveData(File file) {

		try {

			if (file.exists()) {

				file.delete();

			}

			FileOutputStream stream = new FileOutputStream(file);

			ObjectOutputStream saver = new ObjectOutputStream(stream);

			saver.writeObject(Listener_TopSpeak.this.GROUP_STATUS);
			saver.close();

			stream.flush();
			stream.close();

		} catch (Exception exception) {

		}
	}

	@SuppressWarnings("deprecation")
	class Worker implements Runnable {

		@Override
		public void run() {

			long time;
			Date date;

			do {

				try {

					while (true) {

						date = new Date();
						time = 86400L;
						time = time - date.getSeconds();
						time = time - (date.getMinutes() * 60);
						time = time - (date.getHours() * 3600);
						time = time * 1000;
						Thread.sleep(time);

						File DAILY_BACKUP = Paths.get(Listener_TopSpeak.this.FOLDER_DATA.getAbsolutePath(), LoggerX.formatTime("yyyy_MM_dd_HH_mm_ss") + ".bak").toFile();

						Listener_TopSpeak.this.saveData(DAILY_BACKUP);

						for (long temp : Listener_TopSpeak.this.GROUP_REPORT) {
							entry.gropInfo(temp, Listener_TopSpeak.this.generateMemberRank(temp, 10, 10, 3));
						}

						entry.getCQ().logDebug(Listener_TopSpeak.MODULE_PACKAGENAME, "结果", "备份于" + DAILY_BACKUP.getAbsolutePath());

					}
				} catch (Exception exception) {
					if (entry.isEnable()) {
						entry.getCQ().logWarning(Listener_TopSpeak.MODULE_PACKAGENAME, "异常");
					} else {
						entry.getCQ().logInfo(Listener_TopSpeak.MODULE_PACKAGENAME, "关闭");
					}
				}
			} while (entry.isEnable());
		}
	}
}

class GroupStatus implements Serializable {

	private static final long serialVersionUID = 1L;

	public long gropid = 0;
	public long initdt = 0;

	public HashMap<Long, UserStatus> USER_STATUS = new HashMap<>();

	public LinkedList<String> GROP_SENTENCE;
	public LinkedList<String> GROP_COMMANDS;
	public LinkedList<String> GROP_PICTURES;

	public int GROP_SNAPSHOT = 0;
	public int GROP_HONGBAOS = 0;
	public int GROP_TAPVIDEO = 0;
	public int GROP_MESSAGES = 0;
	public int GROP_CHARACTER = 0;
	public int GROP_PURECCODE = 0;

	public GroupStatus(long gropid) {
		this.initdt = System.currentTimeMillis();
		this.gropid = gropid;
		for (Member member : entry.getCQ().getGroupMemberList(gropid)) {
			this.USER_STATUS.put(member.getQQId(), new UserStatus(member.getQQId()));
		}
	}

	public void say(long userid, MessageGrop message) {
		this.USER_STATUS.get(userid).say(message);
	}

	public GroupStatus sum() {

		this.GROP_SENTENCE = new LinkedList<>();
		this.GROP_COMMANDS = new LinkedList<>();
		this.GROP_PICTURES = new LinkedList<>();

		this.GROP_SNAPSHOT = 0;
		this.GROP_HONGBAOS = 0;
		this.GROP_TAPVIDEO = 0;
		this.GROP_MESSAGES = 0;
		this.GROP_CHARACTER = 0;
		this.GROP_PURECCODE = 0;

		for (long userid : this.USER_STATUS.keySet()) {

			UserStatus userStauts = this.USER_STATUS.get(userid).sum();
			this.GROP_SENTENCE.addAll(userStauts.USER_SENTENCE);
			this.GROP_COMMANDS.addAll(userStauts.USER_COMMANDS);
			this.GROP_PICTURES.addAll(userStauts.USER_PICTURES);

			this.GROP_SNAPSHOT = this.GROP_SNAPSHOT + userStauts.USER_SNAPSHOT;
			this.GROP_HONGBAOS = this.GROP_HONGBAOS + userStauts.USER_HONGBAOS;
			this.GROP_TAPVIDEO = this.GROP_TAPVIDEO + userStauts.USER_TAPVIDEO;

			this.GROP_MESSAGES = this.GROP_MESSAGES + userStauts.MESSAGES.size();

			this.GROP_CHARACTER = this.GROP_CHARACTER + userStauts.USER_CHARACTER;
			this.GROP_PURECCODE = this.GROP_PURECCODE + userStauts.USER_PURECCODE;
		}

		return this;

	}
}

class UserStatus implements Serializable {

	private static final long serialVersionUID = 1L;

	public long userid = 0;

	public LinkedList<MessageGrop> MESSAGES = new LinkedList<>();

	public LinkedList<String> USER_COMMANDS;
	public LinkedList<String> USER_SENTENCE;
	public LinkedList<String> USER_PICTURES;

	public int USER_SNAPSHOT = 0;
	public int USER_HONGBAOS = 0;
	public int USER_TAPVIDEO = 0;
	public int USER_CHARACTER = 0;
	public int USER_PURECCODE = 0;

	public UserStatus(long userid) {
		this.userid = userid;
	}

	public void say(MessageGrop message) {
		this.MESSAGES.add(message);
	}

	public UserStatus sum() {

		this.USER_SENTENCE = new LinkedList<>();
		this.USER_COMMANDS = new LinkedList<>();
		this.USER_PICTURES = new LinkedList<>();

		this.USER_CHARACTER = 0;
		this.USER_PURECCODE = 0;
		this.USER_SNAPSHOT = 0;
		this.USER_TAPVIDEO = 0;
		this.USER_HONGBAOS = 0;

		for (MessageGrop temp : this.MESSAGES) {

			if (temp.isCommand()) {
				this.USER_COMMANDS.add(temp.getCommand());
			} else if (temp.isSnappic()) {
				this.USER_SNAPSHOT++;
			} else if (temp.isQQVideo()) {
				this.USER_TAPVIDEO++;
			} else if (temp.isHongbao()) {
				this.USER_HONGBAOS++;
			} else if (temp.hasPicture()) {
				for (String image : temp.getPicture()) {
					this.USER_PICTURES.add(image);
				}
			} else {
				if (temp.isPureCQC()) {
					this.USER_PURECCODE++;
					this.USER_CHARACTER++;
				} else {
					if (temp.getResLength() == 0) { continue; }
					this.USER_SENTENCE.add(temp.getResMessage());
					this.USER_CHARACTER = this.USER_CHARACTER + temp.getResLength();
				}
			}
		}
		return this;
	}
}package studio.blacktech.coolqbot.furryblack.modules.Scheduler;

import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.regex.Pattern;

import studio.blacktech.coolqbot.furryblack.entry;
import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.message.Message;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleScheduler;

public class Scheduler_Dynamic extends ModuleScheduler {

	private static final long serialVersionUID = 1L;

	// ==========================================================================================================================================================
	//
	// 模块基本配置
	//
	// ==========================================================================================================================================================

	private static String MODULE_PACKAGENAME = "Scheduler_Dynamic";
	private static String MODULE_COMMANDNAME = "dynamic";
	private static String MODULE_DISPLAYNAME = "动态域名";
	private static String MODULE_DESCRIPTION = "动态域名";
	private static String MODULE_VERSION = "4.0";
	private static String[] MODULE_USAGE = new String[] {};
	public static String[] MODULE_PRIVACY_STORED = new String[] {};
	public static String[] MODULE_PRIVACY_CACHED = new String[] {};
	public static String[] MODULE_PRIVACY_OBTAIN = new String[] {};

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	private String API_GETADDRESS;
	private String API_SETADDRESS;

	private String CLIENTUA;
	private String HOSTNAME;
	private String PASSWORD;

	private Thread thread;

	private int COUNT_GETIP = 0;
	private int COUNT_SETIP = 0;
	private int COUNT_FRESH = 0;
	private int COUNT_GETIP_FAILED = 0;
	private int COUNT_SETIP_FAILED = 0;
	private int COUNT_FRESH_FAILED = 0;
	private int COUNT_CHANGE = 0;
	private int COUNT_FAILED = 0;

	// ==========================================================================================================================================================
	//
	// 生命周期函数
	//
	// ==========================================================================================================================================================

	public Scheduler_Dynamic() throws Exception {

		// @formatter:off

		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);

		// @formatter:on

	}

	@Override
	public LoggerX init(LoggerX logger) throws Exception {

		this.initAppFolder(logger);
		this.initPropertiesConfigurtion(logger);

		if (this.NEW_CONFIG) {
			logger.seek(Scheduler_Dynamic.MODULE_PACKAGENAME, "配置文件不存在 - 生成默认配置");
			this.CONFIG.setProperty("enable", "false");
			this.CONFIG.setProperty("getaddress", "");
			this.CONFIG.setProperty("setaddress", "");
			this.CONFIG.setProperty("clientua", "BTSCoolQ/1.0");
			this.CONFIG.setProperty("hostname", "");
			this.CONFIG.setProperty("password", "");
			this.saveConfig();
		} else {
			this.loadConfig();
		}

		this.ENABLE = Boolean.parseBoolean(this.CONFIG.getProperty("enable", "false"));

		logger.seek(Scheduler_Dynamic.MODULE_PACKAGENAME, "开关 ", this.ENABLE ? "启用" : "禁用");

		if (this.ENABLE) {

			this.API_GETADDRESS = this.CONFIG.getProperty("getaddress", "");
			this.API_SETADDRESS = this.CONFIG.getProperty("setaddress", "");
			this.CLIENTUA = this.CONFIG.getProperty("clientua", "BTSCoolQ/1.0");
			this.HOSTNAME = this.CONFIG.getProperty("hostname", "");
			this.PASSWORD = this.CONFIG.getProperty("password", "");

			logger.seek(Scheduler_Dynamic.MODULE_PACKAGENAME, "获取", this.API_GETADDRESS);
			logger.seek(Scheduler_Dynamic.MODULE_PACKAGENAME, "刷新", this.API_SETADDRESS);
			logger.seek(Scheduler_Dynamic.MODULE_PACKAGENAME, "标识", this.CLIENTUA);
			logger.seek(Scheduler_Dynamic.MODULE_PACKAGENAME, "域名", this.HOSTNAME);
			logger.seek(Scheduler_Dynamic.MODULE_PACKAGENAME, "密码", this.PASSWORD.substring(6, 12));

		}

		return logger;
	}

	@Override
	public LoggerX boot(LoggerX logger) throws Exception {
		if (this.ENABLE) {
			logger.info(Scheduler_Dynamic.MODULE_PACKAGENAME, "启动工作线程");
			this.thread = new Thread(new WorkerProcerss());
			this.thread.start();
		}
		return logger;
	}

	@Override
	public LoggerX save(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX shut(LoggerX logger) throws Exception {
		if (this.ENABLE) {
			logger.info(Scheduler_Dynamic.MODULE_PACKAGENAME, "终止工作线程");
			this.thread.interrupt();
			this.thread.join();
		}
		return logger;
	}

	@Override
	public LoggerX exec(LoggerX logger, Message message) throws Exception {

		if (message.getSection() < 2) {
			logger.info(Scheduler_Dynamic.MODULE_PACKAGENAME, "参数不足");
			return logger;
		}

		String command = message.getSegment()[1];

		switch (command) {
		case "get":
			logger.info(Scheduler_Dynamic.MODULE_PACKAGENAME, this.getAddress());
			break;
		case "set":
			if (message.getSection() == 2) {
				logger.info(Scheduler_Dynamic.MODULE_PACKAGENAME, this.setAddress());
			} else {
				logger.info(Scheduler_Dynamic.MODULE_PACKAGENAME, this.setAddress(message.getSegment(2)));
			}
			break;
		}
		return logger;
	}

	@Override
	public void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) throws Exception {
	}

	@Override
	public void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) throws Exception {
	}

	// ==========================================================================================================================================================
	//
	// 工具函数
	//
	// ==========================================================================================================================================================

	@Override
	public String[] generateReport(int mode, Message message, Object... parameters) {

		StringBuilder builder = new StringBuilder();
		builder.append("获取地址：");
		builder.append(this.COUNT_GETIP);
		builder.append("/");
		builder.append(this.COUNT_GETIP_FAILED);
		builder.append("\r\n设置地址：");
		builder.append(this.COUNT_SETIP);
		builder.append("/");
		builder.append(this.COUNT_SETIP_FAILED);
		builder.append("\r\n更新地址：");
		builder.append(this.COUNT_FRESH);
		builder.append("/");
		builder.append(this.COUNT_FRESH_FAILED);
		builder.append("\r\n地址变更：");
		builder.append(this.COUNT_CHANGE);
		builder.append("\r\n访问失败：");
		builder.append(this.COUNT_FAILED);
		String[] res = new String[] {
				builder.toString()
		};
		return res;

	}

	@SuppressWarnings("deprecation")
	class WorkerProcerss implements Runnable {

		@Override
		public void run() {
			long time;
			Date date;
			String address;
			String respons;
			int failcount = 0;
			do {
				try {
					// =======================================================
					while (true) {
						date = new Date();
						time = 300L;
						time = time - date.getSeconds();
						time = time - ((date.getMinutes() % 10) * 60);
						if (time < 60) { time = time + 300; }
						time = time * 1000;
						if (entry.DEBUG()) { entry.getCQ().logInfo(Scheduler_Dynamic.MODULE_PACKAGENAME, "休眠：" + time); }
						Thread.sleep(time);
						// =======================================================
						Scheduler_Dynamic.this.COUNT++;
						// =======================================================
						if (entry.DEBUG()) { entry.getCQ().logInfo(Scheduler_Dynamic.MODULE_PACKAGENAME, "执行"); }
						respons = Scheduler_Dynamic.this.setAddress();
						// 直接更新地址
						if (respons == null) {
							// 失败的话 执行备用逻辑
							address = Scheduler_Dynamic.this.getAddress();
							// 获取IP地址
							if (address == null) {
								// 失败的话 增加失败计数
								failcount++;
								Scheduler_Dynamic.this.COUNT_FAILED++;
							} else {
								// 成功的话
								// 利用正则判断是否是正常的ip地址
								if (Pattern.matches("[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}", address)) {
									// 成功的话 设置地址
									respons = Scheduler_Dynamic.this.setAddress(address);
									// 是否设置成功
									if (respons == null) {
										// 失败的话 增加失败计数
										failcount++;
										Scheduler_Dynamic.this.COUNT_FAILED++;
									} else {
										// 成功的话 重置失败计数
										failcount = 0;
										if (respons.startsWith("good")) { Scheduler_Dynamic.this.COUNT_CHANGE++; }
									}
								} else {
									// 不是正常地址 增加失败计数
									failcount++;
									Scheduler_Dynamic.this.COUNT_FAILED++;
								}
							}
						} else {
							// 成功的话 重置失败计数
							failcount = 0;
							// 如果发生改变API返回内容为 good 123.123.123.123
							if (respons.startsWith("good")) { Scheduler_Dynamic.this.COUNT_CHANGE++; }
						}
						if (failcount > 6) {
							failcount = 0;
							entry.adminInfo("[DDNS] 警告 更新失败\r\n需要手动介入\r\n已连续失败六次");
						}
						if (entry.DEBUG()) { entry.getCQ().logInfo(Scheduler_Dynamic.MODULE_PACKAGENAME, "结果 " + respons); }
						// =======================================================
					}
				} catch (InterruptedException exception) {
					if (entry.isEnable()) {
						entry.getCQ().logWarning(Scheduler_Dynamic.MODULE_PACKAGENAME, "异常");
					} else {
						entry.getCQ().logInfo(Scheduler_Dynamic.MODULE_PACKAGENAME, "关闭");
					}
				}
			} while (entry.isEnable());
		}
	}

	public String getAddress() {
		try {
			URL url = new URL(this.API_GETADDRESS);
			URLConnection connection = url.openConnection();
			connection.setReadTimeout(5000);
			connection.setConnectTimeout(5000);
			connection.setRequestProperty("User-Agent", this.CLIENTUA);
			connection.connect();
			connection.getContent();
			byte[] buffer = new byte[32];
			InputStream rx = connection.getInputStream();
			rx.read(buffer);
			this.COUNT_GETIP++;
			return new String(buffer, StandardCharsets.UTF_8).trim();
		} catch (IOException exception) {
			exception.printStackTrace();
			entry.adminInfo(Scheduler_Dynamic.MODULE_PACKAGENAME + " 获取异常 " + exception.getMessage());
			this.COUNT_GETIP_FAILED++;
			return null;
		}
	}

	public String setAddress() {
		try {
			URL url = new URL(this.API_SETADDRESS + "?hostname=" + this.HOSTNAME);
			URLConnection connection = url.openConnection();
			connection.setReadTimeout(5000);
			connection.setConnectTimeout(5000);
			connection.setRequestProperty("User-Agent", this.CLIENTUA);
			connection.setRequestProperty("Authorization", this.PASSWORD);
			connection.connect();
			connection.getContent();
			byte[] buffer = new byte[32];
			InputStream rx = connection.getInputStream();
			rx.read(buffer);
			this.COUNT_SETIP++;
			return new String(buffer, StandardCharsets.UTF_8).trim();
		} catch (IOException exception) {
			this.COUNT_SETIP_FAILED++;
			exception.printStackTrace();
			entry.adminInfo(Scheduler_Dynamic.MODULE_PACKAGENAME + " 获取异常" + exception.getMessage());
			return null;
		}
	}

	public String setAddress(String address) {
		try {
			URL url = new URL(this.API_SETADDRESS + "?hostname=" + this.HOSTNAME + "&myip=" + address);
			URLConnection connection = url.openConnection();
			connection.setReadTimeout(5000);
			connection.setConnectTimeout(5000);
			connection.setRequestProperty("User-Agent", this.CLIENTUA);
			connection.setRequestProperty("Authorization", this.PASSWORD);
			connection.connect();
			connection.getContent();
			byte[] buffer = new byte[32];
			InputStream rx = connection.getInputStream();
			rx.read(buffer);
			this.COUNT_FRESH++;
			return new String(buffer, StandardCharsets.UTF_8).trim();
		} catch (IOException exception) {
			this.COUNT_FRESH_FAILED++;
			exception.printStackTrace();
			entry.adminInfo(Scheduler_Dynamic.MODULE_PACKAGENAME + " 获取异常" + exception.getMessage());
			return null;
		}
	}

}
package studio.blacktech.coolqbot.furryblack.modules;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.TreeMap;

import org.meowy.cqp.jcq.entity.Group;
import org.meowy.cqp.jcq.entity.Member;

import studio.blacktech.coolqbot.furryblack.entry;
import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.exception.InitializationException;
import studio.blacktech.coolqbot.furryblack.common.message.Message;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;
import studio.blacktech.coolqbot.furryblack.common.module.Module;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleExecutor;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleListener;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleScheduler;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleTrigger;
import studio.blacktech.coolqbot.furryblack.modules.Executor.Executor_acon;
import studio.blacktech.coolqbot.furryblack.modules.Executor.Executor_admin;
import studio.blacktech.coolqbot.furryblack.modules.Executor.Executor_chou;
import studio.blacktech.coolqbot.furryblack.modules.Executor.Executor_dice;
import studio.blacktech.coolqbot.furryblack.modules.Executor.Executor_echo;
import studio.blacktech.coolqbot.furryblack.modules.Executor.Executor_food;
import studio.blacktech.coolqbot.furryblack.modules.Executor.Executor_jrjp;
import studio.blacktech.coolqbot.furryblack.modules.Executor.Executor_jrrp;
import studio.blacktech.coolqbot.furryblack.modules.Executor.Executor_kong;
import studio.blacktech.coolqbot.furryblack.modules.Executor.Executor_roll;
import studio.blacktech.coolqbot.furryblack.modules.Executor.Executor_roulette;
import studio.blacktech.coolqbot.furryblack.modules.Executor.Executor_time;
import studio.blacktech.coolqbot.furryblack.modules.Executor.Executor_zhan;
import studio.blacktech.coolqbot.furryblack.modules.Listener.Listener_TopSpeak;
import studio.blacktech.coolqbot.furryblack.modules.Scheduler.Scheduler_Dynamic;
import studio.blacktech.coolqbot.furryblack.modules.Trigger.Trigger_UserDeny;
import studio.blacktech.coolqbot.furryblack.modules.Trigger.Trigger_WordDeny;

/**
 * FurryBlack的核心路由
 *
 * 持有所有模块的实例
 *
 * 管理所有模块的生命周期
 *
 * 响应所有事件
 *
 * 接受所有消息
 *
 * 发送所有消息
 *
 * 昵称表管理
 *
 * Systemd本身也继承自Module始祖模块，包含一般方法。
 *
 * @author Alceatraz Warprays
 *
 */
public class Systemd extends Module {

	private static final long serialVersionUID = 1L;

	// ==========================================================================================================================================================
	//
	// 模块基本配置
	//
	// ==========================================================================================================================================================

	private static String MODULE_PACKAGENAME = "Core_Systemd";
	private static String MODULE_COMMANDNAME = "systemd";
	private static String MODULE_DISPLAYNAME = "核心模块";
	private static String MODULE_DESCRIPTION = "管理所有功能模块并路由所有消息";
	private static String MODULE_VERSION = "27.3";
	private static String[] MODULE_USAGE = new String[] {};
	private static String[] MODULE_PRIVACY_STORED = new String[] {};
	private static String[] MODULE_PRIVACY_CACHED = new String[] {};
	private static String[] MODULE_PRIVACY_OBTAIN = new String[] {};

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	private int COUNT_USER_MESSAGE = 0;
	private int COUNT_DISZ_MESSAGE = 0;
	private int COUNT_GROP_MESSAGE = 0;

	private long USERID_CQBOT = 0;
	private long USERID_ADMIN = 0;

	private boolean ENABLE_SCHEDULER = false;
	private boolean ENABLE_TRIGGER_USER = false;
	private boolean ENABLE_TRIGGER_DISZ = false;
	private boolean ENABLE_TRIGGER_GROP = false;
	private boolean ENABLE_LISENTER_USER = false;
	private boolean ENABLE_LISENTER_DISZ = false;
	private boolean ENABLE_LISENTER_GROP = false;
	private boolean ENABLE_EXECUTOR_USER = false;
	private boolean ENABLE_EXECUTOR_DISZ = false;
	private boolean ENABLE_EXECUTOR_GROP = false;

	private String CONFIG_SCHEDULER;
	private String CONFIG_TRIGGER_USER;
	private String CONFIG_TRIGGER_DISZ;
	private String CONFIG_TRIGGER_GROP;
	private String CONFIG_LISENTER_USER;
	private String CONFIG_LISENTER_DISZ;
	private String CONFIG_LISENTER_GROP;
	private String CONFIG_EXECUTOR_USER;
	private String CONFIG_EXECUTOR_DISZ;
	private String CONFIG_EXECUTOR_GROP;

	private String[] LIST_SCHEDULER = {};
	private String[] LIST_TRIGGER_USER = {};
	private String[] LIST_TRIGGER_DISZ = {};
	private String[] LIST_TRIGGER_GROP = {};
	private String[] LIST_LISENTER_USER = {};
	private String[] LIST_LISENTER_DISZ = {};
	private String[] LIST_LISENTER_GROP = {};
	private String[] LIST_EXECUTOR_USER = {};
	private String[] LIST_EXECUTOR_DISZ = {};
	private String[] LIST_EXECUTOR_GROP = {};

	private TreeMap<String, ModuleScheduler> SCHEDULER_INSTANCE;
	private ArrayList<ModuleScheduler> SCHEDULER_ENABLED;

	private TreeMap<String, ModuleTrigger> TRIGGER_INSTANCE;
	private ArrayList<ModuleTrigger> TRIGGER_USER;
	private ArrayList<ModuleTrigger> TRIGGER_DISZ;
	private ArrayList<ModuleTrigger> TRIGGER_GROP;

	private TreeMap<String, ModuleListener> LISTENER_INSTANCE;
	private ArrayList<ModuleListener> LISTENER_USER;
	private ArrayList<ModuleListener> LISTENER_DISZ;
	private ArrayList<ModuleListener> LISTENER_GROP;

	private TreeMap<String, ModuleExecutor> EXECUTOR_INSTANCE;
	private TreeMap<String, ModuleExecutor> EXECUTOR_USER;
	private TreeMap<String, ModuleExecutor> EXECUTOR_DISZ;
	private TreeMap<String, ModuleExecutor> EXECUTOR_GROP;

	private File FILE_NICKNAME_MAP;
	private File FILE_MESSAGE_HELP;
	private File FILE_MESSAGE_INFO;
	private File FILE_MESSAGE_EULA;
	private File FILE_SILENCE_GROP;

	private File FILE_MEMBERCHANGE;

	private String MESSAGE_HELP = "";
	private String MESSAGE_INFO = "";
	private String MESSAGE_EULA = "";

	private String MESSAGE_LIST_USER = "";
	private String MESSAGE_LIST_DISZ = "";
	private String MESSAGE_LIST_GROP = "";

	private TreeMap<Long, TreeMap<Long, String>> NICKNAME_MAP;

	private HashSet<Long> MESSAGE_MUTE;

	private boolean LOCK_INIT = false;

	// ==========================================================================================================================================================
	//
	// 构造函数
	//
	// ==========================================================================================================================================================

	public Systemd() throws Exception {

		// @formatter:off

		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);

		// @formatter:on

	}

	// ==========================================================================================================================================================
	//
	// 模块声明周期管理
	//
	// ==========================================================================================================================================================

	/**
	 * 你永远不应该执行这个方法
	 */
	@Override
	public LoggerX init(LoggerX logger) throws Exception {

		if (this.LOCK_INIT) { return logger; }
		this.LOCK_INIT = true;

		// =======================================================================================================================
		// 初始化目录
		// =======================================================================================================================

		this.initAppFolder(logger);
		this.initConfFolder(logger);
		this.initLogsFolder(logger);

		// =======================================================================================================================
		// 初始化内存结构
		// =======================================================================================================================

		this.SCHEDULER_INSTANCE = new TreeMap<>();
		this.SCHEDULER_ENABLED = new ArrayList<>();

		this.TRIGGER_INSTANCE = new TreeMap<>();
		this.TRIGGER_USER = new ArrayList<>();
		this.TRIGGER_DISZ = new ArrayList<>();
		this.TRIGGER_GROP = new ArrayList<>();

		this.LISTENER_INSTANCE = new TreeMap<>();
		this.LISTENER_USER = new ArrayList<>();
		this.LISTENER_DISZ = new ArrayList<>();
		this.LISTENER_GROP = new ArrayList<>();

		this.EXECUTOR_INSTANCE = new TreeMap<>();
		this.EXECUTOR_USER = new TreeMap<>();
		this.EXECUTOR_DISZ = new TreeMap<>();
		this.EXECUTOR_GROP = new TreeMap<>();

		this.MESSAGE_MUTE = new HashSet<>();

		this.NICKNAME_MAP = new TreeMap<>();

		// =======================================================================================================================
		// 读取配置文件
		// =======================================================================================================================

		if (this.NEW_CONFIG) {
			logger.seek(Systemd.MODULE_PACKAGENAME, "配置文件不存在", "生成默认配置");
			this.CONFIG.setProperty("logger_level", "0");
			this.CONFIG.setProperty("userid_admin", "0");
			this.CONFIG.setProperty("scheduler", "none");
			this.CONFIG.setProperty("trigger_user", "none");
			this.CONFIG.setProperty("trigger_disz", "none");
			this.CONFIG.setProperty("trigger_grop", "none");
			this.CONFIG.setProperty("listener_user", "none");
			this.CONFIG.setProperty("listener_disz", "none");
			this.CONFIG.setProperty("listener_grop", "none");
			this.CONFIG.setProperty("executor_user", "none");
			this.CONFIG.setProperty("executor_disz", "none");
			this.CONFIG.setProperty("executor_grop", "none");
			this.saveConfig();
		} else {
			this.loadConfig();
		}

		this.USERID_CQBOT = entry.getCQ().getLoginQQ();
		this.USERID_ADMIN = Long.parseLong(this.CONFIG.getProperty("userid_admin", "0"));

		if (this.USERID_ADMIN == 0) { throw new Exception("管理员账号配置错误"); }

		logger.seek(Systemd.MODULE_PACKAGENAME, "机器人账号", this.USERID_CQBOT);
		logger.seek(Systemd.MODULE_PACKAGENAME, "管理员账号", this.USERID_ADMIN);

		for (Group group : entry.getCQ().getGroupList()) {
			this.NICKNAME_MAP.put(group.getId(), new TreeMap<>());
		}

		// =======================================================================================================================
		// 读取独立配置文件
		// =======================================================================================================================

		this.FILE_MESSAGE_HELP = Paths.get(this.FOLDER_CONF.getAbsolutePath(), "message_help.txt").toFile();
		this.FILE_MESSAGE_INFO = Paths.get(this.FOLDER_CONF.getAbsolutePath(), "message_info.txt").toFile();
		this.FILE_MESSAGE_EULA = Paths.get(this.FOLDER_CONF.getAbsolutePath(), "message_eula.txt").toFile();
		this.FILE_SILENCE_GROP = Paths.get(this.FOLDER_CONF.getAbsolutePath(), "mute_grop.txt").toFile();
		this.FILE_NICKNAME_MAP = Paths.get(this.FOLDER_CONF.getAbsolutePath(), "nickmap_grop.txt").toFile();
		this.FILE_MEMBERCHANGE = Paths.get(this.FOLDER_LOGS.getAbsolutePath(), "member_change.txt").toFile();

		if (!this.FILE_MESSAGE_HELP.exists()) { if (!this.FILE_MESSAGE_HELP.createNewFile()) { throw new InitializationException("无法创建文件" + this.FILE_SILENCE_GROP.getName()); } }
		if (!this.FILE_MESSAGE_INFO.exists()) { if (!this.FILE_MESSAGE_INFO.createNewFile()) { throw new InitializationException("无法创建文件" + this.FILE_SILENCE_GROP.getName()); } }
		if (!this.FILE_MESSAGE_EULA.exists()) { if (!this.FILE_MESSAGE_EULA.createNewFile()) { throw new InitializationException("无法创建文件" + this.FILE_SILENCE_GROP.getName()); } }
		if (!this.FILE_SILENCE_GROP.exists()) { if (!this.FILE_SILENCE_GROP.createNewFile()) { throw new InitializationException("无法创建文件" + this.FILE_SILENCE_GROP.getName()); } }
		if (!this.FILE_NICKNAME_MAP.exists()) { if (!this.FILE_NICKNAME_MAP.createNewFile()) { throw new InitializationException("无法创建文件" + this.FILE_SILENCE_GROP.getName()); } }
		if (!this.FILE_MEMBERCHANGE.exists()) { if (!this.FILE_MEMBERCHANGE.createNewFile()) { throw new InitializationException("无法创建文件" + this.FILE_SILENCE_GROP.getName()); } }

		long gropid;
		long userid;
		String line;
		String[] temp;

		BufferedReader readerHelp = new BufferedReader(new InputStreamReader(new FileInputStream(this.FILE_MESSAGE_HELP), StandardCharsets.UTF_8));
		BufferedReader readerInfo = new BufferedReader(new InputStreamReader(new FileInputStream(this.FILE_MESSAGE_INFO), StandardCharsets.UTF_8));
		BufferedReader readerEula = new BufferedReader(new InputStreamReader(new FileInputStream(this.FILE_MESSAGE_EULA), StandardCharsets.UTF_8));
		BufferedReader readerMute = new BufferedReader(new InputStreamReader(new FileInputStream(this.FILE_SILENCE_GROP), StandardCharsets.UTF_8));
		BufferedReader readerNick = new BufferedReader(new InputStreamReader(new FileInputStream(this.FILE_NICKNAME_MAP), StandardCharsets.UTF_8));

		// =======================================================================================
		// 读取 help info eula 文本

		StringBuilder builder = new StringBuilder();

		logger.full(Systemd.MODULE_PACKAGENAME, "读取HELP模板消息");

		while ((line = readerHelp.readLine()) != null) {
			builder.append(line + "\r\n");
		}

		builder.setLength(builder.length() - 2);
		this.MESSAGE_HELP = builder.toString();

		builder = new StringBuilder();

		logger.full(Systemd.MODULE_PACKAGENAME, "读取INFO模板消息");

		while ((line = readerInfo.readLine()) != null) {
			builder.append(line + "\r\n");
			this.MESSAGE_INFO = this.MESSAGE_INFO + line + "\r\n";
		}

		builder.setLength(builder.length() - 2);
		this.MESSAGE_INFO = builder.toString();
		builder = new StringBuilder();

		logger.full(Systemd.MODULE_PACKAGENAME, "读取EULA模板消息");

		while ((line = readerEula.readLine()) != null) {
			builder.append(line + "\r\n");
		}

		builder.setLength(builder.length() - 2);
		this.MESSAGE_EULA = builder.toString();

		this.MESSAGE_HELP = this.MESSAGE_HELP.replaceAll("REPLACE_VERSION", entry.VerID);
		this.MESSAGE_INFO = this.MESSAGE_INFO.replaceAll("REPLACE_VERSION", entry.VerID);
		this.MESSAGE_EULA = this.MESSAGE_EULA.replaceAll("REPLACE_VERSION", entry.VerID);

		String hashInfo = logger.seek(Systemd.MODULE_PACKAGENAME, "INFO散列值", sha1(this.MESSAGE_INFO));
		String hashEula = logger.seek(Systemd.MODULE_PACKAGENAME, "EULA散列值", sha1(this.MESSAGE_EULA));

		this.MESSAGE_INFO = this.MESSAGE_INFO + "\n=======================\nSHA-1: " + hashInfo;
		this.MESSAGE_EULA = this.MESSAGE_EULA + "\n=======================\nSHA-1: " + hashEula;

		// =======================================================================================
		// 读取 静音的群

		logger.full(Systemd.MODULE_PACKAGENAME, "读取静音群列表");

		while ((line = readerMute.readLine()) != null) {

			if (line.startsWith("#")) { continue; }
			if (line.contains("#")) { line = line.substring(0, line.indexOf("#")).trim(); }

			this.MESSAGE_MUTE.add(Long.parseLong(line));

			logger.seek(Systemd.MODULE_PACKAGENAME, "关闭发言", line);
		}

		// =======================================================================================
		// 读取 群昵称对应表

		logger.full(Systemd.MODULE_PACKAGENAME, "读取群昵称表");

		while ((line = readerNick.readLine()) != null) {

			if (line.startsWith("#")) { continue; }
			if (!line.contains(":")) { continue; }
			if (line.contains("#")) { line = line.substring(0, line.indexOf("#")).trim(); }

			temp = line.split(":");

			if (temp.length != 3) {
				logger.seek(Systemd.MODULE_PACKAGENAME, "配置无效", line);
				continue;
			}

			gropid = Long.parseLong(temp[0]);
			userid = Long.parseLong(temp[1]);

			if (!this.NICKNAME_MAP.containsKey(gropid)) { this.NICKNAME_MAP.put(gropid, new TreeMap<Long, String>()); }

			this.NICKNAME_MAP.get(gropid).put(userid, temp[2]);

		}

		readerHelp.close();
		readerInfo.close();
		readerEula.close();
		readerMute.close();
		readerNick.close();

		logger.seek(Systemd.MODULE_PACKAGENAME, "群昵称表", this.NICKNAME_MAP.size() + "个");

		for (long nickmap : this.NICKNAME_MAP.keySet()) {
			logger.seek(Systemd.MODULE_PACKAGENAME, "群" + nickmap, this.NICKNAME_MAP.get(nickmap).size() + "个");
		}

		// =======================================================================================================================
		// 实例化模块
		// =======================================================================================================================

		logger.full(Systemd.MODULE_PACKAGENAME, "实例化模块");

		// =======================================================================================================================
		// 实例化辅助模块

		this.instantiationScheduler(new Scheduler_Dynamic());

		// =======================================================================================================================
		// 实例化触发器

		this.instantiationTrigger(new Trigger_UserDeny());
		this.instantiationTrigger(new Trigger_WordDeny());

		// =======================================================================================================================
		// 实例化监听器

		this.instantiationListener(new Listener_TopSpeak());

		// =======================================================================================================================
		// 实例化执行器

		this.instantiationExecutor(new Executor_admin());
		this.instantiationExecutor(new Executor_acon());
		this.instantiationExecutor(new Executor_chou());
		this.instantiationExecutor(new Executor_dice());
		this.instantiationExecutor(new Executor_echo());
		this.instantiationExecutor(new Executor_food());
		this.instantiationExecutor(new Executor_jrjp());
		this.instantiationExecutor(new Executor_jrrp());
		this.instantiationExecutor(new Executor_kong());
		this.instantiationExecutor(new Executor_roll());
		this.instantiationExecutor(new Executor_roulette());
		this.instantiationExecutor(new Executor_time());
		this.instantiationExecutor(new Executor_zhan());

		// =======================================================================================================================
		// 初始化模块
		// =======================================================================================================================

		logger.full(Systemd.MODULE_PACKAGENAME, "初始化模块");

		// =======================================================================================================================
		// 初始化定时器
		for (String name : this.SCHEDULER_INSTANCE.keySet()) {
			logger.full(Systemd.MODULE_PACKAGENAME, "初始化定时器", name);
			this.SCHEDULER_INSTANCE.get(name).init(logger);
		}

		// =======================================================================================================================
		// 初始化触发器

		for (String name : this.TRIGGER_INSTANCE.keySet()) {
			logger.full(Systemd.MODULE_PACKAGENAME, "初始化触发器", name);
			this.TRIGGER_INSTANCE.get(name).init(logger);
		}

		// =======================================================================================================================
		// 初始化监听器

		for (String name : this.LISTENER_INSTANCE.keySet()) {
			logger.full(Systemd.MODULE_PACKAGENAME, "初始化监听器", name);
			this.LISTENER_INSTANCE.get(name).init(logger);
		}

		// =======================================================================================================================
		// 初始化执行器

		for (String name : this.EXECUTOR_INSTANCE.keySet()) {
			logger.full(Systemd.MODULE_PACKAGENAME, "初始化执行器", name);
			this.EXECUTOR_INSTANCE.get(name).init(logger);
		}

		// =======================================================================================================================
		// 读取模块配置
		// =======================================================================================================================

		logger.full(Systemd.MODULE_PACKAGENAME, "读取模块配置列表");

		// =======================================================================================================================
		// 读取定时器配置

		this.CONFIG_SCHEDULER = this.CONFIG.getProperty("scheduler", "none");

		logger.seek(Systemd.MODULE_PACKAGENAME, "定时器配置 全局", this.CONFIG_SCHEDULER);

		this.LIST_SCHEDULER = this.CONFIG_SCHEDULER.equals("none") ? new String[0] : this.CONFIG_SCHEDULER.split(",");

		// =======================================================================================================================
		// 读取触发器配置

		this.CONFIG_TRIGGER_USER = this.CONFIG.getProperty("trigger_user", "none");
		this.CONFIG_TRIGGER_DISZ = this.CONFIG.getProperty("trigger_disz", "none");
		this.CONFIG_TRIGGER_GROP = this.CONFIG.getProperty("trigger_grop", "none");

		logger.seek(Systemd.MODULE_PACKAGENAME, "触发器配置 私聊", this.CONFIG_TRIGGER_USER);
		logger.seek(Systemd.MODULE_PACKAGENAME, "触发器配置 组聊", this.CONFIG_TRIGGER_DISZ);
		logger.seek(Systemd.MODULE_PACKAGENAME, "触发器配置 群聊", this.CONFIG_TRIGGER_GROP);

		this.LIST_TRIGGER_USER = this.CONFIG_TRIGGER_USER.equals("none") ? new String[0] : this.CONFIG_TRIGGER_USER.split(",");
		this.LIST_TRIGGER_DISZ = this.CONFIG_TRIGGER_DISZ.equals("none") ? new String[0] : this.CONFIG_TRIGGER_DISZ.split(",");
		this.LIST_TRIGGER_GROP = this.CONFIG_TRIGGER_GROP.equals("none") ? new String[0] : this.CONFIG_TRIGGER_GROP.split(",");

		// =======================================================================================================================
		// 读取监听器配置

		this.CONFIG_LISENTER_USER = this.CONFIG.getProperty("listener_user", "none");
		this.CONFIG_LISENTER_DISZ = this.CONFIG.getProperty("listener_disz", "none");
		this.CONFIG_LISENTER_GROP = this.CONFIG.getProperty("listener_grop", "none");

		logger.seek(Systemd.MODULE_PACKAGENAME, "监听器配置 私聊", this.CONFIG_LISENTER_USER);
		logger.seek(Systemd.MODULE_PACKAGENAME, "监听器配置 组聊", this.CONFIG_LISENTER_DISZ);
		logger.seek(Systemd.MODULE_PACKAGENAME, "监听器配置 群聊", this.CONFIG_LISENTER_GROP);

		this.LIST_LISENTER_USER = this.CONFIG_LISENTER_USER.equals("none") ? new String[0] : this.CONFIG_LISENTER_USER.split(",");
		this.LIST_LISENTER_DISZ = this.CONFIG_LISENTER_DISZ.equals("none") ? new String[0] : this.CONFIG_LISENTER_DISZ.split(",");
		this.LIST_LISENTER_GROP = this.CONFIG_LISENTER_GROP.equals("none") ? new String[0] : this.CONFIG_LISENTER_GROP.split(",");

		// =======================================================================================================================
		// 读取执行器配置

		this.CONFIG_EXECUTOR_USER = this.CONFIG.getProperty("executor_user", "none");
		this.CONFIG_EXECUTOR_DISZ = this.CONFIG.getProperty("executor_disz", "none");
		this.CONFIG_EXECUTOR_GROP = this.CONFIG.getProperty("executor_grop", "none");

		logger.seek(Systemd.MODULE_PACKAGENAME, "执行器配置 私聊", this.CONFIG_EXECUTOR_USER);
		logger.seek(Systemd.MODULE_PACKAGENAME, "执行器配置 组聊", this.CONFIG_EXECUTOR_DISZ);
		logger.seek(Systemd.MODULE_PACKAGENAME, "执行器配置 群聊", this.CONFIG_EXECUTOR_GROP);

		this.LIST_EXECUTOR_USER = this.CONFIG_EXECUTOR_USER.equals("none") ? new String[0] : this.CONFIG_EXECUTOR_USER.split(",");
		this.LIST_EXECUTOR_DISZ = this.CONFIG_EXECUTOR_DISZ.equals("none") ? new String[0] : this.CONFIG_EXECUTOR_DISZ.split(",");
		this.LIST_EXECUTOR_GROP = this.CONFIG_EXECUTOR_GROP.equals("none") ? new String[0] : this.CONFIG_EXECUTOR_GROP.split(",");

		// =======================================================================================================================
		// 注册模块
		// =======================================================================================================================

		logger.full(Systemd.MODULE_PACKAGENAME, "注册模块");

		// =======================================================================================================================
		// 注册定时器

		for (String name : this.LIST_SCHEDULER) {
			if (this.SCHEDULER_INSTANCE.containsKey(name)) {
				ModuleScheduler instance = this.SCHEDULER_INSTANCE.get(name);
				if (instance.ENABLE()) {
					logger.full(Systemd.MODULE_PACKAGENAME, "注册定时器 全局", instance.MODULE_PACKAGENAME());
					this.SCHEDULER_ENABLED.add(instance);
				}
			} else {
				logger.mini(Systemd.MODULE_PACKAGENAME, "配置错误", "定时器不存在 " + name);
			}
		}

		this.ENABLE_SCHEDULER = this.SCHEDULER_ENABLED.size() > 0;

		// =======================================================================================================================
		// 注册触发器

		for (String name : this.LIST_TRIGGER_USER) {
			if (this.TRIGGER_INSTANCE.containsKey(name)) {
				ModuleTrigger instance = this.TRIGGER_INSTANCE.get(name);
				if (instance.ENABLE_USER()) {
					logger.full(Systemd.MODULE_PACKAGENAME, "注册触发器 私聊", instance.MODULE_PACKAGENAME());
					this.TRIGGER_USER.add(instance);
				}
			} else {
				logger.mini(Systemd.MODULE_PACKAGENAME, "配置错误", "私聊触发器不存在 " + name);
			}
		}

		for (String name : this.LIST_TRIGGER_DISZ) {
			if (this.TRIGGER_INSTANCE.containsKey(name)) {
				ModuleTrigger instance = this.TRIGGER_INSTANCE.get(name);
				if (instance.ENABLE_DISZ()) {
					logger.full(Systemd.MODULE_PACKAGENAME, "注册触发器 组聊", instance.MODULE_PACKAGENAME());
					this.TRIGGER_DISZ.add(instance);
				}
			} else {
				logger.mini(Systemd.MODULE_PACKAGENAME, "配置错误", "组聊触发器不存在 " + name);
			}
		}

		for (String name : this.LIST_TRIGGER_GROP) {
			if (this.TRIGGER_INSTANCE.containsKey(name)) {
				ModuleTrigger instance = this.TRIGGER_INSTANCE.get(name);
				if (instance.ENABLE_GROP()) {
					logger.full(Systemd.MODULE_PACKAGENAME, "注册触发器 群聊", instance.MODULE_PACKAGENAME());
					this.TRIGGER_GROP.add(instance);
				}
			} else {
				logger.mini(Systemd.MODULE_PACKAGENAME, "配置错误", "群聊触发器不存在 " + name);
			}
		}

		this.ENABLE_TRIGGER_USER = this.TRIGGER_USER.size() > 0;
		this.ENABLE_TRIGGER_DISZ = this.TRIGGER_DISZ.size() > 0;
		this.ENABLE_TRIGGER_GROP = this.TRIGGER_GROP.size() > 0;

		// =======================================================================================================================
		// 注册监听器

		for (String name : this.LIST_LISENTER_USER) {
			if (this.LISTENER_INSTANCE.containsKey(name)) {
				ModuleListener instance = this.LISTENER_INSTANCE.get(name);
				if (instance.ENABLE_USER()) {
					logger.full(Systemd.MODULE_PACKAGENAME, "注册监听器 私聊", instance.MODULE_PACKAGENAME());
					this.LISTENER_USER.add(instance);
				}
			} else {
				logger.mini(Systemd.MODULE_PACKAGENAME, "配置错误", "私聊监听器不存在 " + name);
			}
		}

		for (String name : this.LIST_LISENTER_DISZ) {
			if (this.LISTENER_INSTANCE.containsKey(name)) {
				ModuleListener instance = this.LISTENER_INSTANCE.get(name);
				if (instance.ENABLE_DISZ()) {
					logger.full(Systemd.MODULE_PACKAGENAME, "注册监听器 组聊", instance.MODULE_PACKAGENAME());
					this.LISTENER_DISZ.add(instance);
				}
			} else {
				logger.mini(Systemd.MODULE_PACKAGENAME, "配置错误", "组聊监听器不存在 " + name);
			}
		}

		for (String name : this.LIST_LISENTER_GROP) {
			if (this.LISTENER_INSTANCE.containsKey(name)) {
				ModuleListener instance = this.LISTENER_INSTANCE.get(name);
				if (instance.ENABLE_GROP()) {
					logger.full(Systemd.MODULE_PACKAGENAME, "注册监听器 群聊", instance.MODULE_PACKAGENAME());
					this.LISTENER_GROP.add(instance);
				}
			} else {
				logger.mini(Systemd.MODULE_PACKAGENAME, "配置错误", "群聊监听器不存在 " + name);
			}
		}

		this.ENABLE_LISENTER_USER = this.LISTENER_USER.size() > 0;
		this.ENABLE_LISENTER_DISZ = this.LISTENER_DISZ.size() > 0;
		this.ENABLE_LISENTER_GROP = this.LISTENER_GROP.size() > 0;

		// =======================================================================================================================
		// 注册执行器

		for (String name : this.LIST_EXECUTOR_USER) {
			if (this.EXECUTOR_INSTANCE.containsKey(name)) {
				ModuleExecutor instance = this.EXECUTOR_INSTANCE.get(name);
				if (instance.ENABLE_USER()) {
					logger.full(Systemd.MODULE_PACKAGENAME, "注册执行器 私聊", instance.MODULE_PACKAGENAME());
					this.EXECUTOR_USER.put(instance.MODULE_COMMANDNAME(), instance);
				}
			} else {
				logger.mini(Systemd.MODULE_PACKAGENAME, "配置错误", "私聊执行器不存在 " + name);
			}
		}

		for (String name : this.LIST_EXECUTOR_DISZ) {
			if (this.EXECUTOR_INSTANCE.containsKey(name)) {
				ModuleExecutor instance = this.EXECUTOR_INSTANCE.get(name);
				if (instance.ENABLE_DISZ()) {
					logger.full(Systemd.MODULE_PACKAGENAME, "注册执行器 组聊", instance.MODULE_PACKAGENAME());
					this.EXECUTOR_DISZ.put(instance.MODULE_COMMANDNAME(), instance);
				}
			} else {
				logger.mini(Systemd.MODULE_PACKAGENAME, "配置错误", "组聊执行器不存在 " + name);
			}
		}

		for (String name : this.LIST_EXECUTOR_GROP) {
			if (this.EXECUTOR_INSTANCE.containsKey(name)) {
				ModuleExecutor instance = this.EXECUTOR_INSTANCE.get(name);
				if (instance.ENABLE_GROP()) {
					logger.full(Systemd.MODULE_PACKAGENAME, "注册执行器 群聊", instance.MODULE_PACKAGENAME());
					this.EXECUTOR_GROP.put(instance.MODULE_COMMANDNAME(), instance);
				}
			} else {
				logger.mini(Systemd.MODULE_PACKAGENAME, "配置错误", "群聊执行器不存在 " + name);
			}
		}

		this.ENABLE_EXECUTOR_USER = this.EXECUTOR_USER.size() > 0;
		this.ENABLE_EXECUTOR_DISZ = this.EXECUTOR_DISZ.size() > 0;
		this.ENABLE_EXECUTOR_GROP = this.EXECUTOR_GROP.size() > 0;

		// =======================================================================================================================
		// 统计模块状态
		// =======================================================================================================================

		logger.info(Systemd.MODULE_PACKAGENAME, "模块状态");

		logger.info(Systemd.MODULE_PACKAGENAME, "计时器 全局", this.ENABLE_SCHEDULER ? "启用 " + this.SCHEDULER_ENABLED.size() + "个" : "禁用");

		logger.info(Systemd.MODULE_PACKAGENAME, "触发器 私聊", this.ENABLE_TRIGGER_USER ? "启用 " + this.TRIGGER_USER.size() + "个" : "禁用");
		logger.info(Systemd.MODULE_PACKAGENAME, "触发器 组聊", this.ENABLE_TRIGGER_DISZ ? "启用 " + this.TRIGGER_DISZ.size() + "个" : "禁用");
		logger.info(Systemd.MODULE_PACKAGENAME, "触发器 群聊", this.ENABLE_TRIGGER_GROP ? "启用 " + this.TRIGGER_GROP.size() + "个" : "禁用");

		logger.info(Systemd.MODULE_PACKAGENAME, "监听器 私聊", this.ENABLE_LISENTER_USER ? "启用 " + this.LISTENER_DISZ.size() + "个" : "禁用");
		logger.info(Systemd.MODULE_PACKAGENAME, "监听器 组聊", this.ENABLE_LISENTER_DISZ ? "启用 " + this.LISTENER_DISZ.size() + "个" : "禁用");
		logger.info(Systemd.MODULE_PACKAGENAME, "监听器 群聊", this.ENABLE_LISENTER_GROP ? "启用 " + this.LISTENER_GROP.size() + "个" : "禁用");

		logger.info(Systemd.MODULE_PACKAGENAME, "执行器 私聊", this.ENABLE_EXECUTOR_USER ? "启用 " + this.EXECUTOR_USER.size() + "个" : "禁用");
		logger.info(Systemd.MODULE_PACKAGENAME, "执行器 组聊", this.ENABLE_EXECUTOR_DISZ ? "启用 " + this.EXECUTOR_DISZ.size() + "个" : "禁用");
		logger.info(Systemd.MODULE_PACKAGENAME, "执行器 群聊", this.ENABLE_EXECUTOR_GROP ? "启用 " + this.EXECUTOR_GROP.size() + "个" : "禁用");

		// =======================================================================================================================
		// 预生成 list 的信息

		this.MESSAGE_LIST_USER = this.generateListMessage("私聊", this.TRIGGER_USER, this.LISTENER_USER, this.EXECUTOR_USER);
		this.MESSAGE_LIST_DISZ = this.generateListMessage("组聊", this.TRIGGER_DISZ, this.LISTENER_DISZ, this.EXECUTOR_DISZ);
		this.MESSAGE_LIST_GROP = this.generateListMessage("群聊", this.TRIGGER_GROP, this.LISTENER_GROP, this.EXECUTOR_GROP);

		return logger;

	}

	/**
	 * 你永远不应该执行这个方法
	 */
	@Override
	public LoggerX boot(LoggerX logger) throws Exception {

		// =======================================================================================================================
		// 启动定时器

		for (ModuleScheduler instance : this.SCHEDULER_ENABLED) {
			logger.full(Systemd.MODULE_PACKAGENAME, "启动定时器 ", instance.MODULE_PACKAGENAME());
			instance.boot(logger);
		}

		// =======================================================================================================================
		// 启动触发器

		for (String name : this.TRIGGER_INSTANCE.keySet()) {
			logger.full(Systemd.MODULE_PACKAGENAME, "启动触发器", name);
			ModuleTrigger instance = this.TRIGGER_INSTANCE.get(name);
			if (instance.ENABLE_USER() || instance.ENABLE_DISZ() || instance.ENABLE_GROP()) { instance.boot(logger); }
		}

		// =======================================================================================================================
		// 启动 监听器

		for (String name : this.LISTENER_INSTANCE.keySet()) {
			logger.full(Systemd.MODULE_PACKAGENAME, "启动监听器", name);
			ModuleListener instance = this.LISTENER_INSTANCE.get(name);
			if (instance.ENABLE_USER() || instance.ENABLE_DISZ() || instance.ENABLE_GROP()) { instance.boot(logger); }
		}

		// =======================================================================================================================
		// 启动执行器

		for (String name : this.EXECUTOR_INSTANCE.keySet()) {
			logger.full(Systemd.MODULE_PACKAGENAME, "启动执行器", name);
			ModuleExecutor instance = this.EXECUTOR_INSTANCE.get(name);
			if (instance.ENABLE_USER() || instance.ENABLE_DISZ() || instance.ENABLE_GROP()) { instance.boot(logger); }
		}

		return logger;

	}

	/**
	 * 你永远不应该执行这个方法
	 */
	@Override
	public LoggerX save(LoggerX logger) throws Exception {

		// =======================================================================================================================
		// 保存定时器

		for (String name : this.SCHEDULER_INSTANCE.keySet()) {
			logger.full(Systemd.MODULE_PACKAGENAME, "保存定时器", name);
			this.SCHEDULER_INSTANCE.get(name).save(logger);
		}

		// =======================================================================================================================
		// 保存触发器

		for (String name : this.TRIGGER_INSTANCE.keySet()) {
			logger.full(Systemd.MODULE_PACKAGENAME, "保存触发器", name);
			this.TRIGGER_INSTANCE.get(name).save(logger);
		}

		// =======================================================================================================================
		// 保存监听器

		for (String name : this.LISTENER_INSTANCE.keySet()) {
			logger.full(Systemd.MODULE_PACKAGENAME, "保存监听器", name);
			this.LISTENER_INSTANCE.get(name).save(logger);
		}

		// =======================================================================================================================
		// 保存执行器

		for (String name : this.EXECUTOR_INSTANCE.keySet()) {
			logger.full(Systemd.MODULE_PACKAGENAME, "保存执行器", name);
			this.EXECUTOR_INSTANCE.get(name).save(logger);
		}

		return logger;

	}

	/**
	 * 你永远不应该执行这个方法
	 */
	@Override
	public LoggerX shut(LoggerX logger) throws Exception {

		// =======================================================================================================================
		// 关闭定时器

		for (String name : this.SCHEDULER_INSTANCE.keySet()) {
			logger.full(Systemd.MODULE_PACKAGENAME, "关闭定时器", name);
			this.SCHEDULER_INSTANCE.get(name).shut(logger);
		}

		// =======================================================================================================================
		// 关闭触发器

		for (String name : this.TRIGGER_INSTANCE.keySet()) {
			logger.full(Systemd.MODULE_PACKAGENAME, "关闭触发器", name);
			this.TRIGGER_INSTANCE.get(name).shut(logger);
		}

		// =======================================================================================================================
		// 关闭监听器

		for (String name : this.LISTENER_INSTANCE.keySet()) {
			logger.full(Systemd.MODULE_PACKAGENAME, "关闭监听器", name);
			this.LISTENER_INSTANCE.get(name).shut(logger);
		}

		// =======================================================================================================================
		// 关闭执行器

		for (String name : this.EXECUTOR_INSTANCE.keySet()) {
			logger.full(Systemd.MODULE_PACKAGENAME, "关闭执行器", name);
			this.EXECUTOR_INSTANCE.get(name).shut(logger);
		}

		return logger;

	}

	/**
	 * 你永远不应该执行这个方法
	 */
	@Override
	public LoggerX exec(LoggerX logger, Message message) throws Exception {

		logger.info(LoggerX.datetime());

		String module = message.getSwitch("module");

		if (module == null) {
			logger.info(MODULE_PACKAGENAME, "参数错误 --module 为空");
			return logger;
		}

		logger.info(MODULE_PACKAGENAME, "指定模块", module);

		if (module.equals("systemd")) {

			logger.info(MODULE_PACKAGENAME, "指定功能", message.getSegment(1));
			logger.info(MODULE_PACKAGENAME, "指定命令", message.getSegment(2));

			if (message.getSection() < 2) {
				logger.info(MODULE_PACKAGENAME, "参数错误 缺少行为参数");
				return logger;
			}

			switch (message.getSegment(1)) {

			case "nickmap":

				switch (message.getSegment(2)) {

				case "dump":

					int i = 0;

					File allUserDump = Paths.get(this.FOLDER_LOGS.getAbsolutePath(), "nickdump_" + LoggerX.formatTime("yyyy_MM_dd_HH_mm_ss") + ".txt").toFile();

					allUserDump.createNewFile();

					FileWriter dumper = new FileWriter(allUserDump, true);

					for (Group group : entry.getCQ().getGroupList()) {

						dumper.append("#===========================\n#" + group.getName() + "(" + group.getId() + ")\n");

						for (Member memebr : entry.getCQ().getGroupMemberList(group.getId())) {
							if (this.isMyself(memebr.getQQId())) { continue; }
							dumper.append(group.getId() + ":" + memebr.getQQId() + ":" + this.getGropNick(group.getId(), memebr.getQQId()) + "\n");
							i++;
						}
					}

					dumper.flush();
					dumper.close();

					logger.info(MODULE_PACKAGENAME, "昵称转储", i + "个");

					break;

				case "save":

					this.FILE_NICKNAME_MAP.delete();
					this.FILE_NICKNAME_MAP.createNewFile();

					FileWriter saver = new FileWriter(this.FILE_NICKNAME_MAP, true);

					for (Group group : entry.getCQ().getGroupList()) {

						saver.append("#===========================\n#" + group.getName() + "(" + group.getId() + ")\n");

						for (Member memebr : entry.getCQ().getGroupMemberList(group.getId())) {
							if (this.isMyself(memebr.getQQId())) { continue; }
							saver.append(group.getId() + ":" + memebr.getQQId() + ":" + this.getGropNick(group.getId(), memebr.getQQId()) + "\n");
						}
					}

					saver.flush();
					saver.close();

					logger.info(MODULE_PACKAGENAME, "昵称保存");

					break;

				case "load":

					this.NICKNAME_MAP.clear();

					long gropid;
					long userid;
					String line;
					String[] temp;

					BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(this.FILE_NICKNAME_MAP), StandardCharsets.UTF_8));

					while ((line = reader.readLine()) != null) {

						if (line.startsWith("#")) { continue; }
						if (!line.contains(":")) { continue; }
						if (line.contains("#")) { line = line.substring(0, line.indexOf("#")).trim(); }

						temp = line.split(":");

						if (temp.length != 3) {
							logger.seek(MODULE_PACKAGENAME, "此行配置无效", line);
							continue;
						}

						gropid = Long.parseLong(temp[0]);
						userid = Long.parseLong(temp[1]);

						if (!this.NICKNAME_MAP.containsKey(gropid)) { this.NICKNAME_MAP.put(gropid, new TreeMap<Long, String>()); }

						this.NICKNAME_MAP.get(gropid).put(userid, temp[2]);

						reader.close();

					}

					break;
				}

				break;

			}

		} else if (this.SCHEDULER_INSTANCE.containsKey(module)) {

			ModuleScheduler instance = this.SCHEDULER_INSTANCE.get(module);
			logger.info(MODULE_PACKAGENAME, "查找到定时器", instance.MODULE_PACKAGENAME());
			instance.exec(logger, message);

		} else if (this.TRIGGER_INSTANCE.containsKey(module)) {

			ModuleTrigger instance = this.TRIGGER_INSTANCE.get(module);
			logger.info(MODULE_PACKAGENAME, "查找到触发器", instance.MODULE_PACKAGENAME());
			instance.exec(logger, message);

		} else if (this.LISTENER_INSTANCE.containsKey(module)) {

			ModuleListener instance = this.LISTENER_INSTANCE.get(module);
			logger.info(MODULE_PACKAGENAME, "查找到监听器", instance.MODULE_PACKAGENAME());
			instance.exec(logger, message);

		} else if (this.EXECUTOR_INSTANCE.containsKey(module)) {

			ModuleExecutor instance = this.EXECUTOR_INSTANCE.get(module);
			logger.info(MODULE_PACKAGENAME, "查找到执行器", instance.MODULE_PACKAGENAME());
			instance.exec(logger, message);

		} else {

			logger.mini("模块不存在");

		}

		return logger;

	}

	// ==========================================================================================================================================================
	//
	// 事件处理
	//
	// ==========================================================================================================================================================

	/**
	 * 你永远不应该执行这个方法
	 */
	@Override
	public void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) throws Exception {

		FileWriter writer = new FileWriter(this.FILE_MEMBERCHANGE, true);

		if (this.isMyself(userid)) {

			writer.append("# Bot Join Group " + LoggerX.datetime() + "\n");
			for (Member memeber : entry.getCQ().getGroupMemberList(gropid)) {
				writer.append(gropid + ":" + memeber.getQQId() + ":" + entry.getCQ().getStrangerInfo(memeber.getQQId()).getNick() + "\n");
			}

		} else {

			writer.append("# Member Increase " + LoggerX.datetime() + "\n" + gropid + ":=" + userid + ":" + entry.getCQ().getStrangerInfo(userid).getNick() + "\n");
		}

		writer.flush();
		writer.close();

		for (String name : this.TRIGGER_INSTANCE.keySet()) {
			this.TRIGGER_INSTANCE.get(name).groupMemberIncrease(typeid, sendtime, gropid, operid, userid);
		}

		for (String name : this.LISTENER_INSTANCE.keySet()) {
			this.LISTENER_INSTANCE.get(name).groupMemberIncrease(typeid, sendtime, gropid, operid, userid);
		}

		for (String name : this.EXECUTOR_INSTANCE.keySet()) {
			this.EXECUTOR_INSTANCE.get(name).groupMemberIncrease(typeid, sendtime, gropid, operid, userid);
		}
	}

	/**
	 * 你永远不应该执行这个方法
	 */
	@Override
	public void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) throws Exception {

		for (String name : this.TRIGGER_INSTANCE.keySet()) {
			this.TRIGGER_INSTANCE.get(name).groupMemberDecrease(typeid, sendtime, gropid, operid, userid);
		}

		for (String name : this.LISTENER_INSTANCE.keySet()) {
			this.LISTENER_INSTANCE.get(name).groupMemberDecrease(typeid, sendtime, gropid, operid, userid);
		}

		for (String name : this.EXECUTOR_INSTANCE.keySet()) {
			this.EXECUTOR_INSTANCE.get(name).groupMemberDecrease(typeid, sendtime, gropid, operid, userid);
		}

	}

	// ==========================================================================================================================================================
	//
	// 消息处理
	//
	// ==========================================================================================================================================================

	/**
	 * 你永远不应该执行这个方法
	 *
	 * @param typeid      你永远不应该执行这个方法
	 * @param userid      你永远不应该执行这个方法
	 * @param message     你永远不应该执行这个方法
	 * @param messageid   你永远不应该执行这个方法
	 * @param messagefont 你永远不应该执行这个方法
	 * @throws Exception 你永远不应该执行这个方法
	 */
	public void doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {

		this.COUNT_USER_MESSAGE++;

		if (entry.DEBUG()) { entry.getCQ().logDebug("FurryBlack", message.toString()); }

		if (this.ENABLE_TRIGGER_USER) {
			for (ModuleTrigger temp : this.TRIGGER_USER) {
				if (temp.executeUserMessage(typeid, userid, message, messageid, messagefont)) { return; }
			}
		}

		if (this.ENABLE_LISENTER_USER) {
			for (ModuleListener temp : this.LISTENER_USER) {
				temp.executeUserMessage(typeid, userid, message, messageid, messagefont);
			}
		}

		if (message.parse().isCommand()) {

			switch (message.getCommand()) {

			case "info":
				this.sendInfo(userid);
				break;

			case "eula":
				this.sendEula(userid);
				break;

			case "list":
				this.sendListUser(userid);
				break;

			case "help":
				if (message.getSection() == 0) {
					this.sendHelp(userid);
				} else {
					this.sendHelp(userid, message.getSegment()[0]);
				}
				break;

			default:
				if (this.ENABLE_EXECUTOR_USER && this.EXECUTOR_USER.containsKey(message.getCommand())) {
					this.EXECUTOR_USER.get(message.getCommand()).executeUserMessage(typeid, userid, message, messageid, messagefont);
				} else {
					this.userInfo(userid, "没有此插件，可用插件如下");
					this.sendListUser(userid);
				}
				break;

			}
		} else {
			this.userInfo(userid, "未识别的内容，本BOT没有聊天功能，请使用/help查看帮助。");
		}
	}

	/**
	 * 你永远不应该执行这个方法
	 *
	 * @param diszid      你永远不应该执行这个方法
	 * @param userid      你永远不应该执行这个方法
	 * @param message     你永远不应该执行这个方法
	 * @param messageid   你永远不应该执行这个方法
	 * @param messagefont 你永远不应该执行这个方法
	 * @throws Exception 你永远不应该执行这个方法
	 */
	public void doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {

		this.COUNT_DISZ_MESSAGE++;

		if (entry.DEBUG()) { entry.getCQ().logDebug("FurryBlack", message.toString()); }

		if (this.ENABLE_TRIGGER_DISZ) {
			for (ModuleTrigger temp : this.TRIGGER_DISZ) {
				if (temp.executeDiszMessage(diszid, userid, message, messageid, messagefont)) { return; }
			}
		}

		if (this.ENABLE_LISENTER_DISZ) {
			for (ModuleListener temp : this.LISTENER_DISZ) {
				temp.executeDiszMessage(diszid, userid, message, messageid, messagefont);
			}
		}

		if (message.parse().isCommand()) {

			switch (message.getCommand()) {

			case "info":
				this.diszInfo(diszid, userid, "已发送至私聊，如未收到请允许临时会话或添加好友");
				this.sendInfo(userid);
				break;

			case "eula":
				this.diszInfo(diszid, userid, "已发送至私聊，如未收到请允许临时会话或添加好友");
				this.sendEula(userid);
				break;

			case "list":
				this.diszInfo(diszid, userid, "已发送至私聊，如未收到请允许临时会话或添加好友");
				this.sendListDisz(userid);
				break;

			case "help":
				if (message.getSection() == 0) {
					this.sendHelp(userid);
				} else {
					this.diszInfo(diszid, userid, "已发送至私聊，如未收到请允许临时会话或添加好友");
					this.sendHelp(userid, message.getSegment()[0]);
				}
				break;

			default:
				if (this.ENABLE_EXECUTOR_DISZ && this.EXECUTOR_DISZ.containsKey(message.getCommand())) {
					this.EXECUTOR_DISZ.get(message.getCommand()).executeDiszMessage(diszid, userid, message, messageid, messagefont);
				} else {
					this.diszInfo(diszid, userid, "没有此插件，可用插件已发送至私聊，如未收到请允许临时会话或添加好友");
					this.sendListDisz(userid);
				}
				break;

			}
		}
	}

	/**
	 * 你永远不应该执行这个方法
	 *
	 * @param gropid      你永远不应该执行这个方法
	 * @param userid      你永远不应该执行这个方法
	 * @param message     你永远不应该执行这个方法
	 * @param messageid   你永远不应该执行这个方法
	 * @param messagefont 你永远不应该执行这个方法
	 * @throws Exception 你永远不应该执行这个方法
	 */
	public void doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {

		this.COUNT_GROP_MESSAGE++;

		if (entry.DEBUG()) { entry.getCQ().logDebug("FurryBlack", message.toString()); }

		if (this.ENABLE_TRIGGER_GROP) {
			for (ModuleTrigger temp : this.TRIGGER_GROP) {
				if (temp.executeGropMessage(gropid, userid, message, messageid, messagefont)) { return; }
			}
		}

		if (this.ENABLE_LISENTER_GROP) {
			for (ModuleListener temp : this.LISTENER_GROP) {
				temp.executeGropMessage(gropid, userid, message, messageid, messagefont);
			}
		}

		if (message.parse().isCommand()) {

			switch (message.getCommand()) {

			case "info":
				this.gropInfo(gropid, userid, "已发送至私聊，如未收到请允许临时会话或添加好友");
				this.sendInfo(userid);
				break;

			case "eula":
				this.gropInfo(gropid, userid, "已发送至私聊，如未收到请允许临时会话或添加好友");
				this.sendEula(userid);
				break;

			case "list":
				this.gropInfo(gropid, userid, "已发送至私聊，如未收到请允许临时会话或添加好友");
				this.sendListGrop(userid);
				break;

			case "help":
				if (message.getSection() == 0) {
					this.sendHelp(userid);
				} else {
					this.gropInfo(gropid, userid, "已发送至私聊，如未收到请允许临时会话或添加好友");
					this.sendHelp(userid, message.getSegment()[0]);
				}
				break;

			default:
				if (this.ENABLE_EXECUTOR_GROP && this.EXECUTOR_GROP.containsKey(message.getCommand())) {
					this.EXECUTOR_GROP.get(message.getCommand()).executeGropMessage(gropid, userid, message, messageid, messagefont);
				} else {
					this.gropInfo(gropid, userid, "没有此插件，可用插件已发送至私聊，如未收到请允许临时会话或添加好友");
					this.sendListGrop(userid);
				}
				break;

			}
		}
	}

	// ==========================================================================================================================================================
	//
	// 辅助管理
	//
	// ==========================================================================================================================================================

	private void instantiationScheduler(ModuleScheduler instance) {
		this.SCHEDULER_INSTANCE.put(instance.MODULE_COMMANDNAME(), instance);
	}

	private void instantiationTrigger(ModuleTrigger instance) {
		this.TRIGGER_INSTANCE.put(instance.MODULE_COMMANDNAME(), instance);
	}

	private void instantiationListener(ModuleListener instance) {
		this.LISTENER_INSTANCE.put(instance.MODULE_COMMANDNAME(), instance);
	}

	private void instantiationExecutor(ModuleExecutor instance) {
		this.EXECUTOR_INSTANCE.put(instance.MODULE_COMMANDNAME(), instance);
	}

	// ==========================================================================================================================================================
	//
	// 工具函数
	//
	// ==========================================================================================================================================================

	/**
	 * 生成报告的方法 你永远不应该执行这个方法
	 */
	@Override
	public String[] generateReport(int mode, Message message, Object... parameters) {

		String[] report = new String[] {
				"无可用消息"
		};

		switch (mode) {

		// 模式0 - 系统运行状态 即 systemd 自身
		case 0x00:

			StringBuilder builder = new StringBuilder();

			long uptime = System.currentTimeMillis() - entry.BOOTTIME;
			long uptimedd = uptime / 86400000;
			uptime = uptime % 86400000;
			long uptimehh = uptime / 3600000;
			uptime = uptime % 3600000;
			long uptimemm = uptime / 60000;
			uptime = uptime % 60000;
			long uptimess = uptime / 1000;

			long totalMemory = Runtime.getRuntime().totalMemory() / 1024;
			long freeMemory = Runtime.getRuntime().freeMemory() / 1024;

			builder.append(LoggerX.datetime() + " - 状态简报" + "\r\n");

			builder.append("运行时间：" + uptimedd + " - " + uptimehh + ":" + uptimemm + ":" + uptimess + "\r\n");
			builder.append("系统内存：" + (totalMemory - freeMemory) + "KB/" + totalMemory + "KB" + "\r\n");

			builder.append("私聊：" + this.COUNT_USER_MESSAGE + "次" + "\r\n");
			builder.append("组聊：" + this.COUNT_DISZ_MESSAGE + "次" + "\r\n");
			builder.append("群聊：" + this.COUNT_GROP_MESSAGE + "次" + "\r\n");

			builder.append("定时器：" + this.SCHEDULER_ENABLED.size() + "个" + "\r\n");
			for (ModuleScheduler instance : this.SCHEDULER_ENABLED) {
				if (instance.ENABLE()) { builder.append(instance.MODULE_PACKAGENAME() + "：" + instance.COUNT() + "\r\n"); }
			}

			builder.append("触发器：" + this.TRIGGER_USER.size() + "/" + this.TRIGGER_DISZ.size() + "/" + this.TRIGGER_GROP.size() + "个" + "\r\n");

			for (String temp : this.TRIGGER_INSTANCE.keySet()) {

				ModuleTrigger instance = this.TRIGGER_INSTANCE.get(temp);

				if (instance.ENABLE_USER() || instance.ENABLE_DISZ() || instance.ENABLE_GROP()) { continue; }

				builder.append(instance.MODULE_PACKAGENAME() + "：");
				builder.append(instance.ENABLE_USER() ? instance.BLOCK_USER() : "关");
				builder.append("/");
				builder.append(instance.ENABLE_DISZ() ? instance.BLOCK_DISZ() : "关");
				builder.append("/");
				builder.append(instance.ENABLE_GROP() ? instance.BLOCK_GROP() : "关");

				builder.append("\r\n");
			}

			builder.append("监听器：" + this.LISTENER_USER.size() + "/" + this.LISTENER_DISZ.size() + "/" + this.LISTENER_GROP.size() + "个" + "\r\n");

			for (String temp : this.LISTENER_INSTANCE.keySet()) {

				ModuleListener instance = this.LISTENER_INSTANCE.get(temp);

				if (instance.ENABLE_USER() || instance.ENABLE_DISZ() || instance.ENABLE_GROP()) { continue; }

				builder.append(instance.MODULE_PACKAGENAME() + "：");
				builder.append(instance.ENABLE_USER() ? instance.COUNT_USER() : "关");
				builder.append("/");
				builder.append(instance.ENABLE_DISZ() ? instance.COUNT_DISZ() : "关");
				builder.append("/");
				builder.append(instance.ENABLE_GROP() ? instance.COUNT_GROP() : "关");

				builder.append("\r\n");
			}

			builder.append("执行器：" + this.EXECUTOR_USER.size() + "/" + this.EXECUTOR_DISZ.size() + "/" + this.EXECUTOR_GROP.size() + "个" + "\r\n");

			for (String temp : this.EXECUTOR_INSTANCE.keySet()) {

				ModuleExecutor instance = this.EXECUTOR_INSTANCE.get(temp);

				if (instance.ENABLE_USER() || instance.ENABLE_DISZ() || instance.ENABLE_GROP()) { continue; }

				builder.append(instance.MODULE_PACKAGENAME() + "：");
				builder.append(instance.ENABLE_USER() ? instance.COUNT_USER() : "关");
				builder.append("/");
				builder.append(instance.ENABLE_DISZ() ? instance.COUNT_DISZ() : "关");
				builder.append("/");
				builder.append(instance.ENABLE_GROP() ? instance.COUNT_GROP() : "关");

				builder.append("\r\n");
			}

			report = new String[] {
					builder.substring(0, builder.length() - 2).toString()
			};

			break;

		// 模式10 - 模块简报 如不包含 module 开关 则生成所有模块的简报
		case 0x0A:

			boolean hasModule = message.hasSwitch("module");

			if (hasModule) {

				// 包含 module 开关

				String module = message.getSwitch("module");

				if (module.contains(":")) {

					String temp[] = module.split(":");
					String name = temp[0];
					int submode = Integer.parseInt(temp[1]);

					if (name.equals("systemd")) {
						// /admin report --module=systemd:$
						report = this.generateReport(0, message, null, null);
					} else if (this.TRIGGER_INSTANCE.containsKey(name)) {
						// /admin report --module=userdeny:0
						report = this.TRIGGER_INSTANCE.get(name).generateReport(submode, message, null, null);
					} else if (this.LISTENER_INSTANCE.containsKey(name)) {
						// /admin report --module=shui:10 --group=1234567890
						report = this.LISTENER_INSTANCE.get(name).generateReport(submode, message, null, null);
					} else if (this.EXECUTOR_INSTANCE.containsKey(name)) {
						// /admin report --module=acon --group=1234567890
						report = this.EXECUTOR_INSTANCE.get(name).generateReport(submode, message, null, null);
					} else {
						report[0] = "模块不存在";
					}

				} else {
					report[0] = "module参数错误：" + module;
				}

			} else {

				// 不包含 module 开关

				StringBuilder builder01 = new StringBuilder();
				StringBuilder builder02 = new StringBuilder();
				StringBuilder builder03 = new StringBuilder();
				StringBuilder builder04 = new StringBuilder();

				// part 1 定时器

				builder01.append("定时器：" + this.SCHEDULER_ENABLED.size() + "个" + "\r\n");

				for (ModuleScheduler instance : this.SCHEDULER_ENABLED) {

					String[] temp = instance.generateReport(0, message, null, null);

					if (temp == null) { builder01.append(instance.MODULE_PACKAGENAME() + "：" + instance.COUNT() + "无\r\n"); }

				}

				// part 2 触发器

				builder02.append("触发器：" + this.TRIGGER_USER.size() + "/" + this.TRIGGER_DISZ.size() + "/" + this.TRIGGER_GROP.size() + "个" + "\r\n");

				for (String temp : this.TRIGGER_INSTANCE.keySet()) {

					ModuleTrigger instance = this.TRIGGER_INSTANCE.get(temp);

					if (!instance.ENABLE_USER() || !instance.ENABLE_DISZ() || !instance.ENABLE_GROP()) { continue; }

					builder02.append(instance.MODULE_PACKAGENAME() + "：");
					builder02.append(instance.ENABLE_USER() ? instance.BLOCK_USER() : "关");
					builder02.append("/");
					builder02.append(instance.ENABLE_DISZ() ? instance.BLOCK_DISZ() : "关");
					builder02.append("/");
					builder02.append(instance.ENABLE_GROP() ? instance.BLOCK_GROP() : "关");
					builder02.append("\r\n");

					String[] tempReport = instance.generateReport(0, message, null, null);

					if (tempReport == null) { continue; }

					for (String part : tempReport) {
						builder02.append(part);
						builder02.append("\r\n");
					}

					builder02.append("\r\n");
				}

				// part 3 监听器

				builder03.append("监听器：" + this.LISTENER_USER.size() + "/" + this.LISTENER_DISZ.size() + "/" + this.LISTENER_GROP.size() + "个" + "\r\n");

				for (String temp : this.LISTENER_INSTANCE.keySet()) {

					ModuleListener instance = this.LISTENER_INSTANCE.get(temp);

					if (!instance.ENABLE_USER() || !instance.ENABLE_DISZ() || !instance.ENABLE_GROP()) { continue; }

					builder03.append(instance.MODULE_PACKAGENAME() + "：");
					builder03.append(instance.ENABLE_USER() ? instance.COUNT_USER() : "关");
					builder03.append("/");
					builder03.append(instance.ENABLE_DISZ() ? instance.COUNT_DISZ() : "关");
					builder03.append("/");
					builder03.append(instance.ENABLE_GROP() ? instance.COUNT_GROP() : "关");
					builder03.append("\r\n");

					String[] tempReport = instance.generateReport(0, message, null, null);

					if (tempReport == null) { continue; }

					for (String part : tempReport) {
						builder03.append(part);
						builder03.append("\r\n");
					}

					builder03.append("\r\n");
				}

				// part 4 执行器

				builder04.append("执行器：" + this.EXECUTOR_USER.size() + "/" + this.EXECUTOR_DISZ.size() + "/" + this.EXECUTOR_GROP.size() + "个" + "\r\n");

				for (String temp : this.EXECUTOR_INSTANCE.keySet()) {

					ModuleExecutor instance = this.EXECUTOR_INSTANCE.get(temp);

					if (!instance.ENABLE_USER() || !instance.ENABLE_DISZ() || !instance.ENABLE_GROP()) { continue; }

					builder04.append(instance.MODULE_PACKAGENAME() + "：");
					builder04.append(instance.ENABLE_USER() ? instance.COUNT_USER() : "关");
					builder04.append("/");
					builder04.append(instance.ENABLE_DISZ() ? instance.COUNT_DISZ() : "关");
					builder04.append("/");
					builder04.append(instance.ENABLE_GROP() ? instance.COUNT_GROP() : "关");
					builder04.append("\r\n");

					String[] tempReport = instance.generateReport(0, message, null, null);

					if (tempReport == null) { continue; }

					for (String part : tempReport) {
						builder04.append(part);
						builder04.append("\r\n");
					}

					builder04.append("\r\n");
				}

				report = new String[] {
						builder01.substring(0, builder01.length() - 2).toString(),
						builder02.substring(0, builder02.length() - 2).toString(),
						builder03.substring(0, builder03.length() - 2).toString(),
						builder04.substring(0, builder04.length() - 2).toString(),
				};

			}

			break;

		}

		return report;
	}

	/**
	 * 你永远不应该执行这个方法
	 *
	 * @param level 你永远不应该执行这个方法
	 * @return 你永远不应该执行这个方法
	 * @throws Exception 你永远不应该执行这个方法
	 */
	public LoggerX doInit(int level) throws Exception {

		LoggerX logger = new LoggerX();

		logger.info(LoggerX.datetime());

		switch (level) {

		case 0:
			logger.info("init 0：切换启停");
			if (entry.isEnable()) {
				entry.setEnable(false);
				logger.info("切换至停机");
			} else {
				entry.setEnable(true);
				logger.info("切换至运行");
			}
			break;

		case 1:
			logger.info("init 1：初始化");
			Systemd.this.init(logger);
			break;

		case 2:
			logger.info("init 2：启动");
			Systemd.this.boot(logger);
			break;

		case 3:
			logger.info("init 3：保存");
			Systemd.this.save(logger);
			break;

		case 4:
			logger.info("init 4：关闭丢弃");
			Systemd.this.shut(logger);
			break;

		case 5:
			logger.info("init 5：保存关闭");
			Systemd.this.save(logger);
			Systemd.this.shut(logger);
			break;

		case 6:
			logger.info("init 6：保存重启");
			Systemd.this.save(logger);
			Systemd.this.shut(logger);
			Systemd.this.boot(logger);
			break;

		}

		return logger;
	}

	/**
	 * 生成list命令发送的内容 你永远不应该执行这个方法
	 *
	 * @param flagname  标题名字
	 * @param triggers  触发器列表
	 * @param listeners 监听器列表
	 * @param executors 执行器列表
	 * @return 生成好的/list
	 */
	private String generateListMessage(String flagname, ArrayList<ModuleTrigger> triggers, ArrayList<ModuleListener> listeners, TreeMap<String, ModuleExecutor> executors) {

		StringBuilder builder = new StringBuilder();

		builder.append("=================\r\n" + flagname + "启用的模块\r\n=================\r\n启用的触发器：");

		if (triggers.size() == 0) {
			builder.append("无\r\n");
		} else {
			builder.append(triggers.size() + "\r\n");
			for (ModuleTrigger module : triggers) {
				builder.append(module.MODULE_COMMANDNAME() + " > " + module.MODULE_DISPLAYNAME() + "：" + module.MODULE_DESCRIPTION() + "\r\n");
			}
		}

		builder.append("=================\r\n启用的监听器：");

		if (listeners.size() == 0) {
			builder.append("无\r\n");
		} else {
			builder.append(listeners.size() + "\r\n");
			for (ModuleListener module : listeners) {
				builder.append(module.MODULE_COMMANDNAME() + " > " + module.MODULE_DISPLAYNAME() + "：" + module.MODULE_DESCRIPTION() + "\r\n");
			}
		}

		builder.append("\r\n=================\r\n可用的执行器： ");

		if (executors.size() == 0) {
			builder.append("无\r\n");
		} else {
			builder.append(executors.size() + "\r\n");
			for (String temp : executors.keySet()) {
				ModuleExecutor module = executors.get(temp);
				module.genFullHelp();
				builder.append(module.MODULE_COMMANDNAME() + " > " + module.MODULE_DISPLAYNAME() + "：" + module.MODULE_DESCRIPTION() + "\r\n");
			}
		}

		builder.append("=================");

		return builder.toString();

	}

	public static String sha1(String message) {

		try {

			StringBuffer hexString = new StringBuffer();
			MessageDigest messageDigest = MessageDigest.getInstance("SHA-1");
			byte[] hashBytes = messageDigest.digest(message.getBytes(StandardCharsets.UTF_8));

			for (byte hashByte : hashBytes) {
				int value = (hashByte) & 0xff;
				if (value < 16) { hexString.append("0"); }
				hexString.append(Integer.toHexString(value));
			}
			return hexString.toString();

		} catch (Exception exception) {
			return null;
		}

	}

	// ==========================================================================================================================================================
	//
	// 消息发送
	//
	// ==========================================================================================================================================================

	/**
	 * 判断一个ID是否为BOT自身 entry对此方法进行了转发请勿在此执行
	 *
	 * @param userid 用户ID
	 * @return 是 / 否
	 */
	public boolean isMyself(long userid) {
		return this.USERID_CQBOT == userid;
	}

	/**
	 * 判断一个ID是否为管理员（JCQ设置的管理，并非QQ群管理） entry对此方法进行了转发请勿在此执行
	 *
	 * @param userid 用户ID
	 * @return 是 / 否
	 */
	public boolean isAdmin(long userid) {
		return this.USERID_ADMIN == userid;
	}

	/**
	 * 给管理员发消息 entry对此方法进行了转发请勿在此执行
	 *
	 * @param message 消息
	 */
	public void adminInfo(String message) {
		entry.getCQ().sendPrivateMsg(this.USERID_ADMIN, message);
	}

	/**
	 * 给管理员发消息 entry对此方法进行了转发请勿在此执行
	 *
	 * @param message 消息
	 */
	public void adminInfo(String[] message) {
		for (String temp : message) {
			entry.getCQ().sendPrivateMsg(this.USERID_ADMIN, temp);
		}
	}

	/**
	 * 给用户发私聊 entry对此方法进行了转发请勿在此执行
	 *
	 * @param userid  用户ID
	 * @param message 消息
	 */
	public void userInfo(long userid, String message) {
		entry.getCQ().sendPrivateMsg(userid, message);
	}

	/**
	 * 给用户发私聊 entry对此方法进行了转发请勿在此执行
	 *
	 * @param userid  用户ID
	 * @param message 消息
	 */
	public void userInfo(long userid, String[] message) {
		for (String temp : message) {
			entry.getCQ().sendPrivateMsg(userid, temp);
		}
	}

	/**
	 * 在讨论组发消息 entry对此方法进行了转发请勿在此执行
	 *
	 * @param diszid  讨论组ID
	 * @param message 消息
	 */
	public void diszInfo(long diszid, String message) {
		entry.getCQ().sendDiscussMsg(diszid, message);
	}

	/**
	 * 在讨论组发消息 entry对此方法进行了转发请勿在此执行
	 *
	 * @param diszid  讨论组ID
	 * @param message 消息
	 */
	public void diszInfo(long diszid, String[] message) {
		for (String temp : message) {
			entry.getCQ().sendDiscussMsg(diszid, temp);
		}
	}

	/**
	 * 在讨论组发消息 并at某人 entry对此方法进行了转发请勿在此执行
	 *
	 * @param diszid  讨论组ID
	 * @param userid  用户ID
	 * @param message 消息
	 */
	public void diszInfo(long diszid, long userid, String message) {
		entry.getCQ().sendDiscussMsg(diszid, "[CQ:at,qq=" + userid + "] " + message);
	}

	/**
	 * 在群聊发消息 entry对此方法进行了转发请勿在此执行
	 *
	 * @param gropid  群组ID
	 * @param message 消息
	 */
	public void gropInfo(long gropid, String message) {
		if (this.MESSAGE_MUTE.contains(gropid)) {
			System.out.println("关闭发言 " + gropid + "：" + message);
		} else {
			entry.getCQ().sendGroupMsg(gropid, message);
		}
	}

	/**
	 * 在群聊发消息 entry对此方法进行了转发请勿在此执行
	 *
	 * @param gropid  群组ID
	 * @param message 消息
	 */
	public void gropInfo(long gropid, String[] message) {
		if (this.MESSAGE_MUTE.contains(gropid)) {
			System.out.println("关闭发言 " + gropid + "：" + message);
		} else {
			for (String temp : message) {
				entry.getCQ().sendGroupMsg(gropid, temp);
			}
		}
	}

	/**
	 * 在群聊发消息 并at某人 entry对此方法进行了转发请勿在此执行
	 *
	 * @param gropid  群组ID
	 * @param userid  用户ID
	 * @param message 消息
	 */
	public void gropInfo(long gropid, long userid, String message) {
		if (this.MESSAGE_MUTE.contains(gropid)) {
			System.out.println("关闭发言 " + gropid + "：" + message);
		} else {
			entry.getCQ().sendGroupMsg(gropid, "[CQ:at,qq=" + userid + "] " + message);
		}
	}

	/**
	 * 私聊某人 /info entry对此方法进行了转发请勿在此执行
	 *
	 * @param userid 用户ID
	 */
	public void sendInfo(long userid) {
		entry.getCQ().sendPrivateMsg(userid, this.MESSAGE_INFO);
	}

	/**
	 * 私聊某人 /eula entry对此方法进行了转发请勿在此执行
	 *
	 * @param userid 用户ID
	 */
	public void sendEula(long userid) {
		entry.getCQ().sendPrivateMsg(userid, this.MESSAGE_EULA);
	}

	/**
	 * 私聊某人 /help entry对此方法进行了转发请勿在此执行
	 *
	 * @param userid 用户ID
	 */
	public void sendHelp(long userid) {
		entry.getCQ().sendPrivateMsg(userid, this.MESSAGE_HELP);
	}

	/**
	 * 私聊某人 /help $name entry对此方法进行了转发请勿在此执行
	 *
	 * @param userid 用户ID
	 * @param name   模块名
	 */
	public void sendHelp(long userid, String name) {
		if (this.EXECUTOR_INSTANCE.containsKey(name)) {
			entry.getCQ().sendPrivateMsg(userid, this.EXECUTOR_INSTANCE.get(name).MODULE_FULLHELP);
		} else {
			entry.getCQ().sendPrivateMsg(userid, "不存在名叫" + name + "的模块。请使用/list查询。");
		}
	}

	/**
	 * 私聊某人 私聊模式/list entry对此方法进行了转发请勿在此执行
	 *
	 * @param userid 用户ID
	 */
	public void sendListUser(long userid) {
		entry.getCQ().sendPrivateMsg(userid, this.MESSAGE_LIST_USER);
	}

	/**
	 * 私聊某人 讨论组模式/list entry对此方法进行了转发请勿在此执行
	 *
	 * @param userid 用户ID
	 */
	public void sendListDisz(long userid) {
		entry.getCQ().sendPrivateMsg(userid, this.MESSAGE_LIST_DISZ);
	}

	/**
	 * 私聊某人 群组模式/list entry对此方法进行了转发请勿在此执行
	 *
	 * @param userid 用户ID
	 */
	public void sendListGrop(long userid) {
		entry.getCQ().sendPrivateMsg(userid, this.MESSAGE_LIST_GROP);
	}

	// ==========================================================================================================================================================
	//
	// 昵称映射
	//
	// ==========================================================================================================================================================

	/**
	 * 从昵称对应表查找昵称 entry对此方法进行了转发请勿在此执行
	 *
	 * @param userid 用户ID
	 * @return 昵称
	 */
	public String getNickname(long userid) {
		return entry.getCQ().getStrangerInfo(userid).getNick();
	}

	/**
	 * 从昵称对应表查找昵称 entry对此方法进行了转发请勿在此执行
	 *
	 * @param gropid 群组ID
	 * @param userid 用户ID
	 * @return 昵称
	 */
	public String getGropNick(long gropid, long userid) {
		if (this.NICKNAME_MAP.containsKey(gropid)) {
			TreeMap<Long, String> temp = this.NICKNAME_MAP.get(gropid);
			if (temp.containsKey(userid)) { return temp.get(userid); }
		}
		return entry.getCQ().getStrangerInfo(userid).getNick();
	}

	// ==========================================================================================================================================================
	//
	// 对象持有
	//
	// ==========================================================================================================================================================

	/**
	 * 获取定时器 entry对此方法进行了转发请勿在此执行
	 *
	 * @param name 名称
	 * @return 实例
	 */
	public ModuleScheduler getScheduler(String name) {
		return this.SCHEDULER_INSTANCE.get(name);
	}

	/**
	 * 获取触发器 entry对此方法进行了转发请勿在此执行
	 *
	 * @param name 名称
	 * @return 实例
	 */
	public ModuleTrigger getTrigger(String name) {
		return this.TRIGGER_INSTANCE.get(name);
	}

	/**
	 * 获取监听器 entry对此方法进行了转发请勿在此执行
	 *
	 * @param name 名称
	 * @return 实例
	 */
	public ModuleListener getListener(String name) {
		return this.LISTENER_INSTANCE.get(name);
	}

	/**
	 * 获取执行器 entry对此方法进行了转发请勿在此执行
	 *
	 * @param name 名称
	 * @return 实例
	 */
	public ModuleExecutor getExecutor(String name) {
		return this.EXECUTOR_INSTANCE.get(name);
	}
}
package studio.blacktech.coolqbot.furryblack.modules.Trigger;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.util.HashSet;
import java.util.TreeMap;

import studio.blacktech.coolqbot.furryblack.entry;
import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.message.Message;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleTrigger;

public class Trigger_UserDeny extends ModuleTrigger {

	private static final long serialVersionUID = 1L;

	// ==========================================================================================================================================================
	//
	// 模块基本配置
	//
	// ==========================================================================================================================================================

	private static String MODULE_PACKAGENAME = "Trigger_UserDeny";
	private static String MODULE_COMMANDNAME = "userdeny";
	private static String MODULE_DISPLAYNAME = "过滤器";
	private static String MODULE_DESCRIPTION = "用户过滤器";
	private static String MODULE_VERSION = "2.0";
	private static String[] MODULE_USAGE = new String[] {};
	private static String[] MODULE_PRIVACY_STORED = new String[] {
			"按照\"群-成员\"的层级关系手动配置被阻止的用户"
	};
	private static String[] MODULE_PRIVACY_CACHED = new String[] {};
	private static String[] MODULE_PRIVACY_OBTAIN = new String[] {};

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	private HashSet<Long> USER_IGNORE;
	private HashSet<Long> DISZ_IGNORE;
	private HashSet<Long> GROP_IGNORE;
	private TreeMap<Long, HashSet<Long>> DISZ_IGNORE_ONE;
	private TreeMap<Long, HashSet<Long>> GROP_IGNORE_ONE;

	private TreeMap<Long, Integer> DENY_USER_COUNT;
	private TreeMap<Long, TreeMap<Long, Integer>> DENY_DISZ_COUNT;
	private TreeMap<Long, TreeMap<Long, Integer>> DENY_GROP_COUNT;

	private File FILE_USERIGNORE;
	private File FILE_DISZIGNORE;
	private File FILE_GROPIGNORE;

	private File FILE_DENY_USER;
	private File FILE_DENY_DISZ;
	private File FILE_DENY_GROP;

	// ==========================================================================================================================================================
	//
	// 生命周期函数
	//
	// ==========================================================================================================================================================

	public Trigger_UserDeny() throws Exception {

		// @formatter:off

		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);

		// @formatter:on

	}

	@Override
	public LoggerX init(LoggerX logger) throws Exception {

		this.initAppFolder(logger);
		this.initConfFolder(logger);
		this.initLogsFolder(logger);

		this.USER_IGNORE = new HashSet<>(100);
		this.DISZ_IGNORE = new HashSet<>();
		this.GROP_IGNORE = new HashSet<>();
		this.DISZ_IGNORE_ONE = new TreeMap<>();
		this.GROP_IGNORE_ONE = new TreeMap<>();
		this.DENY_USER_COUNT = new TreeMap<>();
		this.DENY_DISZ_COUNT = new TreeMap<>();
		this.DENY_GROP_COUNT = new TreeMap<>();

		if (this.NEW_CONFIG) {
			this.CONFIG.setProperty("enable_user", "false");
			this.CONFIG.setProperty("enable_disz", "false");
			this.CONFIG.setProperty("enable_grop", "false");
			this.saveConfig();
		} else {
			this.loadConfig();
		}

		this.FILE_USERIGNORE = Paths.get(this.FOLDER_CONF.getAbsolutePath(), "ignore_user.txt").toFile();
		this.FILE_DISZIGNORE = Paths.get(this.FOLDER_CONF.getAbsolutePath(), "ignore_disz.txt").toFile();
		this.FILE_GROPIGNORE = Paths.get(this.FOLDER_CONF.getAbsolutePath(), "ignore_grop.txt").toFile();

		this.FILE_DENY_USER = Paths.get(this.FOLDER_LOGS.getAbsolutePath(), "ignore_user_log.txt").toFile();
		this.FILE_DENY_DISZ = Paths.get(this.FOLDER_LOGS.getAbsolutePath(), "ignore_disz_log.txt").toFile();
		this.FILE_DENY_GROP = Paths.get(this.FOLDER_LOGS.getAbsolutePath(), "ignore_grop_log.txt").toFile();

		if (!this.FILE_USERIGNORE.exists()) { this.FILE_USERIGNORE.createNewFile(); }
		if (!this.FILE_DISZIGNORE.exists()) { this.FILE_DISZIGNORE.createNewFile(); }
		if (!this.FILE_GROPIGNORE.exists()) { this.FILE_GROPIGNORE.createNewFile(); }

		if (!this.FILE_DENY_USER.exists()) { this.FILE_DENY_USER.createNewFile(); }
		if (!this.FILE_DENY_DISZ.exists()) { this.FILE_DENY_DISZ.createNewFile(); }
		if (!this.FILE_DENY_GROP.exists()) { this.FILE_DENY_GROP.createNewFile(); }

		this.ENABLE_USER = Boolean.parseBoolean(this.CONFIG.getProperty("enable_user", "false"));
		this.ENABLE_DISZ = Boolean.parseBoolean(this.CONFIG.getProperty("enable_disz", "false"));
		this.ENABLE_GROP = Boolean.parseBoolean(this.CONFIG.getProperty("enable_grop", "false"));

		BufferedReader readerUser = new BufferedReader(new InputStreamReader(new FileInputStream(this.FILE_USERIGNORE), StandardCharsets.UTF_8));
		BufferedReader readerDisz = new BufferedReader(new InputStreamReader(new FileInputStream(this.FILE_DISZIGNORE), StandardCharsets.UTF_8));
		BufferedReader readerGrop = new BufferedReader(new InputStreamReader(new FileInputStream(this.FILE_GROPIGNORE), StandardCharsets.UTF_8));

		long userid;
		long diszid;
		long gropid;
		String line;
		String[] temp;

		while ((line = readerUser.readLine()) != null) {
			if (line.startsWith("#")) { continue; }
			if (line.contains("#")) { line = line.substring(0, line.indexOf("#")).trim(); }
			this.USER_IGNORE.add(Long.parseLong(line));
			logger.seek(Trigger_UserDeny.MODULE_PACKAGENAME, "禁止私聊用户", line);
		}

		while ((line = readerDisz.readLine()) != null) {
			if (line.startsWith("#")) { continue; }
			if (!line.contains(":")) { continue; }
			if (line.contains("#")) { line = line.substring(0, line.indexOf("#")).trim(); }
			temp = line.split(":");
			diszid = Long.parseLong(temp[0]);
			userid = Long.parseLong(temp[1]);
			if (userid == 0) {
				this.DISZ_IGNORE.add(diszid);
			} else {
				if (!this.DISZ_IGNORE_ONE.containsKey(diszid)) {
					HashSet<Long> tempSet = new HashSet<>();
					this.DISZ_IGNORE_ONE.put(diszid, tempSet);
				}
				this.DISZ_IGNORE_ONE.get(diszid).add(userid);
			}
			logger.seek(Trigger_UserDeny.MODULE_PACKAGENAME, "禁止组聊用户", line);
		}

		while ((line = readerGrop.readLine()) != null) {
			if (line.startsWith("#")) { continue; }
			if (!line.contains(":")) { continue; }
			if (line.contains("#")) { line = line.substring(0, line.indexOf("#")).trim(); }
			temp = line.split(":");
			temp = line.split(":");
			gropid = Long.parseLong(temp[0]);
			userid = Long.parseLong(temp[1]);
			if (userid == 0) {
				this.GROP_IGNORE.add(gropid);
			} else {
				if (!this.GROP_IGNORE_ONE.containsKey(gropid)) {
					HashSet<Long> tempSet = new HashSet<>();
					this.GROP_IGNORE_ONE.put(gropid, tempSet);
				}
				this.GROP_IGNORE_ONE.get(gropid).add(userid);
			}
			logger.seek(Trigger_UserDeny.MODULE_PACKAGENAME, "禁止群聊用户", line);
		}

		readerUser.close();
		readerDisz.close();
		readerGrop.close();

		this.ENABLE_USER = this.ENABLE_USER && (this.USER_IGNORE.size() > 0);
		this.ENABLE_DISZ = this.ENABLE_DISZ && ((this.DISZ_IGNORE.size() + this.DISZ_IGNORE_ONE.size()) > 0);
		this.ENABLE_GROP = this.ENABLE_GROP && ((this.GROP_IGNORE.size() + this.GROP_IGNORE_ONE.size()) > 0);

		for (Long tempuserid : this.USER_IGNORE) {
			this.DENY_USER_COUNT.put(tempuserid, 0);
		}

		for (Long tempdiszid : this.DISZ_IGNORE_ONE.keySet()) {
			TreeMap<Long, Integer> tempcount = new TreeMap<>();
			HashSet<Long> tempdisz = this.DISZ_IGNORE_ONE.get(tempdiszid);
			for (Long tempuserid : tempdisz) {
				tempcount.put(tempuserid, 0);
			}
			this.DENY_DISZ_COUNT.put(tempdiszid, tempcount);
		}

		for (Long tempgropid : this.GROP_IGNORE_ONE.keySet()) {
			TreeMap<Long, Integer> tempcount = new TreeMap<>();
			HashSet<Long> tempgrop = this.GROP_IGNORE_ONE.get(tempgropid);
			for (Long tempuserid : tempgrop) {
				tempcount.put(tempuserid, 0);
			}
			this.DENY_GROP_COUNT.put(tempgropid, tempcount);
		}

		return logger;

	}

	@Override
	public LoggerX boot(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX save(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX shut(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX exec(LoggerX logger, Message message) throws Exception {
		return logger;
	}

	@Override
	public void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {

		if (this.USER_IGNORE.contains(userid)) {

			this.DENY_USER_COUNT.put(userid, this.DENY_USER_COUNT.get(userid) + 1);

			BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(this.FILE_DENY_USER, true), StandardCharsets.UTF_8));
			writer.write(message.toString());
			writer.write("\r\n\r\n\r\n\r\n");
			writer.flush();
			writer.close();

			return true;

		} else {

			return false;

		}
	}

	@Override
	public boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {

		if (this.USER_IGNORE.contains(userid)) {

			this.DENY_USER_COUNT.put(userid, this.DENY_USER_COUNT.get(userid) + 1);

		} else if (this.DISZ_IGNORE.contains(diszid) && this.DISZ_IGNORE_ONE.get(diszid).contains(userid)) {

			TreeMap<Long, Integer> temp = this.DENY_DISZ_COUNT.get(diszid);
			temp.put(userid, temp.get(userid) + 1);

		} else {

			return false;

		}

		BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(this.FILE_DENY_DISZ, true), StandardCharsets.UTF_8));
		writer.write(message.toString());
		writer.write("\r\n\r\n\r\n\r\n");
		writer.flush();
		writer.close();

		return true;
	}

	@Override
	public boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {

		if (this.USER_IGNORE.contains(userid)) {

			this.DENY_USER_COUNT.put(userid, this.DENY_USER_COUNT.get(userid) + 1);

		} else if (this.GROP_IGNORE.contains(gropid) && this.GROP_IGNORE_ONE.get(gropid).contains(userid)) {

			TreeMap<Long, Integer> temp = this.DENY_GROP_COUNT.get(gropid);
			temp.put(userid, temp.get(userid) + 1);

		} else {

			return false;

		}

		BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(this.FILE_DENY_GROP, true), StandardCharsets.UTF_8));
		writer.write(message.toString());
		writer.write("\r\n\r\n\r\n\r\n");
		writer.flush();
		writer.close();

		return true;
	}

	@Override
	public String[] generateReport(int mode, Message message, Object... parameters) {

		this.COUNT_USER = 0;
		this.COUNT_DISZ = 0;
		this.COUNT_GROP = 0;

		for (long userid : this.DENY_USER_COUNT.keySet()) {
			this.COUNT_USER = this.COUNT_USER + this.DENY_USER_COUNT.get(userid);
		}
		for (long diszid : this.DENY_DISZ_COUNT.keySet()) {
			TreeMap<Long, Integer> disz = this.DENY_DISZ_COUNT.get(diszid);
			for (long userid : disz.keySet()) {
				this.COUNT_DISZ = this.COUNT_DISZ + disz.get(userid);
			}
		}
		for (long gropid : this.DENY_GROP_COUNT.keySet()) {
			TreeMap<Long, Integer> grop = this.DENY_GROP_COUNT.get(gropid);
			for (long userid : grop.keySet()) {
				this.COUNT_GROP = this.COUNT_GROP + grop.get(userid);
			}
		}

		if ((this.COUNT_USER == 0) && (this.COUNT_DISZ == 0) && (this.COUNT_GROP == 0)) { return null; }

		StringBuilder builder = new StringBuilder();

		if (this.COUNT_USER == 0) {
			builder.append("拦截私聊：0");
		} else {
			builder.append("拦截私聊：");
			builder.append(this.COUNT_USER);
			for (long userid : this.DENY_USER_COUNT.keySet()) {
				builder.append("\r\n");
				builder.append(entry.getNickname(userid));
				builder.append(" (");
				builder.append(userid);
				builder.append(") ");
				builder.append(this.DENY_USER_COUNT.get(userid));
			}
		}

		if (this.COUNT_DISZ == 0) {
			builder.append("\r\n拦截组聊：0");
		} else {
			builder.append("\r\n拦截组聊：");
			builder.append(this.COUNT_DISZ);
			builder.append("\r\n");
			for (long diszid : this.DENY_DISZ_COUNT.keySet()) {
				TreeMap<Long, Integer> disz = this.DENY_DISZ_COUNT.get(diszid);
				builder.append("组号：");
				builder.append(diszid);
				for (long userid : disz.keySet()) {
					builder.append("\r\n");
					builder.append(entry.getNickname(userid));
					builder.append(" (");
					builder.append(userid);
					builder.append(") ");
					builder.append(disz.get(userid));
				}
			}
		}

		if (this.COUNT_GROP == 0) {
			builder.append("\r\n拦截群聊：0");
		} else {
			builder.append("\r\n拦截群聊：");
			builder.append(this.COUNT_GROP);
			builder.append("\r\n");
			for (long gropid : this.DENY_GROP_COUNT.keySet()) {
				TreeMap<Long, Integer> grop = this.DENY_GROP_COUNT.get(gropid);
				builder.append(" 群号：");
				builder.append(gropid);
				for (long userid : grop.keySet()) {
					builder.append("\r\n");
					builder.append(entry.getNickname(userid));
					builder.append(" (");
					builder.append(userid);
					builder.append(") ");
					builder.append(grop.get(userid));
				}
			}
		}
		String[] res = new String[] {
				builder.toString()
		};
		return res;
	}

}
package studio.blacktech.coolqbot.furryblack.modules.Trigger;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedList;
import java.util.TreeMap;
import java.util.regex.Pattern;

import studio.blacktech.coolqbot.furryblack.entry;
import studio.blacktech.coolqbot.furryblack.common.LoggerX.LoggerX;
import studio.blacktech.coolqbot.furryblack.common.message.Message;
import studio.blacktech.coolqbot.furryblack.common.message.MessageDisz;
import studio.blacktech.coolqbot.furryblack.common.message.MessageGrop;
import studio.blacktech.coolqbot.furryblack.common.message.MessageUser;
import studio.blacktech.coolqbot.furryblack.common.module.ModuleTrigger;

public class Trigger_WordDeny extends ModuleTrigger {

	private static final long serialVersionUID = 1L;

	// ==========================================================================================================================================================
	//
	// 模块基本配置
	//
	// ==========================================================================================================================================================

	private static String MODULE_PACKAGENAME = "Trigger_WordDeny";
	private static String MODULE_COMMANDNAME = "worddeny";
	private static String MODULE_DISPLAYNAME = "过滤器";
	private static String MODULE_DESCRIPTION = "正则过滤器";
	private static String MODULE_VERSION = "2.0";
	private static String[] MODULE_USAGE = new String[] {};
	private static String[] MODULE_PRIVACY_STORED = new String[] {
			"按照\"成员-消息\"的层级关系记录违反ELUA的行为"
	};
	private static String[] MODULE_PRIVACY_CACHED = new String[] {};
	private static String[] MODULE_PRIVACY_OBTAIN = new String[] {};

	// ==========================================================================================================================================================
	//
	// 成员变量
	//
	// ==========================================================================================================================================================

	private ArrayList<String> BLACKLIST;

	private File FILE_BLACKLIST;

	private File FILE_DENY_USER;
	private File FILE_DENY_DISZ;
	private File FILE_DENY_GROP;

	private TreeMap<String, LinkedList<MessageUser>> BLOCK_USER_STORE;
	private TreeMap<String, LinkedList<MessageDisz>> BLOCK_DISZ_STORE;
	private TreeMap<String, LinkedList<MessageGrop>> BLOCK_GROP_STORE;

	// ==========================================================================================================================================================
	//
	// 生命周期函数
	//
	// ==========================================================================================================================================================

	public Trigger_WordDeny() throws Exception {

		// @formatter:off

		super(
				MODULE_PACKAGENAME,
				MODULE_COMMANDNAME,
				MODULE_DISPLAYNAME,
				MODULE_DESCRIPTION,
				MODULE_VERSION,
				MODULE_USAGE,
				MODULE_PRIVACY_STORED,
				MODULE_PRIVACY_CACHED,
				MODULE_PRIVACY_OBTAIN
				);

		// @formatter:on

	}

	@Override
	public LoggerX init(LoggerX logger) throws Exception {

		this.initAppFolder(logger);
		this.initConfFolder(logger);
		this.initLogsFolder(logger);

		this.BLACKLIST = new ArrayList<>(100);

		this.BLOCK_USER_STORE = new TreeMap<>();
		this.BLOCK_DISZ_STORE = new TreeMap<>();
		this.BLOCK_GROP_STORE = new TreeMap<>();

		if (this.NEW_CONFIG) {
			this.CONFIG.setProperty("enable_user", "false");
			this.CONFIG.setProperty("enable_disz", "false");
			this.CONFIG.setProperty("enable_grop", "false");
			this.saveConfig();
		} else {
			this.loadConfig();
		}

		this.ENABLE_USER = Boolean.parseBoolean(this.CONFIG.getProperty("enable_user", "false"));
		this.ENABLE_DISZ = Boolean.parseBoolean(this.CONFIG.getProperty("enable_disz", "false"));
		this.ENABLE_GROP = Boolean.parseBoolean(this.CONFIG.getProperty("enable_grop", "false"));

		this.FILE_BLACKLIST = Paths.get(this.FOLDER_CONF.getAbsolutePath(), "blacklist.txt").toFile();
		this.FILE_DENY_USER = Paths.get(this.FOLDER_LOGS.getAbsolutePath(), "denied_user_log.txt").toFile();
		this.FILE_DENY_DISZ = Paths.get(this.FOLDER_LOGS.getAbsolutePath(), "denied_disz_log.txt").toFile();
		this.FILE_DENY_GROP = Paths.get(this.FOLDER_LOGS.getAbsolutePath(), "denied_grop_log.txt").toFile();

		if (!this.FILE_BLACKLIST.exists()) { this.FILE_BLACKLIST.createNewFile(); }
		if (!this.FILE_DENY_USER.exists()) { this.FILE_DENY_USER.createNewFile(); }
		if (!this.FILE_DENY_DISZ.exists()) { this.FILE_DENY_DISZ.createNewFile(); }
		if (!this.FILE_DENY_GROP.exists()) { this.FILE_DENY_GROP.createNewFile(); }

		BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(this.FILE_BLACKLIST), StandardCharsets.UTF_8));

		String line;
		while ((line = reader.readLine()) != null) {
			if (line.startsWith("#")) { continue; }
			if (line.contains("#")) { line = line.substring(0, line.indexOf("#")); }
			this.BLACKLIST.add(line.trim());
			logger.seek(Trigger_WordDeny.MODULE_PACKAGENAME, "过滤规则", line);
		}
		reader.close();

		boolean temp = this.BLACKLIST.size() > 0;

		this.ENABLE_USER = this.ENABLE_USER && temp;
		this.ENABLE_DISZ = this.ENABLE_DISZ && temp;
		this.ENABLE_GROP = this.ENABLE_GROP && temp;

		for (String templine : this.BLACKLIST) {
			this.BLOCK_USER_STORE.put(templine, new LinkedList<>());
			this.BLOCK_DISZ_STORE.put(templine, new LinkedList<>());
			this.BLOCK_GROP_STORE.put(templine, new LinkedList<>());
		}

		return logger;

	}

	@Override
	public LoggerX boot(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX save(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX shut(LoggerX logger) throws Exception {
		return logger;
	}

	@Override
	public LoggerX exec(LoggerX logger, Message message) throws Exception {
		return logger;
	}

	@Override
	public void groupMemberIncrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public void groupMemberDecrease(int typeid, int sendtime, long gropid, long operid, long userid) {
	}

	@Override
	public boolean doUserMessage(int typeid, long userid, MessageUser message, int messageid, int messagefont) throws Exception {
		for (String temp : this.BLACKLIST) {
			if (Pattern.matches(temp, message.getRawMessage())) {
				entry.adminInfo("私聊过滤：" + entry.getNickname(userid) + "(" + userid + ")" + message.getRawMessage());
				this.BLOCK_USER_STORE.get(temp).add(message);
				FileWriter writer = new FileWriter(this.FILE_DENY_USER, true);
				writer.write(message.toString());
				writer.write("\n\n\n\n");
				writer.flush();
				writer.close();
				return true;
			}
		}
		return false;
	}

	@Override
	public boolean doDiszMessage(long diszid, long userid, MessageDisz message, int messageid, int messagefont) throws Exception {
		for (String temp : this.BLACKLIST) {
			if (Pattern.matches(temp, message.getRawMessage())) {
				entry.adminInfo("组聊过滤：" + diszid + " - " + entry.getNickname(userid) + "(" + userid + ")" + message.getRawMessage());
				this.BLOCK_DISZ_STORE.get(temp).add(message);
				FileWriter writer = new FileWriter(this.FILE_DENY_DISZ, true);
				writer.write(message.toString());
				writer.write("\n\n\n\n");
				writer.flush();
				writer.close();
				return true;
			}
		}
		return false;
	}

	@Override
	public boolean doGropMessage(long gropid, long userid, MessageGrop message, int messageid, int messagefont) throws Exception {
		for (String temp : this.BLACKLIST) {
			if (Pattern.matches(temp, message.getRawMessage())) {
				entry.adminInfo("群聊过滤：" + gropid + " - " + entry.getNickname(userid) + "(" + userid + ")" + message.getRawMessage());
				this.BLOCK_GROP_STORE.get(temp).add(message);
				FileWriter writer = new FileWriter(this.FILE_DENY_GROP, true);
				writer.write(message.toString());
				writer.write("\n\n\n\n");
				writer.flush();
				writer.close();
				return true;
			}
		}
		return false;
	}

	@Override
	public String[] generateReport(int mode, Message message, Object... parameters) {

		this.BLOCK_USER = 0;
		this.BLOCK_DISZ = 0;
		this.BLOCK_GROP = 0;

		for (String temp : this.BLOCK_USER_STORE.keySet()) {
			this.BLOCK_USER = this.BLOCK_USER + this.BLOCK_USER_STORE.get(temp).size();
		}

		for (String temp : this.BLOCK_DISZ_STORE.keySet()) {
			this.BLOCK_DISZ = this.BLOCK_DISZ + this.BLOCK_DISZ_STORE.get(temp).size();
		}

		for (String temp : this.BLOCK_GROP_STORE.keySet()) {
			this.BLOCK_GROP = this.BLOCK_GROP + this.BLOCK_GROP_STORE.get(temp).size();
		}

		if ((this.BLOCK_USER == 0) && (this.BLOCK_DISZ == 0) && (this.BLOCK_GROP == 0)) { return null; }

		String[] res;
		StringBuilder builder;

		if (mode == 0) {
			builder = new StringBuilder();
			builder.append("拦截私聊：");
			builder.append(this.BLOCK_USER);
			builder.append("\r\n拦截私聊：");
			builder.append(this.BLOCK_DISZ);
			builder.append("\r\n拦截私聊：");
			builder.append(this.BLOCK_GROP);
			res = new String[1];
			res[0] = builder.toString();
		} else {
			res = new String[3];
			builder = new StringBuilder();
			builder.append("拦截私聊：");
			builder.append(this.BLOCK_USER);
			if (this.COUNT_USER > 0) {
				LinkedList<MessageUser> blocks;
				for (String temp : this.BLOCK_USER_STORE.keySet()) {
					blocks = this.BLOCK_USER_STORE.get(temp);
					if (blocks.size() == 0) { continue; }
					builder.append("\r\n规则：\"");
					builder.append(temp);
					builder.append("\" - ");
					builder.append(blocks.size());
					builder.append("次");
					for (MessageUser block : blocks) {
						builder.append("\r\n");
						builder.append(LoggerX.datetime(new Date(block.getSendtime())));
						builder.append(" > ");
						builder.append(entry.getNickname(block.userid()));
						builder.append(" (");
						builder.append(block.userid());
						builder.append(") ");
						builder.append(block.getRawMessage());
					}
				}
				res[0] = builder.toString();
			}

			builder = new StringBuilder();
			builder.append("\r\n拦截组聊：");
			builder.append(this.BLOCK_DISZ);
			if (this.COUNT_DISZ > 0) {
				LinkedList<MessageDisz> blocks;
				for (String temp : this.BLOCK_DISZ_STORE.keySet()) {
					blocks = this.BLOCK_DISZ_STORE.get(temp);
					if (blocks.size() == 0) { continue; }
					builder.append("\r\n规则：\"");
					builder.append(temp);
					builder.append("\" - ");
					builder.append(blocks.size());
					builder.append("次");
					for (MessageDisz block : blocks) {
						builder.append("\r\n");
						builder.append(LoggerX.datetime(new Date(block.getSendtime())));
						builder.append(" > ");
						builder.append(entry.getNickname(block.userid()));
						builder.append(" (");
						builder.append(block.userid());
						builder.append(" [");
						builder.append(block.diszid());
						builder.append("]) ");
						builder.append(block.getRawMessage());
					}
				}
				res[1] = builder.toString();
			}

			builder = new StringBuilder();
			builder.append("\r\n拦截群聊：");
			builder.append(this.BLOCK_GROP);
			if (this.COUNT_GROP > 0) {
				LinkedList<MessageGrop> blocks;
				for (String temp : this.BLOCK_GROP_STORE.keySet()) {
					blocks = this.BLOCK_GROP_STORE.get(temp);
					if (blocks.size() == 0) { continue; }
					builder.append("\r\n规则：\"");
					builder.append(temp);
					builder.append("\" - ");
					builder.append(blocks.size());
					builder.append("次");
					for (MessageGrop block : blocks) {
						builder.append("\r\n");
						builder.append(LoggerX.datetime(new Date(block.getSendtime())));
						builder.append(" > ");
						builder.append(entry.getNickname(block.userid()));
						builder.append(" (");
						builder.append(block.userid());
						builder.append(" [");
						builder.append(block.gropid());
						builder.append("])：");
						builder.append(block.getRawMessage());
					}
				}
				res[2] = builder.toString();
			}
		}
		return res;
	}
}
// CoolQ的JSON解析器支持双斜线注释JcqSDK也支持
{
	"ret": 1,
	"apiver": 9,
	"name": "FurryBlack",
	"description": "小动物形象机器人",
	"author": "BlackTechStudio",
	"version": "1.0.0",
	"version_id": 1,
	"class": "studio.blacktech.coolqbot.furryblack.entry",
	"event": [
		{"id": 1001, "type": 1001, "priority": 30000, "name": "CoolQ启动",  "function": "startup"},
		{"id": 1002, "type": 1002, "priority": 30000, "name": "CoolQ关闭",  "function": "exit"},
		{"id": 1003, "type": 1003, "priority": 30000, "name": "JcqCQ启动",  "function": "enable"},
		{"id": 1004, "type": 1004, "priority": 30000, "name": "JcqCQ关闭",  "function": "disable"},
		{"id": 1,    "type": 21,   "priority": 30000, "name": "私聊消息",   "function": "privateMsg"},
		{"id": 2,    "type": 2,    "priority": 30000, "name": "群聊消息",   "function": "groupMsg"},
		{"id": 3,    "type": 4,    "priority": 30000, "name": "组聊消息",   "function": "discussMsg"},
		{"id": 7,    "type": 103,  "priority": 30000, "name": "群成员增加", "function": "groupMemberIncrease"},
		{"id": 6,    "type": 102,  "priority": 30000, "name": "群成员减少", "function": "groupMemberDecrease"},
		{"id": 10,   "type": 201,  "priority": 30000, "name": "好友已添加", "function": "friendAdd"},
		{"id": 8,    "type": 301,  "priority": 30000, "name": "好友添加",   "function": "requestAddFriend"},
		{"id": 9,    "type": 302,  "priority": 30000, "name": "群组添加",   "function": "requestAddGroup"},
		{"id": 5,    "type": 101,  "priority": 30000, "name": "群管理变动", "function": "groupAdmin"},
		{"id": 4,    "type": 11,   "priority": 30000, "name": "上传群文件", "function": "groupUpload"}
	],
  "auth": [
    20,  //获取Cookies 		getCookies / getCsrfToken
    30,  //接收语音 		getRecord
    101, //发送群聊 		sendGroupMsg
    103, //发送组聊 		sendDiscussMsg
    106, //发送私聊 		sendPrivateMsg
    110, //发送赞 			sendLike
    120, //置群员移除 		setGroupKick
    121, //置群员禁言 		setGroupBan
    122, //置群管理员 		setGroupAdmin
    123, //置全群禁言 		setGroupWholeBan
    124, //置匿名群员禁言 	setGroupAnonymousBan
    125, //置群匿名设置 	setGroupAnonymous
    126, //置群成员名片		setGroupCard
    127, //置群退出 		setGroupLeave
    128, //置群成员专属头衔 setGroupSpecialTitle
    130, //取群成员信息		getGroupMemberInfoV2 / getGroupMemberInfo
    131, //取陌生人信息 	getStrangerInfo
    140, //置讨论组退出 	setDiscussLeave
    150, //置好友添加请求 	setFriendAddRequest
    151, //置群添加请求		setGroupAddRequest
    160, //取群成员列表		getGroupMemberList
    161, //取群列表			getGroupList
    180  //撤回消息			deleteMsg
  ]
}